
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Telehash: buckets - Scattered Thoughts</title>
  <meta name="author" content="Jamie Brandon">

  
  <meta name="description" content="The other half of the routing table is the buckets which store node addresses. Usual disclaimer: none of this is properly tested yet. The Kademlia &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://scattered-thoughts.net/blog/2011/03/30/telehash-buckets">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Scattered Thoughts" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-18515092-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
<ul class="subscribe">
  <li><a href="https://github.com/jamii" rel="subscribe-github" title="@jamii on GitHub" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 50,0 C 22.385714,0 0,22.385714 0,50 0,77.614286 22.385714,100 50,100 77.614286,100 100,77.614286 100,50 100,22.385714 77.614286,0 50,0 z m 29.692858,79.692858 c -3.859184,3.859182 -8.351022,6.887754 -13.35,9.00306 -1.27041,0.536736 -2.560204,1.009184 -3.867348,1.415306 v -7.493878 c 0,-3.938774 -1.35102,-6.835714 -4.053062,-8.690816 1.692858,-0.163264 3.24694,-0.390816 4.663266,-0.683672 1.416326,-0.292858 2.913266,-0.716328 4.491838,-1.27041 1.57857,-0.55408 2.994896,-1.213264 4.247958,-1.97755 1.253062,-0.765306 2.458164,-1.758164 3.613266,-2.978572 1.155102,-1.220408 2.12449,-2.604082 2.905102,-4.15 0.780612,-1.545918 1.4,-3.40204 1.855102,-5.566326 0.455102,-2.164286 0.683674,-4.54898 0.683674,-7.153062 0,-5.045918 -1.643878,-9.341836 -4.931634,-12.890816 C 77.44796,33.35 77.285714,29.10204 75.463266,24.512244 l -1.22143,-0.145918 c -0.845918,-0.09796 -2.368366,0.260204 -4.565306,1.07449 -2.196938,0.814286 -4.663264,2.14796 -7.396938,4.004082 -3.87449,-1.07449 -7.893878,-1.611224 -12.061224,-1.611224 -4.19898,0 -8.203062,0.536734 -12.012246,1.611224 -1.72449,-1.17245 -3.361224,-2.139796 -4.907142,-2.905102 C 31.753062,25.77449 30.516326,25.254082 29.587756,24.97653 28.660204,24.7 27.79796,24.528572 27,24.463266 c -0.79796,-0.0653 -1.310204,-0.08062 -1.537756,-0.04898 -0.22755,0.03164 -0.390816,0.0653 -0.487754,0.09796 -1.82347,4.62245 -1.985714,8.87143 -0.487756,12.743878 -3.287754,3.54796 -4.931632,7.844898 -4.931632,12.890816 0,2.604082 0.227552,4.988776 0.683674,7.153062 0.456122,2.164286 1.07449,4.020408 1.855102,5.566326 0.780612,1.545918 1.75,2.929592 2.905102,4.15 1.155102,1.220408 2.360204,2.213266 3.613264,2.978572 1.253062,0.766326 2.669388,1.42449 4.24796,1.97755 1.578572,0.554082 3.07551,0.976532 4.491836,1.27041 1.416328,0.292856 2.970408,0.521428 4.663266,0.683672 -2.669388,1.82347 -4.004082,4.720408 -4.004082,8.690816 v 7.639796 C 36.536734,89.818368 35.083674,89.3 33.656122,88.695918 c -4.99898,-2.115306 -9.490816,-5.143878 -13.35,-9.00306 -3.859184,-3.859184 -6.887754,-8.351022 -9.00306,-13.35 C 9.1163263,61.171428 8.0071428,55.67347 8.0071428,50 c 0,-5.67347 1.1091835,-11.171428 3.2969392,-16.342858 2.115306,-4.998978 5.143878,-9.490816 9.00306,-13.35 3.859184,-3.859182 8.351022,-6.887754 13.35,-9.00306 C 38.828572,9.1163266 44.32653,8.0071428 50,8.0071428 c 5.67347,0 11.171428,1.1091838 16.342858,3.2969392 5,2.115306 9.490816,5.143878 13.35,9.00306 3.859182,3.859184 6.887754,8.351022 9.00306,13.35 2.186736,5.17245 3.295918,10.67041 3.295918,16.342858 0,5.672448 -1.109182,11.171428 -3.296938,16.342858 -2.115306,4.998978 -5.143878,9.490816 -9.00204,13.35 l 0,0 z"></path></svg></a></li>
</ul>
  
  
  
<ul class="subscribe">
  <li><a href="https://twitter.com/jamiiecb" rel="subscribe-twitter" title="@jamiiecb on Twitter" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 512 512"><path class="social" d="M0.001,334.932c33.327,30.816,118.891,59.981,188.517-8.271c-12.52,1.955-22.972-0.416-30.913-8.269
  c-7.531-7.465-7.945-15.182-3.914-22.202c3.275-5.725,10.184-9.741,16.977-13.934c-12.323,2.285-22.829,1.095-32.218-3.706
  c-12.604-6.444-24.863-13.228-28.3-27.207c7.71-8.112,16.28-15.359,34.831-12.627c-17.45-5.83-33.087-13.429-44.41-24.815
  c-11.028-11.091-12.163-18.302-13.932-26.996c9.632-3.567,19.688-5.421,30.478-4.353c-24.397-12.476-34.757-29.63-40.487-48.325
  c-1.731-5.652-2.044-11.03-1.31-16.545c98.826,37.305,145.11,64.109,170.662,89.251c11.496-30.589,38.3-99.868,78.371-123.646
  c0.191,3.77-1.309,7.837-4.357,12.189c11.863-6.609,21.125-17.188,37.445-16.98c-1.879,7.723-7.279,13.904-17.85,17.854
  c10.662-4.084,21.463-7.545,32.65-9.578c10.375-1.881,10.229,6.304,4.355,10.444c-11.916,8.412-24.578,9.456-37.006,13.498
  c38.105,0.949,69.266,18.994,93.604,58.343c8.088,13.074,13.52,26.149,14.807,40.487c16.254,4.563,32.426,5.494,48.76,2.61
  c4.475-0.796,8.645-1.63,12.627-3.482c-6.354,9.529-13.686,17.356-23.947,20.899c-9.811,3.387-19.637,6.688-30.473,6.968
  c17.641,6.675,37.082,7.045,57.033,5.659c-24.402,23.486-43.08,22.922-61.824,22.642c-8.221,34.703-25.025,69.315-60.52,101.005
  c-46.559,41.569-96.678,61.397-148.457,65.742c-48.552,4.07-95.488,3.512-146.726-20.464
  C56.486,393.349,24.648,368.884,0.001,334.932L0.001,334.932z"/></svg></a></li>
</ul>
  
  
  
  
  
<ul class="main-navigation">
  <li><a href="/"><h2>scattered thoughts</h2></a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Telehash: buckets</h1>
      
    
  </header>


<div class="entry-content"><p>The other half of the routing table is the buckets which store node addresses.</p>

<!--more-->


<p>Usual disclaimer: none of this is properly tested yet.</p>

<p>The Kademlia paper has much to say on the issue of routing, most of it contradictory. My takeaway from many readings and from browsing the source code of various different implementations is that the following points are the most important:</p>

<ul>
<li>each bucket should contain at most <em>K</em> nodes</li>
<li>we should only ever report node addresses which we have personally confirmed exist</li>
<li>responsive nodes should never be removed from buckets</li>
<li>nodes should never be removed from buckets unless a suitable replacement exists</li>
</ul>


<p>The first three points make the routing table very resistant to flooding and spoofing. In particular, they prevent a common attack for p2p networks where some bad guy floods the routing tables of all the other nodes so that all traffic is routed through nodes controlled by the bad guy. The last point prevents nodes from flushing their routing tables if their own network connection goes down.</p>

<p>I think the implementation I have come up with is fairly clean, if a little lengthy. Like the bit_tree I want the bucket to be completely pure. All side effects will be handled by the router itself. The main data structures are explained pretty well by the comments:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">K</span><span class="p">,</span> <span class="o">?</span><span class="nv">DIAL_DEPTH</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">node</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">address</span><span class="p">,</span> <span class="c">% node #address{} record</span>
</span><span class='line'>    <span class="n">&#39;end&#39;</span><span class="p">,</span> <span class="c">% node end</span>
</span><span class='line'>    <span class="n">suffix</span><span class="p">,</span> <span class="c">% the remaining bits of the nodes end left over from the bit_tree</span>
</span><span class='line'>    <span class="n">status</span><span class="p">,</span> <span class="c">% one of [live, stale, cache]</span>
</span><span class='line'>    <span class="n">last_seen</span> <span class="c">% for live/stale nodes, the time of the last received message. for cache nodes the time of the last .see reference to the node</span>
</span><span class='line'>   <span class="p">}).</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">bucket</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">nodes</span><span class="p">,</span> <span class="c">% gb_tree mapping addresses to {Status, Last_seen}</span>
</span><span class='line'>    <span class="c">% remaining fields are pq&#39;s of nodes sorted by their last_seen field</span>
</span><span class='line'>    <span class="n">live</span><span class="p">,</span> <span class="c">% nodes currently expected to be alive</span>
</span><span class='line'>    <span class="n">stale</span><span class="p">,</span> <span class="c">% nodes which have not replied recently</span>
</span><span class='line'>    <span class="n">cache</span> <span class="c">% potential nodes which we have not yet verified </span>
</span><span class='line'>   <span class="p">}).</span> <span class="c">% invariant: pq_maps:size(live) + pq_maps:size(stale) &lt;= ?K</span>
</span></code></pre></td></tr></table></div></figure>


<p>The bucket is a two-stage data structure. This allows us the keep nodes of different statuses sorted by the last_seen time but still be able to get/delete nodes just knowing the address. The <em>get_node</em> function should make it clear how this works:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">get_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span>
</span><span class='line'>   <span class="nl">#bucket</span><span class="p">{</span><span class="nb">nodes</span><span class="o">=</span><span class="nv">Nodes</span><span class="p">,</span> <span class="n">live</span><span class="o">=</span><span class="nv">Live</span><span class="p">,</span> <span class="n">stale</span><span class="o">=</span><span class="nv">Stale</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="nv">Cache</span><span class="p">})</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">case</span> <span class="nn">gb_trees</span><span class="p">:</span><span class="n">lookup</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Nodes</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>  <span class="p">{</span><span class="n">value</span><span class="p">,</span> <span class="p">{</span><span class="nv">Status</span><span class="p">,</span> <span class="nv">Last_seen</span><span class="p">}}</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="k">case</span> <span class="nv">Status</span> <span class="k">of</span>
</span><span class='line'>      <span class="n">live</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="nb">get</span><span class="p">({</span><span class="nv">Last_seen</span><span class="p">,</span> <span class="nv">Address</span><span class="p">},</span> <span class="nv">Live</span><span class="p">)};</span>
</span><span class='line'>      <span class="n">stale</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="nb">get</span><span class="p">({</span><span class="nv">Last_seen</span><span class="p">,</span> <span class="nv">Address</span><span class="p">},</span> <span class="nv">Stale</span><span class="p">)};</span>
</span><span class='line'>      <span class="n">cache</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="nb">get</span><span class="p">({</span><span class="nv">Last_seen</span><span class="p">,</span> <span class="nv">Address</span><span class="p">},</span> <span class="nv">Cache</span><span class="p">)}</span>
</span><span class='line'>      <span class="k">end</span><span class="p">;</span>
</span><span class='line'>  <span class="n">none</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="n">none</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is only long because records are purely a compile time structure ie we can&rsquo;t write <em>Bucket#bucket.Status</em> so we have to pattern match on <em>Status</em> instead. We also define <em>add_node/2</em>, <em>del_node/2</em> and <em>update_node/2</em>, which look pretty similar, as well as <em>to_list/1</em>, <em>from_list/1</em> and <em>sizes/1</em>.</p>

<p>The router is going to react to various events by calling the appropriate bucket functions and possibly sending out messages based on the result. The first event it has to handle is a node becoming unresponsive. The bucket will mark this node as stale and return a cache node which the router can attempt to verify.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="c">% this address failed to reply in a timely manner</span>
</span><span class='line'><span class="nf">timedout</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">timing_out</span><span class="p">,</span> <span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">get_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>  <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="k">case</span> <span class="nv">Node</span><span class="nl">#node.status</span> <span class="k">of</span>
</span><span class='line'>      <span class="n">live</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% mark as stale, return a cache node that might be a suitable replacement</span>
</span><span class='line'>          <span class="nv">Bucket2</span> <span class="o">=</span> <span class="n">update_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">status</span><span class="o">=</span><span class="n">stale</span><span class="p">},</span> <span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>          <span class="n">pop_cache_hi</span><span class="p">(</span><span class="nv">Bucket2</span><span class="p">);</span>
</span><span class='line'>      <span class="p">_</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% if cache or stale already we don&#39;t care </span>
</span><span class='line'>          <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span><span class="p">;</span>
</span><span class='line'>  <span class="n">none</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% wtf? we don&#39;t even know this node?</span>
</span><span class='line'>      <span class="c">% one way this could happen: </span>
</span><span class='line'>      <span class="c">% send N1, sendN1, timedout N1, add N2 (pushing N1 out of stale), timedout N1 </span>
</span><span class='line'>      <span class="nn">log</span><span class="p">:</span><span class="n">warning</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">unknown_node_timedout</span><span class="p">,</span> <span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>      <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="c">% return most recently seen cache node, if any exist</span>
</span><span class='line'><span class="nf">pop_cache_hi</span><span class="p">(</span><span class="nl">#bucket</span><span class="p">{</span><span class="n">cache</span><span class="o">=</span><span class="nv">Cache</span><span class="p">}</span><span class="o">=</span><span class="nv">Bucket</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">case</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="n">pop_hi</span><span class="p">(</span><span class="nv">Cache</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>  <span class="p">{_</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Node</span><span class="p">,</span> <span class="nv">Cache2</span><span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="p">{</span><span class="nb">node</span><span class="p">,</span> <span class="nv">Node</span><span class="p">,</span> <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket</span><span class="nl">#bucket</span><span class="p">{</span><span class="n">cache</span><span class="o">=</span><span class="nv">Cache2</span><span class="p">})};</span>
</span><span class='line'>  <span class="n">false</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>The next event is receiving a <em>.see</em> command. This may be as a result of a <em>+end</em> sent by the router but is more likely to be part of a dialing process happening elsewhere. The beauty of Kademlia is that the router can populate the routing table just by listening in on dialing attempts.</p>

<p>For each node listed in the <em>.see</em> command the router will call <em>seen</em>. This adds the node to the cache and returns the least recently seen live node so the router can check that it is still responsive.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="c">% this address has been reported to exist by another node</span>
</span><span class='line'><span class="nf">seen</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">Suffix</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">seeing</span><span class="p">,</span> <span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">get_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>  <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="k">case</span> <span class="nv">Node</span><span class="nl">#node.status</span> <span class="k">of</span>
</span><span class='line'>      <span class="n">cache</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% for cache nodes being in a .see is good enough</span>
</span><span class='line'>          <span class="n">ok</span><span class="p">(</span><span class="n">update_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">last_seen</span><span class="o">=</span><span class="nv">Time</span><span class="p">},</span> <span class="nv">Bucket</span><span class="p">));</span>
</span><span class='line'>      <span class="p">_</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% for live/stale nodes we require direct contact so ignore this</span>
</span><span class='line'>          <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span><span class="p">;</span>
</span><span class='line'>  <span class="n">none</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% put node in cache, return a live node to ping</span>
</span><span class='line'>      <span class="nv">Node</span> <span class="o">=</span> <span class="nl">#node</span><span class="p">{</span>
</span><span class='line'>        <span class="n">address</span> <span class="o">=</span> <span class="nv">Address</span><span class="p">,</span>
</span><span class='line'>        <span class="n">&#39;end&#39;</span> <span class="o">=</span> <span class="nn">util</span><span class="p">:</span><span class="n">to_end</span><span class="p">(</span><span class="nv">Address</span><span class="p">),</span>
</span><span class='line'>        <span class="n">suffix</span> <span class="o">=</span> <span class="nv">Suffix</span><span class="p">,</span>
</span><span class='line'>        <span class="n">status</span> <span class="o">=</span> <span class="n">cache</span><span class="p">,</span>
</span><span class='line'>        <span class="n">last_seen</span> <span class="o">=</span> <span class="nv">Time</span>
</span><span class='line'>       <span class="p">},</span>
</span><span class='line'>      <span class="nv">Bucket2</span> <span class="o">=</span> <span class="n">add_node</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">peek_live_lo</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>      <span class="n">none</span> <span class="o">-&gt;</span> <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket2</span><span class="p">);</span>
</span><span class='line'>      <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Live_node</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="nb">node</span><span class="p">,</span> <span class="nv">Live_node</span><span class="p">,</span> <span class="n">ok</span><span class="p">(</span><span class="nv">Bucket2</span><span class="p">)}</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="c">% return the oldest live node</span>
</span><span class='line'><span class="nf">peek_live_lo</span><span class="p">(</span><span class="nl">#bucket</span><span class="p">{</span><span class="n">live</span><span class="o">=</span><span class="nv">Live</span><span class="p">})</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">case</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="n">peek_lo</span><span class="p">(</span><span class="nv">Live</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>  <span class="n">none</span> <span class="o">-&gt;</span> <span class="n">none</span><span class="p">;</span>
</span><span class='line'>  <span class="p">{_,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Any time we receive a message we learn that the node sending it exists (or not &ndash; we&rsquo;ll deal with address spoofing in a later post) so we can potentially mark it as a live node. The <em>touched</em> function checks if the node is already in the bucket or if it needs to be added.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="c">% this address has been verified as actually existing</span>
</span><span class='line'><span class="nf">touched</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Suffix</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">,</span> <span class="nv">May_split</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">touching</span><span class="p">,</span> <span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">get_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">)</span> <span class="k">of</span>
</span><span class='line'>  <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="k">case</span> <span class="nv">Node</span><span class="nl">#node.status</span> <span class="k">of</span>
</span><span class='line'>      <span class="n">live</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% update last_seen time</span>
</span><span class='line'>          <span class="n">ok</span><span class="p">(</span><span class="n">update_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">last_seen</span><span class="o">=</span><span class="nv">Time</span><span class="p">},</span> <span class="nv">Bucket</span><span class="p">));</span>
</span><span class='line'>      <span class="n">stale</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% update last_seen time and promote to live</span>
</span><span class='line'>          <span class="n">ok</span><span class="p">(</span><span class="n">update_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">last_seen</span><span class="o">=</span><span class="nv">Time</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">live</span><span class="p">},</span> <span class="nv">Bucket</span><span class="p">));</span>
</span><span class='line'>      <span class="n">cache</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="c">% potentially promote the node to live</span>
</span><span class='line'>          <span class="nv">Bucket2</span> <span class="o">=</span> <span class="n">del_node</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>          <span class="n">new_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Suffix</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">Bucket2</span><span class="p">,</span> <span class="nv">May_split</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span><span class="p">;</span>
</span><span class='line'>  <span class="n">none</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% potentially add the node to live</span>
</span><span class='line'>      <span class="n">new_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Suffix</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">,</span> <span class="nv">May_split</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>If the node needs to be added then <em>touched</em> calls <em>new_node</em> which decides if there is space in the bucket and, if so, adds the new node. If the bucket is full and <em>May_split</em> is true then <em>new_node</em> will split the bucket before adding the new node. Deciding whether or not splitting is allowed is the routers job.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="c">% assumes Address is not already in Bucket, otherwise crashes</span>
</span><span class='line'><span class="nf">new_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Suffix</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">,</span> <span class="nv">May_split</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">Node</span> <span class="o">=</span> <span class="nl">#node</span><span class="p">{</span>
</span><span class='line'>      <span class="n">address</span> <span class="o">=</span> <span class="nv">Address</span><span class="p">,</span>
</span><span class='line'>      <span class="n">&#39;end&#39;</span> <span class="o">=</span> <span class="nn">util</span><span class="p">:</span><span class="n">to_end</span><span class="p">(</span><span class="nv">Address</span><span class="p">),</span>
</span><span class='line'>      <span class="n">suffix</span> <span class="o">=</span> <span class="nv">Suffix</span><span class="p">,</span>
</span><span class='line'>      <span class="n">status</span> <span class="o">=</span> <span class="n">undefined</span><span class="p">,</span>
</span><span class='line'>      <span class="n">last_seen</span> <span class="o">=</span> <span class="nv">Time</span>
</span><span class='line'>     <span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="nv">Lives</span><span class="p">,</span> <span class="nv">Stales</span><span class="p">,</span> <span class="p">_}</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>    <span class="k">if</span>
</span><span class='line'>  <span class="nv">Lives</span> <span class="o">+</span> <span class="nv">Stales</span> <span class="o">&lt;</span> <span class="o">?</span><span class="nv">K</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% space left in live</span>
</span><span class='line'>      <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">adding</span><span class="p">,</span> <span class="nv">Node</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>      <span class="n">ok</span><span class="p">(</span><span class="n">add_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">status</span><span class="o">=</span><span class="n">live</span><span class="p">},</span> <span class="nv">Bucket</span><span class="p">));</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">Lives</span> <span class="o">&lt;</span> <span class="o">?</span><span class="nv">K</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nv">Stales</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% space left in live if we push something out of stale</span>
</span><span class='line'>      <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">adding</span><span class="p">,</span> <span class="nv">Node</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>      <span class="nv">Bucket2</span> <span class="o">=</span> <span class="n">drop_stale</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>      <span class="n">ok</span><span class="p">(</span><span class="n">add_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">status</span><span class="o">=</span><span class="n">live</span><span class="p">},</span> <span class="nv">Bucket2</span><span class="p">));</span>
</span><span class='line'>  <span class="nv">May_split</span> <span class="ow">and</span> <span class="p">(</span><span class="nv">Suffix</span> <span class="o">/=</span> <span class="p">[])</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% allowed to split the bucket to make space</span>
</span><span class='line'>      <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">splitting</span><span class="p">,</span> <span class="nv">Node</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>      <span class="p">{</span><span class="n">split</span><span class="p">,</span> <span class="nv">BucketF</span><span class="p">,</span> <span class="nv">BucketT</span><span class="p">}</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>      <span class="p">[</span><span class="nv">Bit</span> <span class="p">|</span> <span class="nv">Suffix2</span><span class="p">]</span> <span class="o">=</span> <span class="nv">Suffix</span><span class="p">,</span>
</span><span class='line'>      <span class="k">case</span> <span class="nv">Bit</span> <span class="k">of</span>
</span><span class='line'>      <span class="n">false</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="nv">BucketF2</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Suffix2</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">BucketF</span><span class="p">,</span> <span class="nv">May_split</span><span class="p">),</span>
</span><span class='line'>          <span class="p">{</span><span class="n">split</span><span class="p">,</span> <span class="nv">BucketF2</span><span class="p">,</span> <span class="nv">BucketT</span><span class="p">};</span>
</span><span class='line'>      <span class="n">true</span> <span class="o">-&gt;</span>
</span><span class='line'>          <span class="nv">BucketT2</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="nv">Address</span><span class="p">,</span> <span class="nv">Suffix2</span><span class="p">,</span> <span class="nv">Time</span><span class="p">,</span> <span class="nv">BucketT</span><span class="p">,</span> <span class="nv">May_split</span><span class="p">),</span>
</span><span class='line'>          <span class="p">{</span><span class="n">split</span><span class="p">,</span> <span class="nv">BucketF</span><span class="p">,</span> <span class="nv">BucketT2</span><span class="p">}</span>
</span><span class='line'>      <span class="k">end</span><span class="p">;</span>
</span><span class='line'>  <span class="n">true</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% not allowed to split, will have to go in the cache</span>
</span><span class='line'>      <span class="nn">log</span><span class="p">:</span><span class="n">info</span><span class="p">([</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="n">caching</span><span class="p">,</span> <span class="nv">Node</span><span class="p">,</span> <span class="nv">Bucket</span><span class="p">]),</span>
</span><span class='line'>      <span class="n">ok</span><span class="p">(</span><span class="n">add_node</span><span class="p">(</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">status</span><span class="o">=</span><span class="n">cache</span><span class="p">},</span> <span class="n">bucket</span><span class="p">))</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="c">% drop the oldest stale node, crashes if none exist</span>
</span><span class='line'><span class="nf">drop_stale</span><span class="p">(</span><span class="nl">#bucket</span><span class="p">{</span><span class="n">stale</span><span class="o">=</span><span class="nv">Stale</span><span class="p">}</span><span class="o">=</span><span class="nv">Bucket</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="p">{_</span><span class="nv">Key</span><span class="p">,</span> <span class="p">_</span><span class="nv">Node</span><span class="p">,</span> <span class="nv">Stale2</span><span class="p">}</span> <span class="o">=</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="n">pop_one_hi</span><span class="p">(</span><span class="nv">Stale</span><span class="p">),</span>
</span><span class='line'>    <span class="nv">Bucket</span><span class="nl">#bucket</span><span class="p">{</span><span class="n">stale</span><span class="o">=</span><span class="nv">Stale2</span><span class="p">}.</span>
</span><span class='line'>
</span><span class='line'><span class="nf">split</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">Nodes</span> <span class="o">=</span> <span class="n">to_list</span><span class="p">(</span><span class="nv">Bucket</span><span class="p">),</span>
</span><span class='line'>    <span class="nv">NodesF</span> <span class="o">=</span> <span class="p">[</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">suffix</span><span class="o">=</span><span class="nv">Suffix2</span><span class="p">}</span> <span class="p">||</span> <span class="nl">#node</span><span class="p">{</span><span class="n">suffix</span><span class="o">=</span><span class="p">[</span><span class="n">false</span><span class="p">|</span><span class="nv">Suffix2</span><span class="p">]}</span><span class="o">=</span><span class="nv">Node</span> <span class="o">&lt;-</span> <span class="nv">Nodes</span><span class="p">],</span>
</span><span class='line'>    <span class="nv">NodesT</span> <span class="o">=</span> <span class="p">[</span><span class="nv">Node</span><span class="nl">#node</span><span class="p">{</span><span class="n">suffix</span><span class="o">=</span><span class="nv">Suffix2</span><span class="p">}</span> <span class="p">||</span> <span class="nl">#node</span><span class="p">{</span><span class="n">suffix</span><span class="o">=</span><span class="p">[</span><span class="n">true</span><span class="p">|</span><span class="nv">Suffix2</span><span class="p">]}</span><span class="o">=</span><span class="nv">Node</span> <span class="o">&lt;-</span> <span class="nv">Nodes</span><span class="p">],</span>
</span><span class='line'>    <span class="p">{</span><span class="n">split</span><span class="p">,</span> <span class="n">from_list</span><span class="p">(</span><span class="nv">NodesF</span><span class="p">),</span> <span class="n">from_list</span><span class="p">(</span><span class="nv">NodesT</span><span class="p">)}.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, upon receiving a <em>+end</em> signal the router needs to reply with a <em>.see</em> command listing the <em>K</em> nearest nodes to the specified end. This will be done using a combination of <em>bit_tree:iter</em> and <em>bucket:nearest</em>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">nearest</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">End</span><span class="p">,</span> <span class="nl">#bucket</span><span class="p">{</span><span class="n">live</span><span class="o">=</span><span class="nv">Live</span><span class="p">,</span> <span class="n">stale</span><span class="o">=</span><span class="nv">Stale</span><span class="p">})</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">Nodes</span> <span class="o">=</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="n">to_list</span><span class="p">(</span><span class="nv">Live</span><span class="p">)</span> <span class="o">++</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="n">to_list</span><span class="p">(</span><span class="nv">Stale</span><span class="p">),</span>
</span><span class='line'>    <span class="nv">Num_nodes</span> <span class="o">=</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="nv">Live</span><span class="p">)</span> <span class="o">+</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="nv">Stale</span><span class="p">),</span>
</span><span class='line'>    <span class="k">if</span>
</span><span class='line'>  <span class="nv">Num_nodes</span> <span class="o">=&lt;</span> <span class="nv">N</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="p">[</span><span class="nv">Node</span><span class="nl">#node.address</span> <span class="p">||</span> <span class="p">{_</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nv">Nodes</span><span class="p">];</span>
</span><span class='line'>  <span class="n">true</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c">% !!! maybe should prefer to return live nodes even if further away</span>
</span><span class='line'>      <span class="nv">Nodes_by_dist</span> <span class="o">=</span> <span class="p">[{</span><span class="nn">util</span><span class="p">:</span><span class="n">distance</span><span class="p">(</span><span class="nv">End</span><span class="p">,</span> <span class="nv">Node</span><span class="nl">#node.&#39;end&#39;</span><span class="p">),</span> <span class="nv">Node</span><span class="p">}</span> <span class="p">||</span> <span class="p">{_</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nn">pq_maps</span><span class="p">:</span><span class="n">to_list</span><span class="p">(</span><span class="nv">Live</span><span class="p">)],</span>
</span><span class='line'>      <span class="p">{</span><span class="nv">Closest</span><span class="p">,</span> <span class="p">_}</span> <span class="o">=</span> <span class="nn">lists</span><span class="p">:</span><span class="n">split</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nn">lists</span><span class="p">:</span><span class="n">sort</span><span class="p">(</span><span class="nv">Nodes_by_dist</span><span class="p">)),</span>
</span><span class='line'>      <span class="p">[</span><span class="nv">Node</span><span class="nl">#node.address</span> <span class="p">||</span> <span class="p">{_</span><span class="nv">Dist</span><span class="p">,</span> <span class="nv">Node</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nv">Closest</span><span class="p">]</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>As usual all the code is sitting in the <a href="https://github.com/jamii/erl-telehash">repo</a>.</p>
</div>


  <footer>
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2011/03/24/telehash-bittrees-revisited/" title="Previous Post: Telehash: bit_trees revisited">&laquo; Telehash: bit_trees revisited</a>
      
      
        <a class="basic-alignment right" href="/blog/2011/04/19/telehash-gen-event-woes/" title="Next Post: Telehash: gen_event woes">Telehash: gen_event woes &raquo;</a>
      
    </p>
  </footer>
</article>
</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Jamie Brandon
</p>

</footer>
  











</body>
</html>
