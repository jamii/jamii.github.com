<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Hugo-a-go-go: optimisation</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Hugo-a-go-go: optimisation</h1></header><article role="main"><p>After a little optimisation work <a href="https://github.com/jamii/hugo-a-go-go/">hugo</a> now manages to play out ~12k games per second on a 9x9 board. Besides fixing the two incorrect optimisations I made during the last minutes of the competition, the main wins were changing the board representation and carefully inspecting the compiler output to eliminate unneccesary work. A lot of the things I discovered are generally applicable to calculation-heavy, cpu-bound cljs code (with all the usual disclaimers about profiling and premature optimsation).<h2 id="layout">Layout</h2><p>The board is now packed into a Uint8Array. With borders included, the board is an 11x11 grid.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">array-size</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">size</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">max-pos</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">array-size</span><span class="w"> </span><span class="n">array-size</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-&gt;pos</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">array-size</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">y</span><span class="p">))))</span><span class="w">
</span></code></pre></div><p>The first 121 entries in the array represent the colour of each cell on the board.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">black</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">grey</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;; for the border
</span><span class="w">
</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">get-colour</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">set-colour</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="n">colour</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nb">aset</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="w"> </span><span class="o">~</span><span class="n">colour</span><span class="p">))</span><span class="w">
</span></code></pre></div><p>The next 121 entries track which string is present on a cell. Strings are just represented by an integer id. The last entry in the array tracks the next id to be assigned.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">empty-string</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">grey-string</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">new-string</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">next-string</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="mi">1023</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">aset</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="mi">1023</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">next-string</span><span class="o">#</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
     </span><span class="n">next-string</span><span class="o">#</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">get-string</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="n">max-pos</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">set-string</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nb">aset</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="n">max-pos</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="n">string</span><span class="p">))</span><span class="w">
</span></code></pre></div><p>The next 121 entries track the number of non-empty neighbouring cells, which is useful for short-circuiting <code class="highlighter-rouge">suicide?</code> and <code class="highlighter-rouge">eyelike?</code> tests.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">get-neighbours</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">freedom-ix</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">max-pos</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="n">freedom-ix</span><span class="o">#</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">add-neighbours</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="n">amount</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">freedom-ix</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">max-pos</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="nb">aset</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="n">freedom-ix</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="n">freedom-ix</span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="n">amount</span><span class="p">))))</span><span class="w">
</span></code></pre></div><p>Finally, the remaining cells map string ids to the number of pseudo-liberties belonging to that string.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">get-liberties</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">string-ix</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">max-pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">get-string</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">))]</span><span class="w">
     </span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="n">string-ix</span><span class="o">#</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">add-liberties</span><span class="w"> </span><span class="p">[</span><span class="n">board</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="n">amount</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">string-ix</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">max-pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">get-string</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="o">~</span><span class="n">pos</span><span class="p">))]</span><span class="w">
     </span><span class="p">(</span><span class="nb">aset</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="n">string-ix</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">aget</span><span class="w"> </span><span class="o">~</span><span class="n">board</span><span class="w"> </span><span class="n">string-ix</span><span class="o">#</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="n">amount</span><span class="p">))))</span><span class="w">
</span></code></pre></div><p>Packing the board this way gives two benefits. First, every field access is reduced to a few instructions. This isn’t as big a win as one might think, given that the structure of the old layout was predictable enough for the jit to replace hash lookups with struct access. More importantly, packing the board means that creating a copy is a single array copy. Cheap copying means we can cache boards all over the place and this leads to a lot of saved work in the UCT stage.<p>My implementation here is a little clumsy but in the future a cljs port of <a href="https://github.com/ztellman/vertigo">vertigo</a> would make this a lot cleaner. This is the kind of abstraction that would be difficult to implement in plain js.<h2 id="truth">Truth</h2><p>In cljs, only <code class="highlighter-rouge">false</code> and <code class="highlighter-rouge">nil</code> are falsey. In generated code, if the cljs compiler cannot infer that the test in a branch is a boolean, it wraps it in <code class="highlighter-rouge">cljs.core.truth_</code> to test for cljs truthiness rather than js truthiness.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo?</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"foo"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">unfoo</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">foo?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
    </span><span class="n">nil</span><span class="w">
    </span><span class="n">x</span><span class="p">))</span><span class="w">
</span></code></pre></div><div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo_QMARK_</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">_EQ_</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">};</span>
<span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">unfoo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">truth_</span><span class="p">(</span><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo_QMARK_</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">a</span>
<span class="p">};</span>
</code></pre></div><p>Normally this doesn’t matter but hugo is optimised enough already that profiling showed it spending ~15% of it’s time inside <code class="highlighter-rouge">cljs.core.truth_</code>. You can avoid it either by adding type hints…<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="o">^</span><span class="nb">boolean</span><span class="w"> </span><span class="n">foo?</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"foo"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">unfoo</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">foo?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
    </span><span class="n">nil</span><span class="w">
    </span><span class="n">x</span><span class="p">))</span><span class="w">
</span></code></pre></div><div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo_QMARK_</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">_EQ_</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">};</span>
<span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">unfoo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo_QMARK_</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">a</span>
<span class="p">};</span>
</code></pre></div><p>… or by wrapping the test in a function that is already hinted.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo?</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"foo"</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">unfoo</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">true?</span><span class="w"> </span><span class="p">(</span><span class="nf">foo?</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
    </span><span class="n">nil</span><span class="w">
    </span><span class="n">x</span><span class="p">))</span><span class="w">
</span></code></pre></div><div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo_QMARK_</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">_EQ_</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">};</span>
<span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">unfoo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span><span class="o">!</span><span class="mi">0</span> <span class="o">===</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo_QMARK_</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">a</span>
<span class="p">};</span>
</code></pre></div><h2 id="equality">Equality</h2><p>Clojure defaults to structural equality where possible, rather than using javascript’s insane notion of equality.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">opposite-colour</span><span class="w"> </span><span class="p">[</span><span class="n">colour</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="n">black</span><span class="p">)</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="n">black</span><span class="p">))</span><span class="w">
</span></code></pre></div><div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">opposite_colour</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">_EQ_</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">black</span><span class="p">)</span> <span class="p">?</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">white</span> <span class="p">:</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">black</span>
<span class="p">};</span>
</code></pre></div><p>Again, this is something that normally doesn’t matter but hugo was spending ~20% of cpu time in <code class="highlighter-rouge">cljs.core.__EQ__</code>. Since we know we are comparing integers we can use <code class="highlighter-rouge">==</code> instead, which compiles down to <code class="highlighter-rouge">===</code> in js.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">opposite-colour</span><span class="w"> </span><span class="p">[</span><span class="n">colour</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">==</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="n">black</span><span class="p">)</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="n">black</span><span class="p">))</span><span class="w">
</span></code></pre></div><div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">opposite_colour</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">===</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">black</span> <span class="p">?</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">white</span> <span class="p">:</span> <span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">black</span>
<span class="p">};</span>
</code></pre></div><p>For other primitive types it seems that <code class="highlighter-rouge">identical?</code> will inline to <code class="highlighter-rouge">===</code>. For keywords you now have to use <code class="highlighter-rouge">keyword-identical?</code> which unfortunately does not inline.<h2 id="polyadic-calls">Polyadic calls</h2><p>Clojure functions can dispatch on the number of arguments. Usually the cljs compiler does a good job of compiling away the extra indirection, but it struggles with local functions.<div class="language-clj highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">letfn</span><span class="w"> </span><span class="p">[(</span><span class="nf">bar</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">bar</span><span class="w"> </span><span class="no">:foo</span><span class="w"> </span><span class="no">:bar</span><span class="p">)))</span><span class="w">
</span></code></pre></div><div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">hugo_a_go_go</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">_EQ_</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span> <span class="p">?</span> <span class="nx">a</span><span class="p">.</span><span class="nx">cljs$core$IFn$_invoke$arity$2</span><span class="p">(</span><span class="k">new</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">Keyword</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">"foo"</span><span class="p">,</span> <span class="s2">"foo"</span><span class="p">,</span> <span class="mi">1014005816</span><span class="p">),</span> <span class="k">new</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">Keyword</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="mi">1014001541</span><span class="p">))</span> <span class="p">:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="k">new</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">Keyword</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">"foo"</span><span class="p">,</span> <span class="s2">"foo"</span><span class="p">,</span> <span class="mi">1014005816</span><span class="p">),</span> <span class="k">new</span> <span class="nx">cljs</span><span class="p">.</span><span class="nx">core</span><span class="p">.</span><span class="nx">Keyword</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="mi">1014001541</span><span class="p">))</span>
<span class="p">};</span>
</code></pre></div><p>The important part to notice here is that it tests if <code class="highlighter-rouge">a.cljs$core$IFn$_invoke$arity$2</code> exists before calling it, despite the fact that that is statically known. We had some small (~5%) performance improvements in a few places (notably board/flood-fill) by lifting all closures up to top-level functions so that the compiler can remove that check.<h2 id="mutable-variables">Mutable variables</h2><p>Sometimes you need a mutable variable. Using atoms incurs overhead for eg checking watches. According to <a href="http://swannodette.github.io/2013/06/10/porting-notchs-minecraft-demo-to-clojurescript/">David Nolen</a>, the best option in cljs is creating a one-element array.<p>It would be nice to have safe access to mutable vars in the style of <a href="https://github.com/ztellman/proteus">proteus</a> instead.<h2 id="next">Next</h2><p>While it meet seem annoying to have to work around the compiler sometimes to get decent performance, I far prefer to have sane semantics by default and just remember a few simple tricks for speeding up inner loops. Having access to macros also opens the door to a world of performant abstractions that would be extremely painful in plain js (eg <a href="https://github.com/clojure/core.match">core.match</a>, <a href="https://github.com/ztellman/vertigo">vertigo</a>). Now that the core of hugo is just bashing on integers and byte arrays there is also the potential to compile sections of it to <a href="http://asmjs.org/">asm.js</a> for even more performance.<p>Hugo now plays fairly sensibly but is still easy to defeat even for a novice player like me. I suspect that the UCT stage is still not entirely correct so the next step is to build a visualiser for the game tree so I can see the reasoning behind it’s moves.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
