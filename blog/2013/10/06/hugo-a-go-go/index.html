
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hugo-a-go-go - Scattered Thoughts</title>
  <meta name="author" content="Jamie Brandon">

  
  <meta name="description" content="For the 2013 Clojure Cup myself and Tom Hall wrote a go AI in clojurescript, inspired by pushkin. The source is here and it can currently be played &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://scattered-thoughts.net/blog/2013/10/06/hugo-a-go-go">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Scattered Thoughts" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-18515092-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
<ul class="subscribe">
  <li><a href="https://github.com/jamii" rel="subscribe-github" title="@jamii on GitHub" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 50,0 C 22.385714,0 0,22.385714 0,50 0,77.614286 22.385714,100 50,100 77.614286,100 100,77.614286 100,50 100,22.385714 77.614286,0 50,0 z m 29.692858,79.692858 c -3.859184,3.859182 -8.351022,6.887754 -13.35,9.00306 -1.27041,0.536736 -2.560204,1.009184 -3.867348,1.415306 v -7.493878 c 0,-3.938774 -1.35102,-6.835714 -4.053062,-8.690816 1.692858,-0.163264 3.24694,-0.390816 4.663266,-0.683672 1.416326,-0.292858 2.913266,-0.716328 4.491838,-1.27041 1.57857,-0.55408 2.994896,-1.213264 4.247958,-1.97755 1.253062,-0.765306 2.458164,-1.758164 3.613266,-2.978572 1.155102,-1.220408 2.12449,-2.604082 2.905102,-4.15 0.780612,-1.545918 1.4,-3.40204 1.855102,-5.566326 0.455102,-2.164286 0.683674,-4.54898 0.683674,-7.153062 0,-5.045918 -1.643878,-9.341836 -4.931634,-12.890816 C 77.44796,33.35 77.285714,29.10204 75.463266,24.512244 l -1.22143,-0.145918 c -0.845918,-0.09796 -2.368366,0.260204 -4.565306,1.07449 -2.196938,0.814286 -4.663264,2.14796 -7.396938,4.004082 -3.87449,-1.07449 -7.893878,-1.611224 -12.061224,-1.611224 -4.19898,0 -8.203062,0.536734 -12.012246,1.611224 -1.72449,-1.17245 -3.361224,-2.139796 -4.907142,-2.905102 C 31.753062,25.77449 30.516326,25.254082 29.587756,24.97653 28.660204,24.7 27.79796,24.528572 27,24.463266 c -0.79796,-0.0653 -1.310204,-0.08062 -1.537756,-0.04898 -0.22755,0.03164 -0.390816,0.0653 -0.487754,0.09796 -1.82347,4.62245 -1.985714,8.87143 -0.487756,12.743878 -3.287754,3.54796 -4.931632,7.844898 -4.931632,12.890816 0,2.604082 0.227552,4.988776 0.683674,7.153062 0.456122,2.164286 1.07449,4.020408 1.855102,5.566326 0.780612,1.545918 1.75,2.929592 2.905102,4.15 1.155102,1.220408 2.360204,2.213266 3.613264,2.978572 1.253062,0.766326 2.669388,1.42449 4.24796,1.97755 1.578572,0.554082 3.07551,0.976532 4.491836,1.27041 1.416328,0.292856 2.970408,0.521428 4.663266,0.683672 -2.669388,1.82347 -4.004082,4.720408 -4.004082,8.690816 v 7.639796 C 36.536734,89.818368 35.083674,89.3 33.656122,88.695918 c -4.99898,-2.115306 -9.490816,-5.143878 -13.35,-9.00306 -3.859184,-3.859184 -6.887754,-8.351022 -9.00306,-13.35 C 9.1163263,61.171428 8.0071428,55.67347 8.0071428,50 c 0,-5.67347 1.1091835,-11.171428 3.2969392,-16.342858 2.115306,-4.998978 5.143878,-9.490816 9.00306,-13.35 3.859184,-3.859182 8.351022,-6.887754 13.35,-9.00306 C 38.828572,9.1163266 44.32653,8.0071428 50,8.0071428 c 5.67347,0 11.171428,1.1091838 16.342858,3.2969392 5,2.115306 9.490816,5.143878 13.35,9.00306 3.859182,3.859184 6.887754,8.351022 9.00306,13.35 2.186736,5.17245 3.295918,10.67041 3.295918,16.342858 0,5.672448 -1.109182,11.171428 -3.296938,16.342858 -2.115306,4.998978 -5.143878,9.490816 -9.00204,13.35 l 0,0 z"></path></svg></a></li>
</ul>
  
  
  
<ul class="subscribe">
  <li><a href="https://twitter.com/jamiiecb" rel="subscribe-twitter" title="@jamiiecb on Twitter" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 512 512"><path class="social" d="M0.001,334.932c33.327,30.816,118.891,59.981,188.517-8.271c-12.52,1.955-22.972-0.416-30.913-8.269
  c-7.531-7.465-7.945-15.182-3.914-22.202c3.275-5.725,10.184-9.741,16.977-13.934c-12.323,2.285-22.829,1.095-32.218-3.706
  c-12.604-6.444-24.863-13.228-28.3-27.207c7.71-8.112,16.28-15.359,34.831-12.627c-17.45-5.83-33.087-13.429-44.41-24.815
  c-11.028-11.091-12.163-18.302-13.932-26.996c9.632-3.567,19.688-5.421,30.478-4.353c-24.397-12.476-34.757-29.63-40.487-48.325
  c-1.731-5.652-2.044-11.03-1.31-16.545c98.826,37.305,145.11,64.109,170.662,89.251c11.496-30.589,38.3-99.868,78.371-123.646
  c0.191,3.77-1.309,7.837-4.357,12.189c11.863-6.609,21.125-17.188,37.445-16.98c-1.879,7.723-7.279,13.904-17.85,17.854
  c10.662-4.084,21.463-7.545,32.65-9.578c10.375-1.881,10.229,6.304,4.355,10.444c-11.916,8.412-24.578,9.456-37.006,13.498
  c38.105,0.949,69.266,18.994,93.604,58.343c8.088,13.074,13.52,26.149,14.807,40.487c16.254,4.563,32.426,5.494,48.76,2.61
  c4.475-0.796,8.645-1.63,12.627-3.482c-6.354,9.529-13.686,17.356-23.947,20.899c-9.811,3.387-19.637,6.688-30.473,6.968
  c17.641,6.675,37.082,7.045,57.033,5.659c-24.402,23.486-43.08,22.922-61.824,22.642c-8.221,34.703-25.025,69.315-60.52,101.005
  c-46.559,41.569-96.678,61.397-148.457,65.742c-48.552,4.07-95.488,3.512-146.726-20.464
  C56.486,393.349,24.648,368.884,0.001,334.932L0.001,334.932z"/></svg></a></li>
</ul>
  
  
  
  
  
<ul class="main-navigation">
  <li><a href="/"><h2>scattered thoughts</h2></a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Hugo-a-go-go</h1>
      
    
  </header>


<div class="entry-content"><p>For the <a href="http://clojurecup.com/">2013 Clojure Cup</a> myself and <a href="http://www.thattommyhall.com/">Tom Hall</a> wrote a <a href="http://en.wikipedia.org/wiki/Go_%28game%29">go</a> AI in clojurescript, inspired by <a href="https://github.com/ztellman/pushkin">pushkin</a>. The source is <a href="https://github.com/jamii/hugo-a-go-go/">here</a> and it can currently be played on the <a href="http://hugoagogo.clojurecup.com/">clojure cup site</a> (only tested in chrome).</p>

<!--more-->


<p>Before reading this post it would help to understand the rules of go. Hugo-a-go-go follows (an approximation of) the <a href="http://en.wikipedia.org/wiki/Rules_of_Go#Chinese_rules">chinese rules</a>. Due to the limited time we don&rsquo;t yet check for <a href="http://en.wikipedia.org/wiki/Rules_of_Go#Ko">ko</a> and don&rsquo;t even attempt to detect the end of the game. The code at the moment is incredibly messy and probably very buggy (the version we submitted seems to actually <em>try</em> to lose) so treat it with suspicion.</p>

<h2>Board</h2>

<p>The best place to start is with the board representation. The most expensive operation for the AI is detecting suicide and death. To make this fast we track connected strings of pieces.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defrecord </span><span class="nv">String</span> <span class="p">[</span><span class="nv">colour</span> <span class="nv">liberties</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>colour</code> is one of <code>:black</code>, <code>:white</code>, <code>:grey</code> (for the border) or <code>:empty</code>. <code>liberties</code> tracks the number of <a href="https://groups.google.com/forum/#!msg/computer-go-archive/hs259RQQ5hI/TOLFX2d5Y6UJ">pseudo-liberties</a> the string has (for black or white strings; for empty or grey strings the <code>liberties</code> value is never read and exists just to avoid having to branch on the colour).</p>

<p>The board is represented by a 1d array of pointers to strings (this representation is inspired by <a href="http://www.gnu.org/software/gnugo/">gnugo</a> rather than pushkin) and a pointer to the empty string (which we use for fast <code>empty?</code> checks).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Board</span> <span class="p">[</span><span class="nv">strings</span> <span class="nv">empty-string</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">size</span> <span class="mi">9</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">array-size</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="nv">size</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">max-pos</span> <span class="p">(</span><span class="nb">* </span><span class="nv">array-size</span> <span class="nv">array-size</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">-&gt;pos</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">array-size</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">y</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>To create a board we just have to setup the empty-string and border-string.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="k">new </span><span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">empty-string</span> <span class="p">(</span><span class="nf">-&gt;String</span> <span class="ss">:empty</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">border-string</span> <span class="p">(</span><span class="nf">-&gt;String</span> <span class="ss">:grey</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">strings</span> <span class="p">(</span><span class="nf">object-array</span> <span class="nv">max-pos</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="nv">max-pos</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">aset </span><span class="nv">strings</span> <span class="nv">i</span> <span class="nv">empty-string</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="nv">array-size</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">aset </span><span class="nv">strings</span> <span class="p">(</span><span class="nf">-&gt;pos</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">i</span><span class="p">)</span> <span class="mi">-1</span><span class="p">)</span> <span class="nv">border-string</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">aset </span><span class="nv">strings</span> <span class="p">(</span><span class="nf">-&gt;pos</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">i</span><span class="p">)</span> <span class="nv">size</span><span class="p">)</span> <span class="nv">border-string</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">aset </span><span class="nv">strings</span> <span class="p">(</span><span class="nf">-&gt;pos</span> <span class="mi">-1</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">i</span><span class="p">))</span> <span class="nv">border-string</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">aset </span><span class="nv">strings</span> <span class="p">(</span><span class="nf">-&gt;pos</span> <span class="nv">size</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">i</span><span class="p">))</span> <span class="nv">border-string</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">-&gt;Board</span> <span class="nv">strings</span> <span class="nv">empty-string</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>A given move is <em>not</em> suicide if, after the move is made, there is at least one neighbour which is either:</p>

<ul>
<li><p>the same colour and has more than zero liberties</p></li>
<li><p>the opposite colour and has zero liberties (ie would die if the move was carried through)</p></li>
<li><p>empty</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">suicide?</span> <span class="p">[</span><span class="o">^</span><span class="nv">Board</span> <span class="nv">board</span> <span class="nv">colour</span> <span class="nv">pos</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">suicide</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">true</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">opposite-colour</span> <span class="p">(</span><span class="nf">condp</span> <span class="nv">keyword-identical?</span> <span class="nv">colour</span> <span class="ss">:black</span> <span class="ss">:white</span> <span class="ss">:white</span> <span class="ss">:black</span><span class="p">)]</span>
</span><span class='line'>    <span class="c1">;; decrement all the neighbours liberties</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">foreach-neighbour</span> <span class="nv">neighbour-pos</span> <span class="nv">pos</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">string</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">neighbour-pos</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">string</span><span class="p">)</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">string</span><span class="p">)))))</span>
</span><span class='line'>    <span class="c1">;; check for suicide</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">foreach-neighbour</span> <span class="nv">neighbour-pos</span> <span class="nv">pos</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">string</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">neighbour-pos</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">condp</span> <span class="nv">keyword-identical?</span> <span class="p">(</span><span class="nf">.-colour</span> <span class="nv">string</span><span class="p">)</span>
</span><span class='line'>          <span class="nv">colour</span> <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">string</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">reset!</span> <span class="nv">suicide</span> <span class="nv">false</span><span class="p">))</span>
</span><span class='line'>          <span class="nv">opposite-colour</span> <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">string</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>                            <span class="p">(</span><span class="nf">reset!</span> <span class="nv">suicide</span> <span class="nv">false</span><span class="p">))</span>
</span><span class='line'>          <span class="ss">:empty</span> <span class="p">(</span><span class="nf">reset!</span> <span class="nv">suicide</span> <span class="nv">false</span><span class="p">)</span>
</span><span class='line'>          <span class="ss">:grey</span> <span class="nv">nil</span><span class="p">)))</span>
</span><span class='line'>    <span class="c1">;; undo the decrement</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">foreach-neighbour</span> <span class="nv">neighbour-pos</span> <span class="nv">pos</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">string</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">neighbour-pos</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">string</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">string</span><span class="p">)))))</span>
</span><span class='line'>    <span class="err">@</span><span class="nv">suicide</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Actually making a move is similar but we have to clear out dead strings and join adjacent strings together. Proving that it&rsquo;s safe to do all this in a single pass is straightforward, if tedious.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="kd">defn </span><span class="nv">set-colour</span> <span class="p">[</span><span class="o">^</span><span class="nv">Board</span> <span class="nv">board</span> <span class="nv">pos</span> <span class="nv">colour</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">string</span> <span class="p">(</span><span class="nf">-&gt;String</span> <span class="nv">colour</span> <span class="mi">0</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">aset </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">pos</span> <span class="nv">string</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">foreach-neighbour</span> <span class="nv">neighbour-pos</span> <span class="nv">pos</span>
</span><span class='line'>                       <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">neighbour-string</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">neighbour-pos</span><span class="p">)</span>
</span><span class='line'>                             <span class="nv">neighbour-colour</span> <span class="p">(</span><span class="nf">.-colour</span> <span class="nv">neighbour-string</span><span class="p">)]</span>
</span><span class='line'>                         <span class="p">(</span><span class="nf">condp</span> <span class="nv">keyword-identical?</span> <span class="nv">neighbour-colour</span>
</span><span class='line'>                           <span class="ss">:empty</span>
</span><span class='line'>                           <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-liberties</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">pos</span><span class="p">))</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">pos</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'>                           <span class="ss">:grey</span>
</span><span class='line'>                           <span class="nv">nil</span>
</span><span class='line'>
</span><span class='line'>                           <span class="nv">colour</span>
</span><span class='line'>                           <span class="p">(</span><span class="nf">do</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">neighbour-string</span><span class="p">)</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">neighbour-string</span><span class="p">)))</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">join-strings</span> <span class="nv">board</span> <span class="p">(</span><span class="nb">aget </span><span class="p">(</span><span class="nf">.-strings</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">neighbour-string</span> <span class="nv">pos</span> <span class="nv">neighbour-pos</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>                           <span class="c1">;; opposite colour</span>
</span><span class='line'>                           <span class="p">(</span><span class="nf">do</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">neighbour-string</span><span class="p">)</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">neighbour-string</span><span class="p">)))</span>
</span><span class='line'>                             <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">.-liberties</span> <span class="nv">neighbour-string</span><span class="p">))</span>
</span><span class='line'>                               <span class="p">(</span><span class="nf">clear-string</span> <span class="nv">board</span> <span class="nv">neighbour-string</span> <span class="nv">neighbour-pos</span><span class="p">))))))))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Monte Carlo</h2>

<p>Go branches far too much to exhaustively check all possible futures. Instead we use a heuristic measure of the value of a move &ndash; the Monte Carlo estimate of the expected score when both players choose from the set of valid moves uniformly at random. To put it simply, we run large numbers of random games from this board position and take the mean score as our measure of how strong this board position is. Since we don&rsquo;t have a test for the end of the game we just run until either 100 moves have been made or until both sides have no valid moves remaining.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">flood-fill</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">colour</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">filled</span> <span class="p">(</span><span class="nf">object-array</span> <span class="nv">max-pos</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">flood-fill-around</span> <span class="p">[</span><span class="nv">pos</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nf">foreach-neighbour</span> <span class="nv">pos</span> <span class="nv">pos</span>
</span><span class='line'>                  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">aget </span><span class="nv">filled</span> <span class="nv">pos</span><span class="p">))</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">keyword-identical?</span> <span class="ss">:empty</span> <span class="p">(</span><span class="nf">get-colour</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">)))</span>
</span><span class='line'>                    <span class="p">(</span><span class="nb">aset </span><span class="nv">filled</span> <span class="nv">pos</span> <span class="nv">true</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">flood-fill-around</span> <span class="nv">pos</span><span class="p">))))]</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">x</span> <span class="nv">size</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">y</span> <span class="nv">size</span><span class="p">]</span>
</span><span class='line'>          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pos</span> <span class="p">(</span><span class="nf">-&gt;pos</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)]</span>
</span><span class='line'>            <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">keyword-identical?</span> <span class="nv">colour</span> <span class="p">(</span><span class="nf">get-colour</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">aset </span><span class="nv">filled</span> <span class="nv">pos</span> <span class="nv">true</span><span class="p">)</span>
</span><span class='line'>              <span class="p">(</span><span class="nf">flood-fill-around</span> <span class="nv">pos</span><span class="p">))))))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">filter identity </span><span class="nv">filled</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">score</span> <span class="p">[</span><span class="nv">board</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">white-flood</span> <span class="p">(</span><span class="nf">flood-fill</span> <span class="nv">board</span> <span class="ss">:white</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">black-flood</span> <span class="p">(</span><span class="nf">flood-fill</span> <span class="nv">board</span> <span class="ss">:black</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">total</span> <span class="p">(</span><span class="nb">* </span><span class="nv">size</span> <span class="nv">size</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">overlap</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">+ </span><span class="nv">white-flood</span> <span class="nv">black-flood</span><span class="p">)</span> <span class="nv">total</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">white-score</span> <span class="p">(</span><span class="nb">- </span><span class="nv">white-flood</span> <span class="nv">overlap</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">black-score</span> <span class="p">(</span><span class="nb">- </span><span class="nv">black-flood</span> <span class="nv">overlap</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">{</span><span class="ss">:white</span> <span class="nv">white-score</span> <span class="ss">:black</span> <span class="nv">black-score</span><span class="p">}))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">random-move</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">colour</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">starting-pos</span> <span class="p">(</span><span class="nf">random-int</span> <span class="nv">board/max-pos</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">pos</span> <span class="nv">starting-pos</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">board/valid?</span> <span class="nv">board</span> <span class="nv">colour</span> <span class="nv">pos</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">board/eyelike?</span> <span class="nv">board</span> <span class="nv">colour</span> <span class="nv">pos</span><span class="p">)))</span>
</span><span class='line'>        <span class="nv">pos</span>
</span><span class='line'>        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">new-pos</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">pos</span><span class="p">)</span> <span class="nv">board/max-pos</span><span class="p">)]</span>
</span><span class='line'>          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">starting-pos</span> <span class="nv">new-pos</span><span class="p">)</span>
</span><span class='line'>            <span class="nv">nil</span>
</span><span class='line'>            <span class="p">(</span><span class="nf">recur</span> <span class="nv">new-pos</span><span class="p">)))))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">with-random-moves</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">n</span> <span class="nv">starting-colour</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">colour</span> <span class="p">(</span><span class="nb">take </span><span class="nv">n</span> <span class="p">(</span><span class="nb">interleave </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">starting-colour</span><span class="p">)</span> <span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nf">board/opposite-colour</span> <span class="nv">starting-colour</span><span class="p">))))]</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">move</span> <span class="p">(</span><span class="nf">random-move</span> <span class="nv">board</span> <span class="nv">colour</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">board/set-colour</span> <span class="nv">board</span> <span class="nv">move</span> <span class="nv">colour</span><span class="p">)))</span>
</span><span class='line'>  <span class="nv">board</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>You may notice that the above code actually only runs until one side has no moves &ndash; this is the first of many bugs.</p>

<p>The scoring and random-move code was a huge bottleneck so at the last minute I &lsquo;optimised&rsquo; it by changing it to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; rough approximation of the final score if the board is tightly packed</span>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">score</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">colour</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">score</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">pos</span> <span class="nv">board/max-pos</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">keyword-identical?</span> <span class="nv">colour</span> <span class="p">(</span><span class="nf">board/get-colour</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">swap!</span> <span class="nv">score</span> <span class="nv">inc</span><span class="p">)))</span>
</span><span class='line'>    <span class="err">@</span><span class="nv">score</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; massive speedup at the expense of never playing in killed spaces</span>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">with-random-moves-from</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">n</span> <span class="nv">starting-colour</span> <span class="nv">moves</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">js/goog.array.shuffle</span> <span class="nv">moves</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">colour</span> <span class="nv">starting-colour</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">move</span> <span class="p">(</span><span class="nf">.pop</span> <span class="nv">moves</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">board/set-colour</span> <span class="nv">board</span> <span class="nv">move</span> <span class="nv">colour</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">board/opposite-colour</span> <span class="nv">colour</span><span class="p">))))</span>
</span><span class='line'>  <span class="nv">board</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>I think it is these two changes that are largely responsible for the submitted version playing so poorly &ndash; it doesn&rsquo;t check for eyes in the random playouts, doesn&rsquo;t allow the other player to keep killing strings when the ai player has no moves and doesn&rsquo;t count eyes in the final score. This explains why it likes to tightly pack pieces against the edge of the board.</p>

<h2>UCT</h2>

<p>While the monte-carlo estimate gives us a reasonable heuristic for move strength it doesn&rsquo;t re-use any information between passes. With such a large move space we need to explore more intelligently. The <a href="http://teytaud.over-blog.com/article-35709049.html">UCT</a> algorithm treats move-selection like a <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>.</p>

<iframe width="640" height="360" src="//www.youtube.com/embed/dbvoPg51CqQ?feature=player_embedded" frameborder="0" allowfullscreen="allowfullscreen">video</iframe>


<p>We build a tree of moves where each node in the tree tracks not just the estimated score for all its child nodes but also the upper bound of a confidence interval on that estimate.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Node</span> <span class="p">[</span><span class="nv">parent</span> <span class="nv">colour</span> <span class="nv">pos</span> <span class="nb">count </span><span class="nv">sum</span> <span class="nv">nodes</span> <span class="nv">valids</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>colour</code> is the colour making the move at this node. <code>pos</code> is the position at which it is moving. <code>nodes</code> is a list of child nodes for which we have estimates. <code>valids</code> is a list of valid moves which have not yet been converted into nodes. <code>count</code> and <code>sum</code> track the mean score for all the children in <code>nodes</code>.</p>

<p>On each iteration we pick a path through the tree, choosing some explore/exploit tradeoff using the upper confidence bounds. Given the limited time we had, I decided to just copy a scoring function from a paper without stopping to understand it, so I don&rsquo;t actually know what explore/exploit tradeoff we are making :S</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">best-child</span> <span class="p">[</span><span class="nv">node</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">best-score</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
</span><span class='line'>        <span class="nv">best-child</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">nil</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">child</span> <span class="p">(</span><span class="nf">.-nodes</span> <span class="nv">node</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">score</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">.-sum</span> <span class="nv">child</span><span class="p">)</span> <span class="p">(</span><span class="nf">.-count</span> <span class="nv">child</span><span class="p">))</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">js/Math.sqrt</span>
</span><span class='line'>                      <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nf">js/Math.log</span> <span class="p">(</span><span class="nf">.-count</span> <span class="nv">node</span><span class="p">)))</span>
</span><span class='line'>                         <span class="p">(</span><span class="nb">* </span><span class="mi">5</span> <span class="p">(</span><span class="nf">.-count</span> <span class="nv">child</span><span class="p">)))))]</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">score</span> <span class="err">@</span><span class="nv">best-score</span><span class="p">)</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">reset!</span> <span class="nv">best-score</span> <span class="nv">score</span><span class="p">)</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">reset!</span> <span class="nv">best-child</span> <span class="nv">child</span><span class="p">))))</span>
</span><span class='line'>    <span class="err">@</span><span class="nv">best-child</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">expand</span> <span class="p">[</span><span class="nv">board</span> <span class="nb">node </span><span class="nv">ai-colour</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pos</span> <span class="p">(</span><span class="nf">.-pos</span> <span class="nv">node</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not= </span><span class="mi">0</span> <span class="nv">pos</span><span class="p">)</span> <span class="c1">;; top node has pos 0 - probably a smell</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">board/set-colour</span> <span class="nv">board</span> <span class="nv">pos</span> <span class="p">(</span><span class="nf">.-colour</span> <span class="nv">node</span><span class="p">))))</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">valid-pos</span> <span class="p">(</span><span class="nf">.pop</span> <span class="p">(</span><span class="nf">.-valids</span> <span class="nv">node</span><span class="p">))]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.push</span> <span class="p">(</span><span class="nf">.-nodes</span> <span class="nv">node</span><span class="p">)</span> <span class="p">(</span><span class="nf">expand-leaf</span> <span class="nv">board</span> <span class="nv">ai-colour</span> <span class="nb">node </span><span class="p">(</span><span class="nf">board/opposite-colour</span> <span class="p">(</span><span class="nf">.-colour</span> <span class="nv">node</span><span class="p">))</span> <span class="nv">valid-pos</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">child</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">.-colour</span> <span class="nv">node</span><span class="p">)</span> <span class="nv">ai-colour</span><span class="p">)</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">worst-child</span> <span class="nv">node</span><span class="p">)</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">best-child</span> <span class="nv">node</span><span class="p">))]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">expand</span> <span class="nv">board</span> <span class="nv">child</span> <span class="nv">ai-colour</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">nil</span> <span class="c1">;; no possible moves - pass</span>
</span><span class='line'>      <span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>On reaching a leaf we extend it by one more move, estimate the value of that move using monte-carlo simulations and then propagate the value back up the path to the top of tree.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">expand-leaf</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">ai-colour</span> <span class="nv">parent</span> <span class="nv">colour</span> <span class="nv">pos</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">board/set-colour</span> <span class="nv">board</span> <span class="nv">pos</span> <span class="nv">colour</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">valids</span> <span class="p">(</span><span class="nf">valids</span> <span class="nv">board</span> <span class="p">(</span><span class="nf">board/opposite-colour</span> <span class="nv">colour</span><span class="p">))]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">random/with-random-moves-from</span> <span class="nv">board</span> <span class="mi">100</span> <span class="p">(</span><span class="nf">board/opposite-colour</span> <span class="nv">colour</span><span class="p">)</span> <span class="p">(</span><span class="nf">aclone</span> <span class="nv">valids</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">value</span> <span class="p">(</span><span class="nf">value</span> <span class="nv">board</span> <span class="nv">ai-colour</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">add-value</span> <span class="nv">parent</span> <span class="nv">value</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">-&gt;Node</span> <span class="nv">parent</span> <span class="nv">colour</span> <span class="nv">pos</span> <span class="mi">1</span> <span class="nv">value</span> <span class="p">(</span><span class="nf">object-array</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">valids</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">add-value</span> <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-count</span> <span class="nv">node</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">.-count</span> <span class="nv">node</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-sum</span> <span class="nv">node</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">.-sum</span> <span class="nv">node</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">parent</span> <span class="p">(</span><span class="nf">.-parent</span> <span class="nv">node</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">recur</span> <span class="nv">parent</span> <span class="nv">value</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, the ai chooses its move by running a number of iterations of this algorithm and returning the value of <code>best-child</code> at the root (this is probably wrong &ndash; at this point we should just exploit, not explore).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">move-for</span> <span class="p">[</span><span class="nv">board</span> <span class="nv">colour</span> <span class="nv">n</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">node </span><span class="p">(</span><span class="nf">hugo-a-go-go.tree/new</span> <span class="p">(</span><span class="nf">board/copy</span> <span class="nv">board</span><span class="p">)</span> <span class="nv">colour</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">_</span> <span class="nv">n</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">expand</span> <span class="p">(</span><span class="nf">board/copy</span> <span class="nv">board</span><span class="p">)</span> <span class="nb">node </span><span class="nv">colour</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">child</span> <span class="p">(</span><span class="nf">best-child</span> <span class="nv">node</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">.-pos</span> <span class="nv">child</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Postmortem</h2>

<p>Together we spent around 20 man-hours on the competition. I spent the first two thirds of the competition just getting the board representation to work correctly. Part of the delay was that after moving to a cljs-only implementation the feedback loop was much slower. I wasted an hour or two tring to get brepl working without any success and after that had to rely on print statements and pre-compiled test cases. Finding errors in cljs also leaves a lot to be desired (eg a typo in a field name resulted in an <code>undefined</code> value which, several functions later, became a <code>NaN</code> which then behaves interestingly inside max/min). I only started on the UCT code an hour or two before the deadline. Tom started on the user input around the same time. We played our first game against the ai about five minutes before the deadline and frantically submitted whatever code we had running.</p>

<p>If we were taking it more seriously we certainly could have done a lot more to prepare &ndash; being familiar with the cljs dev tools, actually learning the rules of go, sketching out the board representation and the UCT implementation before the weekend started, not walking a marathon on the same weekend. But winning was not the goal and instead we had a lot of fun and excitement seeing just how much we can hack together in such a short space of time.</p>

<p>Our AI is definitely not correct so it&rsquo;s difficult to evaluate the project yet. The code is relatively short and simple (especially compared to eg <a href="http://git.savannah.gnu.org/cgit/gnugo.git/tree/engine">gnugo</a>) but that doesn&rsquo;t mean much until it actually works. The performance is promising &ndash; the current version can simulate around 5k games per second in chrome. Fixing the monte-carlo step and the scoring will eat into that performance but I&rsquo;ve already spotted plenty of inefficiencies in other places. We haven&rsquo;t even started experimenting with <a href="https://github.com/ztellman/vertigo">vertigo</a> or <a href="http://asmjs.org/">asm.js</a> yet so there is certainly lots of headroom.</p>

<p>I am definitely hoping to come back to this project. To echo <a href="http://www.youtube.com/watch?v=v5dYE0CMmHQ">Zach Tellman&rsquo;s motivation</a>, it will be really interesting to see if it is possible to write a competitive go AI in a high-level language. We&rsquo;ve also thought about distributing the UCT step and have team games pitching the aggregated wisdom of a group of human players voting on their next move against the assembled computing power of their browsing machines.</p>
</div>


  <footer>
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/05/21/flowing-faster-external-memory/" title="Previous Post: External memory">&laquo; External memory</a>
      
      
        <a class="basic-alignment right" href="/blog/2013/11/24/hugo-a-go-go-optimisation/" title="Next Post: Hugo-a-go-go: optimisation">Hugo-a-go-go: optimisation &raquo;</a>
      
    </p>
  </footer>
</article>
</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Jamie Brandon
</p>

</footer>
  











</body>
</html>
