<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Staged interpreters in Rust</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Staged interpreters in Rust</h1></header><article role="main"><p>Last week I was writing an interpreter for a query language. On arithmetic-heavy queries the interpreter overhead was &gt;10x compared to a compiled baseline. I tried staging the interpreter to move the overhead out of the inner loops. In the end the results weren’t worth the complexity compared to just writing a compiler so I didn’t end up finishing it. But I think it’s a neat idea anyway so I wrote a much simpler example to demonstrate.<p>(It’s essentially a <a href="http://okmij.org/ftp/tagless-final/JFP.pdf">tagless staged interpreter</a> with the addition of shared mutable state).<p>Let’s look at a much simpler example that I actually finished (<a href="https://github.com/jamii/rust-tagless/blob/master/src/main.rs">source code</a>). It’s an interpreter for a rather pointless little language that has just enough features to illustrate the idea.<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Type</span> <span class="p">{</span>
    <span class="n">Number</span><span class="p">,</span>
    <span class="n">Bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">Value</span> <span class="p">{</span>
    <span class="nf">Number</span><span class="p">(</span><span class="nb">i64</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="err">'</span><span class="k">static</span> <span class="nb">str</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Expr</span> <span class="p">{</span>
    <span class="nf">Constant</span><span class="p">(</span><span class="n">Value</span><span class="p">),</span>
    <span class="nf">Add</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span> <span class="c">// e1 + e2</span>
    <span class="nf">LessThan</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span> <span class="c">// e1 &lt; e2</span>
    <span class="nf">Let</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span> <span class="c">// let v::t = e1 in e2</span>
    <span class="nf">Get</span><span class="p">(</span><span class="n">Name</span><span class="p">),</span> <span class="c">// v</span>
    <span class="nf">Set</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span> <span class="c">// v = e</span>
    <span class="nf">While</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span> <span class="c">// while e1 { e2 }</span>
<span class="p">}</span>
</code></pre></div><p>This is enough to write a rather pointless little program:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">// let i = 1 {</span>
<span class="c">//   while i &lt; 1000 {</span>
<span class="c">//     i = i + 1</span>
<span class="c">//   }</span>
<span class="c">// }</span>
<span class="k">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Let</span><span class="p">(</span>
    <span class="s">"i"</span><span class="p">,</span> <span class="nn">Type</span><span class="p">::</span><span class="n">Number</span><span class="p">,</span> <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Constant</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
    <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">While</span><span class="p">(</span>
        <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">LessThan</span><span class="p">(</span><span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Get</span><span class="p">(</span><span class="s">"i"</span><span class="p">),</span> <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Constant</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">1000</span><span class="p">))),</span>
        <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Set</span><span class="p">(</span>
            <span class="s">"i"</span><span class="p">,</span>
            <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Add</span><span class="p">(</span><span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Get</span><span class="p">(</span><span class="s">"i"</span><span class="p">),</span> <span class="k">box</span> <span class="nn">Expr</span><span class="p">::</span><span class="nf">Constant</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
        <span class="p">),</span>
    <span class="p">),</span>
<span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="nf">interpret</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">expr</span><span class="p">));</span>
</code></pre></div><p>Let’s look at what happens in the interpreter when we run this program.<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Variable</span> <span class="p">{</span>
    <span class="nf">Number</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">env</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">Variable</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Value</span> <span class="p">{</span>
    <span class="k">match</span> <span class="o">*</span><span class="n">expr</span> <span class="p">{</span>
        <span class="err">..</span><span class="py">.
        Expr</span><span class="p">::</span><span class="nf">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">expr1</span><span class="p">,</span> <span class="k">ref</span> <span class="n">expr2</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">value1</span> <span class="o">=</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr1</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">value2</span> <span class="o">=</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr2</span><span class="p">);</span>
            <span class="k">match</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number1</span><span class="p">),</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number2</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span>
                    <span class="n">number1</span> <span class="o">+</span> <span class="n">number2</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error!"</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Get</span><span class="p">(</span><span class="k">ref</span> <span class="n">name</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">env</span><span class="nf">.get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">&amp;</span><span class="nn">Variable</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">ref</span> <span class="n">number_cell</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number_cell</span><span class="nf">.get</span><span class="p">()),</span>
                <span class="o">&amp;</span><span class="nn">Variable</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">ref</span> <span class="n">bool_cell</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">bool_cell</span><span class="nf">.get</span><span class="p">()),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Set</span><span class="p">(</span><span class="k">ref</span> <span class="n">name</span><span class="p">,</span> <span class="k">ref</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>
            <span class="k">match</span> <span class="p">(</span><span class="n">env</span><span class="nf">.get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="o">&amp;</span><span class="nn">Variable</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">ref</span> <span class="n">number_cell</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">number_cell</span><span class="nf">.set</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
                    <span class="n">value</span>
                <span class="p">}</span>
                <span class="p">(</span><span class="o">&amp;</span><span class="nn">Variable</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">ref</span> <span class="n">bool_cell</span><span class="p">),</span> <span class="o">&amp;</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">bool_cell</span><span class="nf">.set</span><span class="p">(</span><span class="nb">bool</span><span class="p">);</span>
                    <span class="n">value</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error!"</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">While</span><span class="p">(</span><span class="k">ref</span> <span class="n">expr1</span><span class="p">,</span> <span class="k">ref</span> <span class="n">expr2</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">while</span> <span class="k">true</span> <span class="p">{</span>
                <span class="k">match</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nf">interpret</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr2</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error!"</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The loop in our program executes <code class="highlighter-rouge">i = i + 1</code> on each iteration, and on each iteration we:<ol><li>Check what to do with each expression: <code class="highlighter-rouge">match *expr { ... }</code><li>Get the variable <code class="highlighter-rouge">i</code> from the environment hashtable twice: <code class="highlighter-rouge">env.get(name)</code><li>Check that the types of <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">1</code> are the same: <code class="highlighter-rouge">match (value1, value2) { ... }</code><li>Check that the types of <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">i + 1</code> are the same: <code class="highlighter-rouge">match (env.get(name).unwrap(), &amp;value) { ... }</code></ol><p>This is all wasted work. We know at the start of the loop that each of these decisions is going to come out the same way on every iteration. How can we avoid doing them on every iteration?<p>Suppose we have one pass that makes the decisions and another pass that actually runs the program. Something like:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">staged</span><span class="p">:</span> <span class="n">Staged</span> <span class="o">=</span> <span class="nf">stage</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">run</span><span class="p">(</span><span class="n">staged</span><span class="p">);</span>
</code></pre></div><p>What is <code class="highlighter-rouge">Staged</code>? It’s a thing that we can run and get back a <code class="highlighter-rouge">Value</code>. So the most general type we could use is a closure that returns <code class="highlighter-rouge">Value</code>:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="n">Staged</span> <span class="o">=</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Value</span><span class="o">&gt;</span>
</code></pre></div><p>But we actually need a bit more information to build these efficiently. Remember we want to know the type of things ahead of time so that we don’t have to check on every loop. So we need to pull the tag out of the <code class="highlighter-rouge">Value</code> and wrap the entire closure:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Staged</span> <span class="p">{</span>
    <span class="nf">Number</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i64</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div><p>These closures are going to close over variables, so we also need to make the variables shareable between multiple closures by adding a reference counted pointer:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">StagedVariable</span> <span class="p">{</span>
    <span class="nf">Number</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div><p>Now we can just glue together bits of code to make these closures:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">stage</span><span class="p">(</span><span class="n">env</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">StagedVariable</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Staged</span> <span class="p">{</span>
    <span class="k">match</span> <span class="o">*</span><span class="n">expr</span> <span class="p">{</span>
        <span class="err">..</span><span class="py">.
        Expr</span><span class="p">::</span><span class="nf">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">expr1</span><span class="p">,</span> <span class="k">ref</span> <span class="n">expr2</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">staged1</span> <span class="o">=</span> <span class="nf">stage</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr1</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">staged2</span> <span class="o">=</span> <span class="nf">stage</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr2</span><span class="p">);</span>
            <span class="k">match</span> <span class="p">(</span><span class="n">staged1</span><span class="p">,</span> <span class="n">staged2</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number1</span><span class="p">),</span> <span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number2</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                    <span class="nf">number1</span><span class="p">()</span> <span class="o">+</span> <span class="nf">number2</span><span class="p">()</span>
                <span class="p">}),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error!"</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Get</span><span class="p">(</span><span class="k">ref</span> <span class="n">name</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">env</span><span class="nf">.get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">&amp;</span><span class="nn">StagedVariable</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">ref</span> <span class="n">number_cell</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">number_cell</span> <span class="o">=</span> <span class="n">number_cell</span><span class="nf">.clone</span><span class="p">();</span>
                    <span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="n">number_cell</span><span class="nf">.get</span><span class="p">())</span>
                <span class="p">}</span>
                <span class="o">&amp;</span><span class="nn">StagedVariable</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">ref</span> <span class="n">bool_cell</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">bool_cell</span> <span class="o">=</span> <span class="n">bool_cell</span><span class="nf">.clone</span><span class="p">();</span>
                    <span class="nn">Staged</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="n">bool_cell</span><span class="nf">.get</span><span class="p">())</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Set</span><span class="p">(</span><span class="k">ref</span> <span class="n">name</span><span class="p">,</span> <span class="k">ref</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">staged</span> <span class="o">=</span> <span class="nf">stage</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>
            <span class="k">match</span> <span class="n">env</span><span class="nf">.get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">&amp;</span><span class="nn">StagedVariable</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">ref</span> <span class="n">number_cell</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="n">staged</span> <span class="p">{</span>
                        <span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">number_cell</span> <span class="o">=</span> <span class="n">number_cell</span><span class="nf">.clone</span><span class="p">();</span>
                            <span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                                <span class="k">let</span> <span class="n">number</span> <span class="o">=</span> <span class="nf">number</span><span class="p">();</span>
                                <span class="n">number_cell</span><span class="nf">.set</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
                                <span class="n">number</span>
                            <span class="p">})</span>
                        <span class="p">}</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error!"</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="o">&amp;</span><span class="nn">StagedVariable</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">ref</span> <span class="n">bool_cell</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="n">staged</span> <span class="p">{</span>
                        <span class="nn">Staged</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">bool_cell</span> <span class="o">=</span> <span class="n">bool_cell</span><span class="nf">.clone</span><span class="p">();</span>
                            <span class="nn">Staged</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                                <span class="k">let</span> <span class="nb">bool</span> <span class="o">=</span> <span class="nf">bool</span><span class="p">();</span>
                                <span class="n">bool_cell</span><span class="nf">.set</span><span class="p">(</span><span class="nb">bool</span><span class="p">);</span>
                                <span class="nb">bool</span>
                            <span class="p">})</span>
                        <span class="p">}</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error!"</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">While</span><span class="p">(</span><span class="k">ref</span> <span class="n">expr1</span><span class="p">,</span> <span class="k">ref</span> <span class="n">expr2</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nf">stage</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nn">Staged</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">bool1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">Staged</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="k">match</span> <span class="nf">stage</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr2</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nn">Staged</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">bool2</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                                <span class="k">while</span> <span class="nf">bool1</span><span class="p">()</span> <span class="p">{</span>
                                    <span class="nf">bool2</span><span class="p">();</span>
                                <span class="p">}</span>
                                <span class="k">false</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                        <span class="nn">Staged</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">number2</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">box</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                                <span class="k">while</span> <span class="nf">bool1</span><span class="p">()</span> <span class="p">{</span>
                                    <span class="nf">number2</span><span class="p">();</span>
                                <span class="p">}</span>
                                <span class="k">false</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Type error"</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Compared to before, on each iteration we now:<ol><li>Call a function pointer to find out what to do with each expr<li>Close over the variable <code class="highlighter-rouge">i</code> and just need to dereference a pointer<li>Have already checked that the types of <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">1</code> are the same<li>Have already checked that the types of <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">i + 1</code> are the same</ol><p>Calling a function pointer is cheaper than a single hashtable lookup. The actual interpreter I was working had much more overhead per bytecode and typically executed heavily nested loops, so this was a clear win.<p>It wasn’t all positive though. I struggled with the increasing complexity of the code:<ol><li>I needed to read external data, so the actual type was <code class="highlighter-rouge">type Staged&lt;'a&gt; = Box&lt;Fn() -&gt; Value + 'a&gt;</code>. The lifetimes infected everything else.<li>Even though the closures themselves are typically polymorphic, we need to dispatch on type to get a specialized version of the closure for each type. In the example above we are only dispatching on a single two-way type so it isn’t so bad. In the real version I had some MxN dispatches that created <a href="https://github.com/jamii/imp/blob/3f442d30bd845a39f5cbeb7f5360529af068bc69/src/interpreter.rs#L660-L793">astonishing amounts of boilerplate</a>.<li>The compiled baseline keeps all state on the stack. To do the same in the staged interpreter we would have to allow each closure to take arguments instead of closing over shared mutable state. The trouble is that while we know the size of each argument in advance, we can’t write code that is generic over the number of arguments. So we’d still end up having to heap-allocate a <code class="highlighter-rouge">Vec&lt;Argument&gt;</code> or similar. Unless we dispatched on the size too…</ol><p>In the end the whole thing was nixed by the fact that the staged interpreter had already become way more complex than the compiler I had written previously and that the improvements in compile time were more than lost by the slower run time.<p>I’m still curious whether the complexity can be circumvented, but I don’t have time to explore it further myself.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
