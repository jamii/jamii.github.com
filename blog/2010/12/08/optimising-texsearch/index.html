<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Optimising texsearch</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Optimising texsearch</h1></header><article role="main"><p><a href="https://github.com/jamii/texsearch">Texsearch</a> is a search engine for LaTeX formulae. It forms part of the backend for <a href="http://latexsearch.com">latexsearch.com</a> which indexes the entire Springer corpus.<p>Texsearch has only a minimal understanding of LaTeX and no understanding of the structure of the formulae it searches in, but unlike it’s competitors (eg <a href="http://uniquation.com/en/">Uniquation</a>) it’s able to index the entire Springer corpus and answer queries quickly and cheaply. It’s a brute force solution that gave us an good-enough search engine search engine with minimal research risk.<h2 id="parsing">Parsing</h2><p>When searching within LaTeX content we want results that represent the same formulae as the search term. Unfortunately LaTeX presents plenty of opportunities for obfuscating content with macros, presentation commands and just plain weird lexing.<p>Texsearch uses <a href="http://plastex.sourceforge.net/">PlasTeX</a> to parse LaTeX formulae and expand macros. The preprocessor then discards any LaTeX elements which relate to presentation rather than content (font, weight, colouring etc). The remaining LaTeX elements are each hashed into a 63 bit integer. This massively reduces the memory consumption, allowing the entire corpus and search index to be held in RAM. Collisions should be rare given that there are far less than 2^63 possible elements.<h2 id="indexing">Indexing</h2><p>At the core of texsearch is a search algorithm which performs approximate searches over the search corpus. Specifically, given a search term S and a search radius R we want to return all corpus terms T such that the <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> between S and some substring of T is less than R. This is a common problem in bioinformatics and NLP and there is a <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.7225&amp;rep=rep1&amp;type=pdf">substantial amount of research</a> on how to solve this efficiently. I have been through a range of different algorithms in previous iterations of texsearch and have only recently achieved reasonable performance (mean search time is now ~300ms for a corpus of 1.5m documents). The code is available <a href="https://github.com/jamii/texsearch">here</a>.<p>We define the distance from latexL to latexR as the minimum Levenshtein distance between latexL and any substring of latexR. With this definition we can specify the results of the search algorithm more simply as returning all corpus terms with distance R of S.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">distance</span> <span class="n">latexL</span> <span class="n">latexR</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">maxl</span><span class="p">,</span> <span class="n">maxr</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">latexL</span><span class="p">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">latexR</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">maxl</span> <span class="p">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">maxr</span> <span class="p">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">maxl</span> <span class="k">else</span>
  <span class="c">(* cache.(l).(r) is the distance between latexL[l to maxl] and latexR[r to maxr] *)</span>
  <span class="k">let</span> <span class="n">cache</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make_matrix</span> <span class="p">(</span><span class="n">maxl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">maxr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* Must match everything on the left *)</span>
  <span class="k">for</span> <span class="n">l</span> <span class="p">=</span> <span class="n">maxl</span> <span class="p">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">cache</span><span class="o">.(</span><span class="n">l</span><span class="o">).(</span><span class="n">maxr</span><span class="p">)</span> <span class="p">&lt;-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">cache</span><span class="o">.(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">).(</span><span class="n">maxr</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="c">(* General matching *)</span>
  <span class="k">for</span> <span class="n">l</span> <span class="p">=</span> <span class="n">maxl</span> <span class="p">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">r</span> <span class="p">=</span> <span class="n">maxr</span> <span class="p">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
      <span class="n">cache</span><span class="o">.(</span><span class="n">l</span><span class="o">).(</span><span class="n">r</span><span class="p">)</span> <span class="p">&lt;-</span>
          <span class="n">minimum</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cache</span><span class="o">.(</span><span class="n">l</span><span class="o">).(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cache</span><span class="o">.(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">).(</span><span class="n">r</span><span class="o">))</span>
            <span class="o">((</span><span class="n">abs</span> <span class="p">(</span><span class="n">compare</span> <span class="n">latexL</span><span class="o">.(</span><span class="n">l</span><span class="p">)</span> <span class="n">latexR</span><span class="o">.(</span><span class="n">r</span><span class="o">)))</span> <span class="o">+</span> <span class="n">cache</span><span class="o">.(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">).(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>
  <span class="k">done</span> <span class="k">done</span><span class="p">;</span>
  <span class="c">(* Non-matches on the right dont count until left starts matching *)</span>
  <span class="k">for</span> <span class="n">r</span> <span class="p">=</span> <span class="n">maxr</span> <span class="p">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">cache</span><span class="o">.(</span><span class="mi">0</span><span class="o">).(</span><span class="n">r</span><span class="p">)</span> <span class="p">&lt;-</span>
        <span class="n">minimum</span>
          <span class="p">(</span><span class="n">cache</span><span class="o">.(</span><span class="mi">0</span><span class="o">).(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>
          <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cache</span><span class="o">.(</span><span class="mi">1</span><span class="o">).(</span><span class="n">r</span><span class="o">))</span>
          <span class="o">((</span><span class="n">abs</span> <span class="p">(</span><span class="n">compare</span> <span class="n">latexL</span><span class="o">.(</span><span class="mi">0</span><span class="p">)</span> <span class="n">latexR</span><span class="o">.(</span><span class="n">r</span><span class="o">)))</span> <span class="o">+</span> <span class="n">cache</span><span class="o">.(</span><span class="mi">1</span><span class="o">).(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">cache</span><span class="o">.(</span><span class="mi">0</span><span class="o">).(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div><p>The search algorithm is built around a <a href="http://en.wikipedia.org/wiki/Suffix_array">suffix array</a> presenting the following interface:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="p">:</span> <span class="kt">unit</span> <span class="p">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">add</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="p">*</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="kt">list</span> <span class="p">-&gt;</span> <span class="kt">unit</span>
<span class="k">val</span> <span class="n">prepare</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="kt">unit</span>

<span class="k">val</span> <span class="n">delete</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="p">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="kt">unit</span>

<span class="k">val</span> <span class="n">find_exact</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="kt">int</span> <span class="p">*</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">find_approx</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="kt">float</span> <span class="p">-&gt;</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="kt">int</span> <span class="p">*</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">find_query</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="kt">float</span> <span class="p">-&gt;</span> <span class="nn">Query</span><span class="p">.</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="kt">int</span> <span class="p">*</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="kt">list</span>
</code></pre></div><p>The data structure is pretty straightforward. We store the LaTeX elements in a DynArray and represent suffixes by a pair of pointers - the first into the DynArray and the second into the LaTeX term itself. Each LaTeX term is matched to an opaque object which is used by the consumer of this module to id the terms.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="n">id</span> <span class="p">=</span> <span class="kt">int</span>
<span class="k">type</span> <span class="n">pos</span> <span class="p">=</span> <span class="kt">int</span>

<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="p">=</span>
  <span class="p">{</span> <span class="n">latexs</span> <span class="p">:</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">t</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">t</span>
  <span class="p">;</span> <span class="n">opaques</span> <span class="p">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">t</span>
  <span class="p">;</span> <span class="k">mutable</span> <span class="n">next_id</span> <span class="p">:</span> <span class="n">id</span>
  <span class="p">;</span> <span class="k">mutable</span> <span class="kt">array</span> <span class="p">:</span> <span class="p">(</span><span class="n">id</span> <span class="p">*</span> <span class="n">pos</span><span class="p">)</span> <span class="kt">array</span>
  <span class="p">;</span> <span class="k">mutable</span> <span class="n">unsorted</span> <span class="p">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="p">*</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="kt">list</span> <span class="p">}</span>

<span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="p">=</span>
  <span class="p">{</span> <span class="n">latexs</span> <span class="p">=</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>
  <span class="p">;</span> <span class="n">opaques</span> <span class="p">=</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>
  <span class="p">;</span> <span class="n">next_id</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">;</span> <span class="kt">array</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">;</span> <span class="n">unsorted</span> <span class="p">=</span> <span class="bp">[]</span><span class="p">}</span>
</code></pre></div><p>The suffix array is built in a completely naive way. We just throw all the suffixes into a list and sort it. There are much more efficient methods known but this is fast enough, especially since we do updates offline. The building is separated into two functions to make incremental updates easier.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="n">sa</span> <span class="n">latexs</span> <span class="p">=</span>
  <span class="n">sa</span><span class="p">.</span><span class="n">unsorted</span> <span class="p">&lt;-</span> <span class="n">latexs</span> <span class="o">@</span> <span class="n">sa</span><span class="p">.</span><span class="n">unsorted</span>

<span class="k">let</span> <span class="n">insert</span> <span class="n">sa</span> <span class="p">(</span><span class="n">opaque</span><span class="p">,</span> <span class="n">latex</span><span class="p">)</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">id</span> <span class="p">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">next_id</span> <span class="k">in</span>
  <span class="n">sa</span><span class="p">.</span><span class="n">next_id</span> <span class="p">&lt;-</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nn">DynArray</span><span class="p">.</span><span class="n">add</span> <span class="n">sa</span><span class="p">.</span><span class="n">opaques</span> <span class="n">opaque</span><span class="p">;</span>
  <span class="nn">DynArray</span><span class="p">.</span><span class="n">add</span> <span class="n">sa</span><span class="p">.</span><span class="n">latexs</span> <span class="n">latex</span><span class="p">;</span>
  <span class="n">id</span>

<span class="k">let</span> <span class="n">prepare</span> <span class="n">sa</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">ids</span> <span class="p">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="n">insert</span> <span class="n">sa</span><span class="p">)</span> <span class="n">sa</span><span class="p">.</span><span class="n">unsorted</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">new_suffixes</span> <span class="p">=</span> <span class="nn">Util</span><span class="p">.</span><span class="n">concat_map</span> <span class="p">(</span><span class="n">suffixes</span> <span class="n">sa</span><span class="p">)</span> <span class="n">ids</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">cmp</span> <span class="p">=</span> <span class="n">compare_suffix</span> <span class="n">sa</span> <span class="k">in</span>
  <span class="k">let</span> <span class="kt">array</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">merge</span> <span class="n">cmp</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fast_sort</span> <span class="n">cmp</span> <span class="n">new_suffixes</span><span class="p">)</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">to_list</span> <span class="n">sa</span><span class="p">.</span><span class="kt">array</span><span class="o">))</span> <span class="k">in</span>
  <span class="n">sa</span><span class="p">.</span><span class="n">unsorted</span> <span class="p">&lt;-</span> <span class="bp">[]</span><span class="p">;</span>
  <span class="n">sa</span><span class="p">.</span><span class="kt">array</span> <span class="p">&lt;-</span> <span class="kt">array</span>
</code></pre></div><h2 id="exact-queries">Exact queries</h2><p>So now we have a sorted array of suffixes of all our corpus terms. If we want to find all exact matches for a given search term we just do a binary search to find the first matching suffix and then scan through the array until the last matching suffix. For reasons that will make more sense later, we divide this into two stages. Most of the work is done in <code class="highlighter-rouge">gather_exact</code>, where we perform the search and dump the resulting LaTeX term ids into a HashSet. Then <code class="highlighter-rouge">find_exact</code> runs through the HashSet and looks up the matching opaques.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="c">(* binary search *)</span>
<span class="k">let</span> <span class="n">gather_exact</span> <span class="n">ids</span> <span class="n">sa</span> <span class="n">latex</span> <span class="p">=</span>
  <span class="c">(* find beginning of region *)</span>
  <span class="c">(* lo &lt; latex *)</span>
  <span class="c">(* hi &gt;= latex *)</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">narrow</span> <span class="n">lo</span> <span class="n">hi</span> <span class="p">=</span>
    <span class="k">let</span> <span class="n">mid</span> <span class="p">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">((</span><span class="n">hi</span><span class="p">-</span><span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="p">=</span> <span class="n">mid</span> <span class="k">then</span> <span class="n">hi</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">leq</span> <span class="n">sa</span> <span class="n">latex</span> <span class="n">sa</span><span class="p">.</span><span class="kt">array</span><span class="o">.(</span><span class="n">mid</span><span class="p">)</span>
    <span class="k">then</span> <span class="n">narrow</span> <span class="n">lo</span> <span class="n">mid</span>
    <span class="k">else</span> <span class="n">narrow</span> <span class="n">mid</span> <span class="n">hi</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">sa</span><span class="p">.</span><span class="kt">array</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">traverse</span> <span class="n">index</span> <span class="p">=</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">then</span> <span class="bp">()</span> <span class="k">else</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">=</span> <span class="n">sa</span><span class="p">.</span><span class="kt">array</span><span class="o">.(</span><span class="n">index</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">is_prefix</span> <span class="n">sa</span> <span class="n">latex</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">then</span>
      <span class="k">begin</span>
	<span class="nn">Hashset</span><span class="p">.</span><span class="n">add</span> <span class="n">ids</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">traverse</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">else</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="n">traverse</span> <span class="p">(</span><span class="n">narrow</span> <span class="o">(-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="p">-</span><span class="mi">1</span><span class="o">))</span>

<span class="k">let</span> <span class="n">exact_match</span> <span class="n">sa</span> <span class="n">id</span> <span class="p">=</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">get</span> <span class="n">sa</span><span class="p">.</span><span class="n">opaques</span> <span class="n">id</span><span class="p">)</span>

<span class="k">let</span> <span class="n">find_exact</span> <span class="n">sa</span> <span class="n">latex</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">ids</span> <span class="p">=</span> <span class="nn">Hashset</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="n">gather_exact</span> <span class="n">ids</span> <span class="n">sa</span> <span class="n">latex</span><span class="p">;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="n">exact_match</span> <span class="n">sa</span><span class="p">)</span> <span class="p">(</span><span class="nn">Hashset</span><span class="p">.</span><span class="n">to_list</span> <span class="n">ids</span><span class="p">)</span>
</code></pre></div><h2 id="approximate-queries">Approximate queries</h2><p>Suppose the distance from our search term S to some corpus term T is strictly less than the search radius R. That means that if we split S into R pieces at least one of those pieces must match a substring of T exactly. So our approximate search algorithm is to perform exact searches for each of the R pieces and then calculate the distance to each of the results. Notice the similarity in structure to the previous algorithm. You can also see now that the exact search is split into two functions so that we can reuse <code class="highlighter-rouge">gather_exact</code>.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">gather_approx</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">latex</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">k</span> <span class="p">=</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">cutoff</span> <span class="n">precision</span> <span class="n">latex</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ids</span> <span class="p">=</span> <span class="nn">Hashset</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="n">gather_exact</span> <span class="n">ids</span> <span class="n">sa</span><span class="p">)</span> <span class="p">(</span><span class="nn">Latex</span><span class="p">.</span><span class="n">fragments</span> <span class="n">latex</span> <span class="n">k</span><span class="o">);</span>
  <span class="n">ids</span>

<span class="k">let</span> <span class="n">approx_match</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">latexL</span> <span class="n">id</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">latexR</span> <span class="p">=</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">get</span> <span class="n">sa</span><span class="p">.</span><span class="n">latexs</span> <span class="n">id</span> <span class="k">in</span>
  <span class="k">match</span> <span class="nn">Latex</span><span class="p">.</span><span class="n">similar</span> <span class="n">precision</span> <span class="n">latexL</span> <span class="n">latexR</span> <span class="k">with</span>
  <span class="p">|</span> <span class="nc">Some</span> <span class="n">dist</span> <span class="p">-&gt;</span>
      <span class="k">let</span> <span class="n">opaque</span> <span class="p">=</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">get</span> <span class="n">sa</span><span class="p">.</span><span class="n">opaques</span> <span class="n">id</span> <span class="k">in</span>
      <span class="nc">Some</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">opaque</span><span class="p">)</span>
  <span class="p">|</span> <span class="nc">None</span> <span class="p">-&gt;</span>
      <span class="nc">None</span>

<span class="k">let</span> <span class="n">find_approx</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">latex</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">ids</span> <span class="p">=</span> <span class="n">gather_approx</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">latex</span> <span class="k">in</span>
  <span class="nn">Util</span><span class="p">.</span><span class="n">filter_map</span> <span class="p">(</span><span class="n">approx_match</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">latex</span><span class="p">)</span> <span class="p">(</span><span class="nn">Hashset</span><span class="p">.</span><span class="n">to_list</span> <span class="n">ids</span><span class="p">)</span>
</code></pre></div><p>We can also extend this to allow boolean queries.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">gather_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">query</span> <span class="k">with</span>
  <span class="p">|</span> <span class="nn">Query</span><span class="p">.</span><span class="nc">Latex</span> <span class="p">(</span><span class="n">latex</span><span class="p">,</span> <span class="o">_)</span> <span class="p">-&gt;</span> <span class="n">gather_approx</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">latex</span>
  <span class="p">|</span> <span class="nn">Query</span><span class="p">.</span><span class="nc">And</span> <span class="p">(</span><span class="n">query1</span><span class="p">,</span> <span class="n">query2</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nn">Hashset</span><span class="p">.</span><span class="n">inter</span> <span class="p">(</span><span class="n">gather_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query1</span><span class="p">)</span> <span class="p">(</span><span class="n">gather_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query2</span><span class="p">)</span>
  <span class="p">|</span> <span class="nn">Query</span><span class="p">.</span><span class="nc">Or</span> <span class="p">(</span><span class="n">query1</span><span class="p">,</span> <span class="n">query2</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nn">Hashset</span><span class="p">.</span><span class="n">union</span> <span class="p">(</span><span class="n">gather_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query1</span><span class="p">)</span> <span class="p">(</span><span class="n">gather_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query2</span><span class="p">)</span>

<span class="k">let</span> <span class="n">query_match</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query</span> <span class="n">id</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">latexR</span> <span class="p">=</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">get</span> <span class="n">sa</span><span class="p">.</span><span class="n">latexs</span> <span class="n">id</span> <span class="k">in</span>
  <span class="k">match</span> <span class="nn">Query</span><span class="p">.</span><span class="n">similar</span> <span class="n">precision</span> <span class="n">query</span> <span class="n">latexR</span> <span class="k">with</span>
  <span class="p">|</span> <span class="nc">Some</span> <span class="n">dist</span> <span class="p">-&gt;</span>
      <span class="k">let</span> <span class="n">opaque</span> <span class="p">=</span> <span class="nn">DynArray</span><span class="p">.</span><span class="n">get</span> <span class="n">sa</span><span class="p">.</span><span class="n">opaques</span> <span class="n">id</span> <span class="k">in</span>
      <span class="nc">Some</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">opaque</span><span class="p">)</span>
  <span class="p">|</span> <span class="nc">None</span> <span class="p">-&gt;</span>
      <span class="nc">None</span>

<span class="k">let</span> <span class="n">find_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">ids</span> <span class="p">=</span> <span class="n">gather_query</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query</span> <span class="k">in</span>
  <span class="nn">Util</span><span class="p">.</span><span class="n">filter_map</span> <span class="p">(</span><span class="n">query_match</span> <span class="n">sa</span> <span class="n">precision</span> <span class="n">query</span><span class="p">)</span> <span class="p">(</span><span class="nn">Hashset</span><span class="p">.</span><span class="n">to_list</span> <span class="n">ids</span><span class="p">)</span>
</code></pre></div><p>This is a lot simpler than my previous approach, which required some uncomfortable reasoning about overlapping regions in quasi-metric spaces.<h2 id="memory-usage">Memory usage</h2><p>This is a significant speed improvement over previous versions but it now consumes a ridiculous amount of memory. The instance running <a href="http://latexsearch.com">latexsearch.com</a> wavers around 4.7 gb during normal operation and reaches 7-8 gb when updating the index. This pushes other services out of main memory and everything is horribly slow until they swap back in.<p>The main data structure is a suffix array with type <code class="highlighter-rouge">(id * pos) array</code>, which is responsible for the vast majority of the memory usage. Each cell in the array contains a pointer to a tuple containing two integers, for a total of 4 words per suffix. The types id and pos are both small integers so if we pack them into a single unboxed integer we can reduce this to 1 word per suffix.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Suffix</span> <span class="p">=</span> <span class="k">struct</span>

<span class="k">type</span> <span class="n">id</span> <span class="p">=</span> <span class="kt">int</span>
<span class="k">type</span> <span class="n">pos</span> <span class="p">=</span> <span class="kt">int</span>

<span class="k">type</span> <span class="n">t</span> <span class="p">=</span> <span class="kt">int</span>

<span class="k">let</span> <span class="n">pack_size</span> <span class="p">=</span> <span class="p">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">word_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">-</span> <span class="mi">1</span>
<span class="k">let</span> <span class="n">max_size</span> <span class="p">=</span> <span class="mi">1</span> <span class="ow">lsl</span> <span class="n">pack_size</span>

<span class="k">exception</span> <span class="nc">Invalid_suffix</span> <span class="k">of</span> <span class="n">id</span> <span class="p">*</span> <span class="n">pos</span>

<span class="k">let</span> <span class="n">pack</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">=</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="p">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">max_size</span><span class="p">)</span>
  <span class="o">||</span> <span class="p">(</span><span class="n">pos</span> <span class="p">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">max_size</span><span class="p">)</span>
  <span class="k">then</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Invalid_suffix</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">pos</span><span class="o">))</span>
  <span class="k">else</span> <span class="n">pos</span> <span class="ow">lor</span> <span class="p">(</span><span class="n">id</span> <span class="ow">lsl</span> <span class="n">pack_size</span><span class="p">)</span>

<span class="k">let</span> <span class="n">unpack</span> <span class="n">suffix</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">id</span> <span class="p">=</span> <span class="n">suffix</span> <span class="n">lsr</span> <span class="n">pack_size</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">suffix</span> <span class="ow">land</span> <span class="p">(</span><span class="n">max_size</span> <span class="p">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

<span class="k">end</span>
</code></pre></div><p>The main data structure then becomes <code class="highlighter-rouge">Suffix.t array</code>. With this change the memory usage drops down to 1.4 gb. The mean search time also improves. It seems that having fewer cache misses makes up for the extra computation involved in unpacking the suffixes.<p>Now that the array field is a single block in memory it is easy to move it out of the heap entirely so the gc never has to scan it.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">ancientify</span> <span class="n">sa</span> <span class="p">=</span>
  <span class="n">sa</span><span class="p">.</span><span class="kt">array</span> <span class="p">&lt;-</span> <span class="nn">Ancient</span><span class="p">.</span><span class="n">follow</span> <span class="p">(</span><span class="nn">Ancient</span><span class="p">.</span><span class="n">mark</span> <span class="n">sa</span><span class="p">.</span><span class="kt">array</span><span class="o">);</span>
  <span class="nn">Gc</span><span class="p">.</span><span class="n">full_major</span> <span class="bp">()</span>
</code></pre></div><p>This eliminates gc pauses, and we finally have a usable system.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
