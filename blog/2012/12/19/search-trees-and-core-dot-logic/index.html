<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Search trees and core.logic</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Search trees and core.logic</h1></header><article role="main"><p>I mentioned in an <a href="http://scattered-thoughts.net/blog/2012/12/02/hacker-school/">earlier post</a> that I had spent some time working on <a href="https://github.com/jamii/shackles">shackles</a>, an extensible <a href="http://en.wikipedia.org/wiki/Constraint_programming">constraint solver</a> based on <a href="http://www.gecode.org/">gecode</a> with extensions for <a href="http://en.wikipedia.org/wiki/Logic_programming">logic programming</a>. I eventually gave up working on shackles in favor of using <a href="https://github.com/clojure/core.logic">core.logic</a> which is much more mature and has actual maintainers. Last week David Nolen (the author of core.logic) was visiting Hacker School so I decided to poke around inside core.logic and see what could be brought over from shackles. The <a href="https://github.com/clojure/core.logic/pull/13">first chunk of work</a> adds fair conjunction, user-configurable search and a parallel solver.<p>First, a little background. From a high-level point of view, a constraint solver does three things:<ul><li><p>specifies a search space in the form of a set of constraints<li><p>turns that search space into a search tree<li><p>searches the resulting tree for non-failed leaves</ul><p>Currently core.logic (and cKanren before it) complects all three of these. My patch partly decomplects the latter from the first two, allowing different search algorithms to be specified independently of the problem specification.<p>Let’s look at how core.logic works. I’m going to gloss over a lot of implementation details in order to make the core ideas clearer.<p>The search tree in core.logic is representated as a lazy stream of the non-failed leaves of the tree. This stream can be:<ul><li><p><code class="highlighter-rouge">nil</code> - the empty stream<li><p><code class="highlighter-rouge">(Choice. head tail)</code> - a cons cell</ul><p>Disjunction of two goals produces a new goal which contains the search trees of the two goals as adjacent branches. In core.logic, this is implemented by combining their streams with <code class="highlighter-rouge">mplus</code>. A naive implementation might look like this:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">mplus</span><span class="w"> </span><span class="p">[</span><span class="n">stream1</span><span class="w"> </span><span class="n">stream2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">stream1</span><span class="p">)</span><span class="w"> </span><span class="n">stream2</span><span class="w">
    </span><span class="p">(</span><span class="nf">choice?</span><span class="w"> </span><span class="n">stream1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Choice.</span><span class="w"> </span><span class="p">(</span><span class="nf">.head</span><span class="w"> </span><span class="n">stream1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">mplus</span><span class="w"> </span><span class="p">(</span><span class="nf">.tail</span><span class="w"> </span><span class="n">stream1</span><span class="p">)</span><span class="w"> </span><span class="n">stream2</span><span class="p">))))</span><span class="w">
</span></code></pre></div><p>This amounts to a depth-first search of the leaves of the tree. Unfortunately, search trees in core.logic can be infinitely deep so a depth-first search can get stuck. If the first branch has an infinite subtree we will never see results from the second branch.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; simple non-terminating goal
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">forevero</span><span class="w">
  </span><span class="p">(</span><span class="nf">fresh</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="n">forevero</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">run*</span><span class="w"> </span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">conde</span><span class="w">
    </span><span class="p">[</span><span class="n">forvero</span><span class="p">]</span><span class="w">
    </span><span class="p">[(</span><span class="nb">==</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="mi">1</span><span class="p">)]))</span><span class="w">

</span><span class="c1">;; with depth-first search blocks immediately, returning (...)
;; with breadth-first search blocks after the first result, returning (1 ...)
</span></code></pre></div><p>We can perform breadth-first search by adding a new stream type:<ul><li><code class="highlighter-rouge">(fn [] stream)</code> - a thunk representing a branch in the search tree</ul><p>And then interleaving results from each branch:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">mplus</span><span class="w"> </span><span class="p">[</span><span class="n">stream1</span><span class="w"> </span><span class="n">stream2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="p">(</span><span class="nf">fn?</span><span class="w"> </span><span class="n">stream1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nf">mplus</span><span class="w"> </span><span class="n">stream2</span><span class="w"> </span><span class="p">(</span><span class="nf">stream1</span><span class="p">)))))</span><span class="w">
</span></code></pre></div><p>This is how core.logic implements fair disjunction (fair in the sense that all branches of <code class="highlighter-rouge">conde</code> will be explored equally). However, we still have a problem with fair conjunction. Conjunction is performed in core.logic by running the second goal starting at each of the leaves of the tree of the first goal. In terms of the stream representation, this looks like:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="p">[</span><span class="n">stream</span><span class="w"> </span><span class="n">goal</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="c1">;; failure
</span><span class="w">    </span><span class="p">(</span><span class="nf">choice?</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Choice.</span><span class="w"> </span><span class="p">(</span><span class="nf">bind</span><span class="w"> </span><span class="p">(</span><span class="nf">.head</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bind</span><span class="w"> </span><span class="p">(</span><span class="nf">.tail</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">fn?</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nf">bind</span><span class="w"> </span><span class="p">(</span><span class="nf">stream</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">))))</span><span class="w">
</span></code></pre></div><p>This gives rise to similar behaviour as the naive version of <code class="highlighter-rouge">mplus</code>:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">run*</span><span class="w"> </span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">all</span><span class="w">
    </span><span class="n">forevero</span><span class="w">
    </span><span class="p">(</span><span class="nf">!=</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">q</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; with unfair conjunction blocks immediately, returning (...)
;; with fair conjunction the second branch causes failure, returning ()
</span></code></pre></div><p>I suspect the reason that core.logic didn’t yet have fair conjunction is entirely due to this stream representation, which complects all three stages of constraint solving and hides the underlying search tree. Since shackles is based on gecode it has the advantage of a much clearer theoretical framework (I strongly recommend <a href="http://www.gecode.org/paper.html?id=Tack:PhD:2009">this paper</a>, not just for the insight into gecode but as a shining example of how mathematical intuition can be used to guide software design).<p>The first step in introducing fair conjunction to core.logic is to explicitly represent the search tree. The types are similar:<ul><li><code class="highlighter-rouge">nil</code> - the empty tree<li><code class="highlighter-rouge">(Result. state)</code> - a leaf<li><code class="highlighter-rouge">(Choice. left right)</code> - a branch<li><code class="highlighter-rouge">(Thunk. state goal)</code> - a thunk containing the current state and a sub-goal</ul><p>Defining <code class="highlighter-rouge">mplus</code> is now trivial since it is no longer responsible for interleaving results:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">mplus</span><span class="w"> </span><span class="p">[</span><span class="n">tree1</span><span class="w"> </span><span class="n">tree2</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">Choice.</span><span class="w"> </span><span class="n">tree1</span><span class="w"> </span><span class="n">tree2</span><span class="p">))</span><span class="w">
</span></code></pre></div><p>And we now have two variants of bind:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bind-unfair</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="w"> </span><span class="n">goal</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">goal</span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="c1">;; failure
</span><span class="w">    </span><span class="p">(</span><span class="nf">result?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">goal</span><span class="w"> </span><span class="p">(</span><span class="nf">.state</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="c1">;; success, start the second tree here
</span><span class="w">    </span><span class="p">(</span><span class="nf">choice?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Choice.</span><span class="w"> </span><span class="p">(</span><span class="nf">bind-unfair</span><span class="w"> </span><span class="p">(</span><span class="nf">.left</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bind-unfair</span><span class="w"> </span><span class="p">(</span><span class="nf">.right</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">thunk?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Thunk.</span><span class="w"> </span><span class="p">(</span><span class="nf">.state</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bind-unfair</span><span class="w"> </span><span class="p">((</span><span class="nf">.goal</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bind-fair</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="w"> </span><span class="n">goal</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">goal</span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="c1">;; failure
</span><span class="w">    </span><span class="p">(</span><span class="nf">result?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">goal</span><span class="w"> </span><span class="p">(</span><span class="nf">.state</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="c1">;; success, start the second tree here
</span><span class="w">    </span><span class="p">(</span><span class="nf">choice?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Choice.</span><span class="w"> </span><span class="p">(</span><span class="nf">bind-fair</span><span class="w"> </span><span class="p">(</span><span class="nf">.left</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bind-fair</span><span class="w"> </span><span class="p">(</span><span class="nf">.right</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="n">goal</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">thunk?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">Thunk.</span><span class="w"> </span><span class="p">(</span><span class="nf">.state</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bind-fair</span><span class="w"> </span><span class="p">(</span><span class="nf">goal</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">.goal</span><span class="w"> </span><span class="n">tree</span><span class="p">)))))</span><span class="w"> </span><span class="c1">;; interleave!
</span></code></pre></div><p>The crucial difference here is that bind-fair takes advantage of the continuation-like thunk to interleave both goals, allowing each to do one thunk’s worth of work before switching to the next.<p>(We keep bind-unfair around because it tends to be faster in practice - when you know what order your goals will be run in you can use domain knowledge to specify the most optimal order. However, making program evaluation dependent on goal ordering is less declarative and there are also some problems that cannot be specified without fair conjunction. It’s nice to have both.)<p>Now that we explicity represent the tree we can use different search algorithms. My patch defaults to lazy, breadth-first search (to maintain the previous semantics) but it also supplies a variety of others including a <a href="https://github.com/jamii/core.logic/blob/flexible-search/src/main/clojure/clojure/core/logic/par.clj#L49">parallel depth-first search</a> using <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">fork-join</a>.<p>I still need to write a few more tests and sign the clojure contributor agreement before this can be considered for merging. I also have a pesky performance regression in lazy searches - this branch sometimes does more work than the original when only finding the first solution. I’m not sure yet whether this is down to a lack of laziness somewhere or maybe just a result of a slightly different search order. Either way, it needs to be fixed.<p>After this change, core.logic still complects the specification of the search space and the generation of the search tree (eg we have to choose between bind-unfair and bind-fair in the problem specification). At some point I would like to either fix that in core.logic or finish work on shackles. For now though, I’m going back to working on <a href="https://github.com/jamii/droplet">droplet</a>.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
