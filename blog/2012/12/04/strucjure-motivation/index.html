<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Strucjure: motivation</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Strucjure: motivation</h1></header><article role="main"><p>I feel that the readme for <a href="https://github.com/jamii/strucjure">strucjure</a> does a reasonable job of explaining how to use the library but not of explaining why you would want to. I want to do that here. I’m going to focus on the motivation behind strucjure and the use cases for it rather than the internals, so try not to worry too much about how this all works and just focus on the ideas (the implementation itself is <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">very simple</a> but liable to keep changing).<p>The core idea is that strucjure (and the <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;ved=0CFIQFjAD&amp;url=http%3A%2F%2Flambda-the-ultimate.org%2Fnode%2F2477&amp;ei=lQ69UJqrLK-WyAHC1IGIBg&amp;usg=AFQjCNEJAMQULpZ62ASYefNHadlUWTlgKA&amp;sig2=E1ePKzLJJNaFw5BfEG9rrA">OMeta</a> library on which it is based) is not just yet-another-parser, but is instead a concise language for describing, manipulating and transforming data structures. The <a href="http://www.vpri.org/">VPRI</a> folks have done some amazing things with OMeta. My goal with strucjure is to see how much further this idea can be taken.<p>(Note: For the purposes of this post I’ll use the terms pattern and view interchangeably. There <em>is</em> a difference, but the line between the two is not yet clear to me and will probably change in future implementations)<h2 id="pattern-matching">Pattern matching</h2><p>Pattern matching is a concept found in many functional languages. The basic idea is something like a switch statement, combined with a mini-language for describing patterns which the input should be tested against. The first pattern which matches has its corresponding branch executed.<p>As a very simple example, we can use strucjure to write fizzbuzz like this:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">100</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">prn</span><span class="w">
   </span><span class="p">(</span><span class="nf">match</span><span class="w"> </span><span class="p">[(</span><span class="nf">mod</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">5</span><span class="p">)]</span><span class="w">
          </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="s">"fizzbuzz"</span><span class="w">
          </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="s">"fizz"</span><span class="w">
          </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="s">"buzz"</span><span class="w">
          </span><span class="n">_</span><span class="w">      </span><span class="n">i</span><span class="p">)))</span><span class="w">
</span></code></pre></div><p>This is a concise, readable description of the various cases and replaces a chain of if-statements.<p>If we stopped there, you could be forgiven for not caring. Simple examples don’t really demonstrate the power of pattern matching. Let’s instead look at a more complicated example - <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black trees</a>. An important operation on red-black trees is re-establishing the balance invariants after inserting a new node. Here is a java implementation of the balance operation (from <a href="http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">this implementation</a>):<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="c1">// make a left-leaning link lean to the right</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">RED</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">N</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// make a right-leaning link lean to the left</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">RED</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">N</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// flip the colors of a node and its two children</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">flipColors</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// h must have opposite color of its two children</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">assert</span> <span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">&amp;&amp;</span>  <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span>  <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">)</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
        <span class="n">h</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// restore red-black tree invariant</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">balance</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>                      <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>     <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>

        <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>This pile of if-statements obscures the intent of the code, which is to re-arrange the tree so that no red node has a red child. What we really want to see is ‘if the tree looks like foo, replace it with bar’. Using pattern matching we can express this directly (code based on <a href="http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec11.html">this implementation</a>):<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Leaf</span><span class="w"> </span><span class="p">[])</span><span class="w">
</span><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="p">[</span><span class="nb">left</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="nb">right</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">Black</span><span class="w"> </span><span class="p">[</span><span class="nb">left</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="nb">right</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">balance</span><span class="w">
  </span><span class="c1">;; if it looks like one of these...
</span><span class="w">  </span><span class="p">(</span><span class="nb">or</span><span class="w">
   </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">?a</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?b</span><span class="p">)</span><span class="w"> </span><span class="n">?y</span><span class="w"> </span><span class="n">?c</span><span class="p">)</span><span class="w"> </span><span class="n">?z</span><span class="w"> </span><span class="n">?d</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">?a</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">?b</span><span class="w"> </span><span class="n">?y</span><span class="w"> </span><span class="n">?c</span><span class="p">))</span><span class="w"> </span><span class="n">?z</span><span class="w"> </span><span class="n">?d</span><span class="p">)</span><span class="w">
   </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="n">?a</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">?b</span><span class="w"> </span><span class="n">?y</span><span class="w"> </span><span class="n">?c</span><span class="p">)</span><span class="w"> </span><span class="n">?z</span><span class="w"> </span><span class="n">?d</span><span class="p">))</span><span class="w">
   </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="n">?a</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">?b</span><span class="w"> </span><span class="n">?y</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">?c</span><span class="w"> </span><span class="n">?z</span><span class="w"> </span><span class="n">?d</span><span class="p">))))</span><span class="w">
  </span><span class="c1">;; replace it with this...
</span><span class="w">  </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">d</span><span class="p">))</span><span class="w">

  </span><span class="c1">;; otherwise, leave it alone
</span><span class="w">  </span><span class="n">?other</span><span class="w">
  </span><span class="n">other</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>(Note that this isn’t exactly the same operation as the code above, because the corresponding implementation has a slightly different insert algorithm too. Nevertheless, converting this operation to java would result in the same grotesque expansion of if-statements).<p>Strucjure is not very optimized yet, but if you use a more mature pattern-matching library then this code would be as fast as what you would write by hand. For complex patterns <a href="https://github.com/clojure/core.match">core.match</a> often does a better job of optimizing the decision tree than I can manage by hand, in much the same way that GCC does a better job of writing assembly code than I ever could.<p>Strucjure patterns are first-class values and can call other patterns or recursively call themselves, so they can express much more complex patterns than other pattern matchers. For example:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">balanced-height</span><span class="w">
  </span><span class="n">Leaf</span><span class="w">
  </span><span class="mi">0</span><span class="w">

  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">Black.</span><span class="w"> </span><span class="n">_</span><span class="w">
         </span><span class="p">(</span><span class="nf">balanced-height</span><span class="w"> </span><span class="n">?l</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">balanced-height</span><span class="w"> </span><span class="n">?r</span><span class="p">))</span><span class="w">
       </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">Red.</span><span class="w"> </span><span class="n">_</span><span class="w">
         </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="n">Red</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">balanced-height</span><span class="w"> </span><span class="n">?l</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="n">Red</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">balanced-height</span><span class="w"> </span><span class="n">?r</span><span class="p">)))</span><span class="w">
       </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">))</span><span class="w">
  </span><span class="n">l</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>This is a pattern which only matches balanced red-black trees, by recursively matching against each branch and returning the number of black nodes per path (see property 5 <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Properties">here</a>).<h2 id="parsing">Parsing</h2><p>Strucjure supports patterns which only consume part of the input and can chain these patterns together. Combine that with pattern matching and you can very easily write back-tracking recursive-descent parsers.<p>We can use this for traditional text parsing (you have to be feeling a little masochistic at the moment because strucjure can’t directly handle strings yet, only sequences of \c \h \a \r \s). For example, strucjure <a href="http://scattered-thoughts.net/blog/2012/10/25/strucjure-reading-the-readme/">parses its own readme</a> to ensure all the examples are correct.<p>Parsing doesn’t have to be limited to text. We can apply the same techniques to any sequential data structure.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">defnview</span><span class="w"> </span><span class="n">zero-or-more-prefix</span><span class="w"> </span><span class="p">[</span><span class="n">elem</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nf">elem</span><span class="w"> </span><span class="n">?x</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more-prefix</span><span class="w"> </span><span class="n">elem</span><span class="p">)</span><span class="w"> </span><span class="n">?xs</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/zero-or-more-prefix</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">self-counting</span><span class="w">
        </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="ss">'one</span><span class="w">
        </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="ss">'two</span><span class="w">
        </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="ss">'three</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/self-counting</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="p">(</span><span class="nf">zero-or-more-prefix</span><span class="w"> </span><span class="n">self-counting</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">one</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">two</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>Since we live in lisp land, code is data too. We can use strucjure to easily and <em>readably</em> (hopefully) operate over sexps.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; generic parser for (right-binding) infix operators with precedence
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">value?</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">not-any?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bind*</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="n">current</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[[</span><span class="n">ops</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">tighter</span><span class="p">]</span><span class="w"> </span><span class="n">current</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">view</span><span class="w">
     </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">bind*</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">tighter</span><span class="p">)</span><span class="w"> </span><span class="n">?x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">ops</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">?op</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">bind*</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="n">?y</span><span class="p">))</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="o">~</span><span class="n">op</span><span class="w"> </span><span class="o">~</span><span class="n">x</span><span class="w"> </span><span class="o">~</span><span class="n">y</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">bind*</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">tighter</span><span class="p">)</span><span class="w"> </span><span class="n">?x</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">view</span><span class="w">
     </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="p">[((</span><span class="nf">bind*</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">all</span><span class="p">)</span><span class="w"> </span><span class="n">?x</span><span class="p">)])</span><span class="w"> </span><span class="n">x</span><span class="w">
     </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">value?</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">?x</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="p">[</span><span class="n">binding-levels</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">bind*</span><span class="w"> </span><span class="n">binding-levels</span><span class="w"> </span><span class="n">binding-levels</span><span class="p">))</span><span class="w">

</span><span class="c1">;; run 'bind with basic arithmetic precedences
</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">math</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="p">(</span><span class="nf">bind</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="p">{</span><span class="ss">'+</span><span class="w"> </span><span class="ss">'-</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="ss">'*</span><span class="w"> </span><span class="ss">'/</span><span class="p">}])</span><span class="w"> </span><span class="n">args</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">macroexpand</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">math</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (- 1 (+ 2 (- 3 4)))
</span><span class="p">(</span><span class="nb">macroexpand</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">math</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">/</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (+ 1 (+ (* 2 7) (/ 1 2)))
</span><span class="p">(</span><span class="nb">macroexpand</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">math</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">7</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nb">/</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="c1">;; (+ 1 (* 2 (/ (7 + 1) 2)))
</span></code></pre></div><p>No more death-by-polish-notation!<p>(The operators above really ought to bind to the left but, unlike ometa, strucjure doesn’t yet support <a href="http://en.wikipedia.org/wiki/Left_recursion">left-recursion</a> and I’m too lazy to manually transform the grammar. It’s a temporary limitation.)<p>Taking this to its logical conclusion, the syntax for patterns and views in strucjure is itself defined <a href="https://github.com/jamii/strucjure/blob/master/src/strucjure/parser.clj#L178">using views</a>. This is a fairly complex DSL but with strucjure it’s was very easy to write, read and modify the parser.<h2 id="generic-programming">Generic programming</h2><p>Clojure has some great facilities for generic traversals in the form of clojure.walk:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">walk</span><span class="w">
  </span><span class="s">"Traverses form, an arbitrary data structure.  inner and outer are
  functions.  Applies inner to each element of form, building up a
  data structure of the same type, then applies outer to the result.
  Recognizes all Clojure data structures. Consumes seqs as with doall."</span><span class="w">

  </span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.1"</span><span class="p">}</span><span class="w">
  </span><span class="p">[</span><span class="n">inner</span><span class="w"> </span><span class="n">outer</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
   </span><span class="p">(</span><span class="nf">list?</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">outer</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="n">form</span><span class="p">)))</span><span class="w">
   </span><span class="p">(</span><span class="nb">instance?</span><span class="w"> </span><span class="n">clojure.lang.IMapEntry</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">outer</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="n">form</span><span class="p">)))</span><span class="w">
   </span><span class="p">(</span><span class="nb">seq?</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">outer</span><span class="w"> </span><span class="p">(</span><span class="nb">doall</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="n">form</span><span class="p">)))</span><span class="w">
   </span><span class="p">(</span><span class="nf">coll?</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">outer</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">(</span><span class="nf">empty</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="n">form</span><span class="p">)))</span><span class="w">
   </span><span class="no">:else</span><span class="w"> </span><span class="p">(</span><span class="nf">outer</span><span class="w"> </span><span class="n">form</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">postwalk</span><span class="w">
  </span><span class="s">"Performs a depth-first, post-order traversal of form. Calls f on
each sub-form, uses f's return value in place of the original.
Recognizes all Clojure data structures except sorted-map-by.
Consumes seqs as with doall."</span><span class="w">
  </span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.1"</span><span class="p">}</span><span class="w">
  </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">walk</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">postwalk</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">form</span><span class="p">))</span><span class="w">
</span></code></pre></div><p>Essentially, all this is doing is specifying how to take apart clojure data structures and how to put them back together again. Strucjure supports passing optional :pre-view and :post-view functions to modify the input to or output from any named view encountered during parsing, so we can do something very similar:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">clojure</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">list?</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">clojure</span><span class="p">)</span><span class="w"> </span><span class="n">?xs</span><span class="p">))</span><span class="w"> </span><span class="n">xs</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">clojure.lang.IMapEntry</span><span class="w"> </span><span class="p">[</span><span class="n">?x</span><span class="w"> </span><span class="n">?y</span><span class="p">])</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="nb">seq?</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">clojure</span><span class="p">)</span><span class="w"> </span><span class="n">?xs</span><span class="p">))</span><span class="w"> </span><span class="n">xs</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">coll?</span><span class="w"> </span><span class="n">?coll</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">clojure</span><span class="p">)</span><span class="w"> </span><span class="n">?xs</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">(</span><span class="nf">empty</span><span class="w"> </span><span class="n">coll</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w">
  </span><span class="n">?other</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">postwalk</span><span class="w"> </span><span class="p">[</span><span class="n">form</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">clojure</span><span class="w"> </span><span class="n">form</span><span class="w"> </span><span class="p">{</span><span class="no">:post-view</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">sub-form</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">sub-form</span><span class="p">)}))</span><span class="w">
</span></code></pre></div><p>The problem with using this (or clojure.walk) for generic traversals is that it loses context. When a given sub-form is encountered, the function f is given no indication of where in the data structure that sub-form is or how it is being used. If we apply the above idea to domain-specific views we can do generic traversals <em>with context</em>. The motivating example for this was a simple game I was porting called <a href="https://github.com/jamii/l-seed">l-seed</a> (I haven’t yet updated l-seed to use strucjure, but you can see a precursor to it in <a href="https://github.com/jamii/l-seed/blob/master/src/l_seed/syntax.clj">l-seed.syntax</a>). In l-seed, players submit programs defining the growth of their plant species and compete with other player’s plants for sunlight and nutrients. The plant language can be defined like this:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+name+</span><span class="w">
  </span><span class="nb">string?</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+tag+</span><span class="w">
  </span><span class="nb">string?</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+length+</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+direction+</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">-360</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">360</span><span class="p">))</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+relation+</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="ss">'=</span><span class="w"> </span><span class="ss">'&gt;</span><span class="w"> </span><span class="ss">'&gt;=</span><span class="w"> </span><span class="ss">'&lt;</span><span class="w"> </span><span class="ss">'&lt;=</span><span class="p">)</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+property+</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="ss">'tag</span><span class="w"> </span><span class="ss">'length</span><span class="w"> </span><span class="ss">'direction</span><span class="p">)</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+condition+</span><span class="w">
  </span><span class="p">[</span><span class="ss">'and</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">+condition+</span><span class="p">)</span><span class="w"> </span><span class="n">?conditions</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">'and</span><span class="w"> </span><span class="n">conditions</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'or</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">+condition+</span><span class="p">)</span><span class="w"> </span><span class="n">?conditions</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">'or</span><span class="w"> </span><span class="n">conditions</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'not</span><span class="w"> </span><span class="p">(</span><span class="nf">+condition+</span><span class="w"> </span><span class="n">?condition</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'not</span><span class="w"> </span><span class="n">condition</span><span class="p">)</span><span class="w">
  </span><span class="p">[(</span><span class="nf">+relation+</span><span class="w"> </span><span class="n">?relation</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">+property+</span><span class="w"> </span><span class="n">?property</span><span class="p">)</span><span class="w"> </span><span class="n">?value</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">value</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+condition-head+</span><span class="w">
  </span><span class="p">[</span><span class="ss">'when</span><span class="w"> </span><span class="p">(</span><span class="nf">+condition+</span><span class="w"> </span><span class="n">?condition</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'when</span><span class="w"> </span><span class="n">condition</span><span class="p">)</span><span class="w">
  </span><span class="ss">'whenever</span><span class="w"> </span><span class="ss">'whenever</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+action+</span><span class="w">
  </span><span class="p">[</span><span class="ss">'grow-by</span><span class="w"> </span><span class="p">(</span><span class="nf">+length+</span><span class="w"> </span><span class="n">?length</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'grow-by</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'turn-by</span><span class="w"> </span><span class="p">(</span><span class="nf">+direction+</span><span class="w"> </span><span class="n">?direction</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'turn-by</span><span class="w"> </span><span class="n">direction</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'turn-to</span><span class="w"> </span><span class="p">(</span><span class="nf">+direction+</span><span class="w"> </span><span class="n">?direction</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'turn-to</span><span class="w"> </span><span class="n">direction</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'tag</span><span class="w"> </span><span class="p">(</span><span class="nf">+tag+</span><span class="w"> </span><span class="n">?tag</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'tag</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'blossom</span><span class="w"> </span><span class="p">(</span><span class="nf">+tag+</span><span class="w"> </span><span class="n">?tag</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'blossom</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w">
  </span><span class="p">[</span><span class="ss">'branch</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="p">(</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">+action+</span><span class="p">))</span><span class="w"> </span><span class="n">?action-lists</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">'branch</span><span class="w"> </span><span class="n">action-lists</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+rule+</span><span class="w">
  </span><span class="p">[</span><span class="ss">'rule</span><span class="w"> </span><span class="p">(</span><span class="nf">+name+</span><span class="w"> </span><span class="n">?name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">+condition-head+</span><span class="w"> </span><span class="n">?condition-head</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">+action+</span><span class="p">)</span><span class="w"> </span><span class="n">?actions</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">list</span><span class="w"> </span><span class="ss">'rule</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">condition-head</span><span class="w"> </span><span class="n">actions</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">+rules+</span><span class="w">
  </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">+rule+</span><span class="p">)</span><span class="w"> </span><span class="n">?rules</span><span class="p">)]</span><span class="w"> </span><span class="n">rules</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>(Note that we specify both how to take apart a data structure and how to put it together. Really, the latter should be derived from the former. I think strucjure will eventually feature reversible patterns for this purpose.)<p>We can then operate on these programs in a generic way. For example, deciding which rule to execute next:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">select*</span><span class="w"> </span><span class="p">[</span><span class="n">properties</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">defview</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+relation+</span><span class="w"> </span><span class="n">?relation</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">resolve</span><span class="w"> </span><span class="n">relation</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+property+</span><span class="w"> </span><span class="n">?property</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">properties</span><span class="w"> </span><span class="n">property</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+condition+</span><span class="w"> </span><span class="p">[</span><span class="ss">'and</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">?conds</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">true?</span><span class="w"> </span><span class="n">conds</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+condition+</span><span class="w"> </span><span class="p">[</span><span class="ss">'or</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">?conds</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="nb">true?</span><span class="w"> </span><span class="n">conds</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+condition+</span><span class="w"> </span><span class="p">[</span><span class="ss">'not</span><span class="w"> </span><span class="n">?cond</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="k">cond</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+condition+</span><span class="w"> </span><span class="p">[</span><span class="n">?relation</span><span class="w"> </span><span class="n">?property</span><span class="w"> </span><span class="n">?value</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">relation</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+condition-head+</span><span class="w"> </span><span class="p">[</span><span class="ss">'when</span><span class="w"> </span><span class="n">?condition</span><span class="p">]]</span><span class="w"> </span><span class="n">condition</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+condition-head+</span><span class="w"> </span><span class="p">[</span><span class="ss">'whenever</span><span class="p">]]</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+rule+</span><span class="w"> </span><span class="p">[</span><span class="ss">'rule</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">?condition</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">?actions</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="n">actions</span><span class="p">)</span><span class="w">
    </span><span class="p">[</span><span class="o">`</span><span class="n">+rules+</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">?rules</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">choose</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">seq</span><span class="w"> </span><span class="n">rules</span><span class="p">))</span><span class="w">
    </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="n">?other</span><span class="p">]</span><span class="w"> </span><span class="n">other</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="nb">select</span><span class="w"> </span><span class="p">[</span><span class="n">rules</span><span class="w"> </span><span class="n">properties</span><span class="p">]</span><span class="w">
  </span><span class="s">"Pick a valid rule and return its list of actions (or nil if no rules are valid)"</span><span class="w">
  </span><span class="p">(</span><span class="nf">utilpostwalk</span><span class="w"> </span><span class="n">+rules+</span><span class="w"> </span><span class="n">rules</span><span class="w"> </span><span class="p">(</span><span class="nf">select*</span><span class="w"> </span><span class="n">properties</span><span class="p">)))</span><span class="w">
</span></code></pre></div><p>Writing code like this allows us to separate the shape of the data from the computation we perform over it.<p>We’re also not limited to just walking over data structures. We can perform more complex operations in the same generic fashion.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">map-reduce</span><span class="w"> </span><span class="p">[</span><span class="n">strucjure</span><span class="w"> </span><span class="n">form</span><span class="w"> </span><span class="n">map-op</span><span class="w"> </span><span class="n">reduce-op</span><span class="p">]</span><span class="w">
  </span><span class="s">"Call map-op on every sub-form and reduce results with reduce-op"</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">(</span><span class="nf">reduce-op</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">strucjure</span><span class="w"> </span><span class="n">form</span><span class="w">
           </span><span class="p">{</span><span class="no">:post-view</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
                         </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">reduce-op</span><span class="w"> </span><span class="p">(</span><span class="nf">map-op</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">form</span><span class="p">))</span><span class="w">
                         </span><span class="n">form</span><span class="p">)})</span><span class="w">
    </span><span class="err">@</span><span class="n">acc</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">collect</span><span class="w"> </span><span class="p">[</span><span class="n">strucjure</span><span class="w"> </span><span class="n">form</span><span class="w"> </span><span class="n">filter-op</span><span class="p">]</span><span class="w">
  </span><span class="s">"Return all sub-forms satisfying filter-op"</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="n">nil</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">strucjure</span><span class="w"> </span><span class="n">form</span><span class="w">
           </span><span class="p">{</span><span class="no">:post-view</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
                         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">filter-op</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">form</span><span class="p">)</span><span class="w">
                           </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="p">)))})</span><span class="w">
    </span><span class="err">@</span><span class="n">acc</span><span class="p">))</span><span class="w">
</span></code></pre></div><h2 id="types">Types</h2><p>I originally learned to code in haskell. One of the things I miss about strong static typing is it that it automatically provides documentation about the data structures used in your program. Strucjure patterns can fulfill the same role. In l-seed, if you are confused about what a rule should look like you can just go look at the +rule+ pattern.<p>We can’t quite get static typing out of this, but we do get runtime checking for complex typedata-structures:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">defgenotype</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">rules</span><span class="p">]</span><span class="w">
  </span><span class="c1">;; compile-time syntax check for the genotype language
</span><span class="w">  </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">+rules+</span><span class="w"> </span><span class="n">rules</span><span class="p">)</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">~</span><span class="nb">name</span><span class="w"> </span><span class="o">'~</span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="n">rules</span><span class="p">)))</span><span class="w">
</span></code></pre></div><p>In theory, it should also be possible to generate random data structures satisfying a given pattern. This would be useful for providing examples and for <a href="https://github.com/clojure/test.generative">generative testing</a>. In erlang, <a href="https://github.com/manopapad/proper">proper</a> allows using type-specs directly alongside hand-written generators. I haven’t yet implemented this in strucjure but I think it should be reasonably easy once reversible patterns are implemented.<h2 id="state-machines">State machines</h2><p>One can think of parsers in general as state machines with look-ahead and backtracking. OMeta takes this idea and runs with it:<blockquote><p>Most interesting ideas have more than one fruitful way to view them, and it occurred to us that, abstractly, one could think of TCP/IP as a kind of “non‐deterministic parser with balancing heuristics”, in that it takes in a stream of things, does various kinds of pattern‐matching on them, deals with errors by backing up and taking other paths, and produces a transformation of the input in a specified form as a result.<p>Since the language transformation techniques we use operate on arbitrary objects, not just strings (see above), and include some abilities of both standard and logic programming, it seemed that this could be used to make a very compact TCP/IP. Our first attempt was about 160 lines of code that was robust enough to run a website. We think this can be done even more compactly and clearly, and we plan to take another pass at this next year.</blockquote><p>I haven’t yet tried doing anything like this in strucjure, but all the machinery is there. It would make an interesting complement to <a href="https://github.com/jamii/droplet">droplet</a>.<h2 id="moving-forward">Moving forward</h2><p>There are of lot of different directions for improvement and experimentation.<p>One of my top priorities is better error reporting. This sucks:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="n">clojure.lang.ExceptionInfo</span><span class="err">:</span><span class="w"> </span><span class="n">throw+</span><span class="err">:</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.view.PartialMatch</span><span class="p">{</span><span class="no">:view</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.view.Or</span><span class="p">{</span><span class="no">:views</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">strucjure.view.Match</span><span class="p">{</span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Seq</span><span class="p">{</span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Chain</span><span class="p">{</span><span class="no">:patterns</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">strucjure.view.Import</span><span class="p">{</span><span class="no">:view-fun</span><span class="w"> </span><span class="o">#</span><span class="n">&lt;test$bind_STAR_$fn__2339</span><span class="w"> </span><span class="n">test$bind_STAR_$fn__2339</span><span class="err">@</span><span class="mi">60</span><span class="n">a896b8&gt;,</span><span class="w"> </span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Bind</span><span class="p">{</span><span class="no">:symbol</span><span class="w"> </span><span class="n">x</span><span class="p">}}</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Head</span><span class="p">{</span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.And</span><span class="p">{</span><span class="no">:patterns</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">strucjure.pattern.Guard</span><span class="p">{</span><span class="no">:fun</span><span class="w"> </span><span class="o">#</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">clojure.lang.AFunction$1</span><span class="err">@</span><span class="mi">5</span><span class="n">c3f3b9b&gt;</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Bind</span><span class="p">{</span><span class="no">:symbol</span><span class="w"> </span><span class="n">op</span><span class="p">}]}}</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.view.Import</span><span class="p">{</span><span class="no">:view-fun</span><span class="w"> </span><span class="o">#</span><span class="n">&lt;test$bind_STAR_$fn__2343</span><span class="w"> </span><span class="n">test$bind_STAR_$fn__2343</span><span class="err">@</span><span class="mi">3</span><span class="n">b626c6d&gt;,</span><span class="w"> </span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Bind</span><span class="p">{</span><span class="no">:symbol</span><span class="w"> </span><span class="n">y</span><span class="p">}}]}}</span><span class="n">,</span><span class="w"> </span><span class="no">:result-fun</span><span class="w"> </span><span class="o">#</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">clojure.lang.AFunction$1</span><span class="err">@</span><span class="mi">3</span><span class="n">abc8690&gt;</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.view.Match</span><span class="p">{</span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Seq</span><span class="p">{</span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Chain</span><span class="p">{</span><span class="no">:patterns</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="n">strucjure.view.Import</span><span class="p">{</span><span class="no">:view-fun</span><span class="w"> </span><span class="o">#</span><span class="n">&lt;test$bind_STAR_$fn__2347</span><span class="w"> </span><span class="n">test$bind_STAR_$fn__2347</span><span class="err">@</span><span class="mi">2</span><span class="n">f267610&gt;,</span><span class="w"> </span><span class="no">:pattern</span><span class="w"> </span><span class="o">#</span><span class="n">strucjure.pattern.Bind</span><span class="p">{</span><span class="no">:symbol</span><span class="w"> </span><span class="n">x</span><span class="p">}}]}}</span><span class="n">,</span><span class="w"> </span><span class="no">:result-fun</span><span class="w"> </span><span class="o">#</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">clojure.lang.AFunction$1</span><span class="err">@</span><span class="mi">6112</span><span class="n">c9f&gt;</span><span class="p">}]}</span><span class="n">,</span><span class="w"> </span><span class="no">:input</span><span class="w"> </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="n">,</span><span class="w"> </span><span class="no">:remaining</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="n">,</span><span class="w"> </span><span class="no">:output</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w">
</span></code></pre></div><p>I have some ideas about how to improve this but nothing totally concrete. I could, at the very least, return the bindings that existed at the point of failure along with some kind of failure stack. If I can figure out a reasonable way to implement <a href="http://en.wikipedia.org/wiki/Cut_%28logic_programming%29">cut</a> that will also help.<p>Another short-term priority is some form of <a href="http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons">tail call elemination</a>. Many patterns and views are naturally implemented in a recursive fashion:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defnview</span><span class="w"> </span><span class="n">zero-or-more</span><span class="w"> </span><span class="p">[</span><span class="n">elem</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="p">(</span><span class="nf">elem</span><span class="w"> </span><span class="n">?x</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">elem</span><span class="p">)</span><span class="w"> </span><span class="n">?xs</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>But in the current implementation of strucjure this will quickly overflow the stack. The current workaround is to define such views by hand:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">ZeroOrMore</span><span class="w"> </span><span class="p">[</span><span class="n">view</span><span class="p">]</span><span class="w">
  </span><span class="n">View</span><span class="w">
  </span><span class="p">(</span><span class="nf">run*</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="n">opts</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w">
           </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nb">instance?</span><span class="w"> </span><span class="n">clojure.lang.Seqable</span><span class="w"> </span><span class="n">input</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">elems</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w">
             </span><span class="n">outputs</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[[</span><span class="n">elem</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">elems</span><span class="p">]</span><span class="w"> </span><span class="n">elems</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[[</span><span class="n">remaining</span><span class="w"> </span><span class="n">output</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">opts</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">remaining</span><span class="p">)</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">elems</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="n">outputs</span><span class="p">))</span><span class="w">
              </span><span class="p">[(</span><span class="nb">cons</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">elems</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="n">outputs</span><span class="p">)])</span><span class="w">
            </span><span class="p">[(</span><span class="nb">cons</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">elems</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="n">outputs</span><span class="p">)])</span><span class="w">
          </span><span class="p">[</span><span class="n">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="n">outputs</span><span class="p">)])))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">zero-or-more</span><span class="w"> </span><span class="n">-&gt;ZeroOrMore</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>This is gross. I don’t have any ideas on how to overcome this.<p>I’ve already briefly mentioned reversible patterns. At the beginning of this post I warned that I would use the terms view and pattern interchangeably. The line between them in strucjure is currently blurry but I think that the distinction should be that patterns must be reversible while views are allowed to destroy information.<p>Lastly, there will eventually be a need for some level of optimization. Given the extra flexibility in strucjure I don’t expect to ever be as fast as core.match but there is certainly lots of room for improvement on the current code. Originally, strucjure patterns were compiled into efficient clojure code but the implementation was complicated and it was difficult to rapidly iterate around it. I will probably return to compilation once the semantics and interface settle down.<p>For now, I’m going to dogfood strucjure in various projects while ruminating on improvements. I’m already very happy with how much leverage can be had from such a simple idea, especially if I can fix the problems above. Hopefully the examples here might get other people thinking along the same lines.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
