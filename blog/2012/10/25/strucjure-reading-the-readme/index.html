<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Strucjure: reading the readme</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Strucjure: reading the readme</h1></header><article role="main"><p>I just released <a href="https://github.com/jamii/strucjure">strucjure</a>, a clojure library and DSL for parsing and pattern matching based on <a href="http://lambda-the-ultimate.org/node/2477">Ometa</a>.<p>The readme on github has detailed descriptions of the syntax etc which I won’t repeat here. What I do want to do is run through a realistic example.<p>The readme has a large number of examples and I want to be sure that these are all correct and up to date. As part of the test-suite for strucjure I parse the <a href="https://raw.github.com/jamii/strucjure/master/README.md">readme source</a>, pull out all the examples and make sure that they all run correctly and return the expected output.<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">jamie@alien:~/strucjure$ </span>lein <span class="nb">test </span>strucjure.test
WARNING: newline already refers to: <span class="c">#'clojure.core/newline in namespace: strucjure.test, being replaced by: #'strucjure.test/newline</span>

lein <span class="nb">test </span>strucjure.test

Ran 1 tests containing 166 assertions.
0 failures, 0 errors.
</code></pre></div><p>The readme parser is pretty simple. Since I control both the parser and the readme source so it doesn’t need to be bullet-proof, just the simplest thing that will get the job done. Strucjure is very bare-bones at the moment though so we have to create a lot of simple views that really belong in a library somewhere.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">space</span><span class="w">
  </span><span class="sc">\s</span><span class="n">pace</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="nb">newline</span><span class="w">
  </span><span class="sc">\n</span><span class="n">ewline</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">not-newline</span><span class="w">
  </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="sc">\n</span><span class="n">ewline</span><span class="p">)</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">line</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">[])</span><span class="w"> </span><span class="c1">; have to consume at least one char
</span><span class="w">       </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more</span><span class="w"> </span><span class="n">not-newline</span><span class="p">)</span><span class="w"> </span><span class="n">?line</span><span class="p">)</span><span class="w">
               </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">optional</span><span class="w"> </span><span class="nb">newline</span><span class="p">)</span><span class="w"> </span><span class="n">?end</span><span class="p">)))</span><span class="w">
  </span><span class="n">line</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">indented-line</span><span class="w">
  </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">one-or-more</span><span class="w"> </span><span class="n">space</span><span class="p">)</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nf">line</span><span class="w"> </span><span class="n">?line</span><span class="p">))</span><span class="w">
  </span><span class="n">line</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>We want a tokeniser for various parts of the readme. We could write it like this:<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defnview</span><span class="w"> </span><span class="n">tokenise</span><span class="w"> </span><span class="p">[</span><span class="n">sep</span><span class="p">]</span><span class="w">
  </span><span class="c1">;; empty input
</span><span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="o">'</span><span class="p">(())</span><span class="w">
  </span><span class="c1">;; throw away separator, start a new token
</span><span class="w">  </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nf">sep</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">tokenise</span><span class="w"> </span><span class="n">sep</span><span class="p">)</span><span class="w"> </span><span class="n">?results</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w">
  </span><span class="c1">;; add the current char to the first token
</span><span class="w">  </span><span class="p">[</span><span class="n">?char</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">tokenise</span><span class="w"> </span><span class="n">sep</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">?result</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">?results</span><span class="p">])]</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="n">results</span><span class="p">))</span><span class="w">
</span></code></pre></div><p>Unfortunately in the current implementation of strucjure that recursive call goes on the stack, so this view will blow up on large inputs. For now we just have to implement this view by hand to get access to recur.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tokenise</span><span class="w"> </span><span class="p">[</span><span class="n">sep</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">view/-&gt;Raw</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="n">opts</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">elems</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">input</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">elems</span><span class="w"> </span><span class="n">elems</span><span class="w">
              </span><span class="n">token-acc</span><span class="w"> </span><span class="n">nil</span><span class="w">
              </span><span class="n">tokens-acc</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[[</span><span class="n">remaining</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">view/run</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="n">elems</span><span class="w"> </span><span class="n">opts</span><span class="p">)]</span><span class="w">
           </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="n">token-acc</span><span class="p">)</span><span class="w"> </span><span class="n">tokens-acc</span><span class="p">))</span><span class="w">
           </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[[</span><span class="n">elem</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">elems</span><span class="p">]</span><span class="w"> </span><span class="n">elems</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">elems</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="n">token-acc</span><span class="p">)</span><span class="w"> </span><span class="n">tokens-acc</span><span class="p">)</span><span class="w">
             </span><span class="p">[</span><span class="n">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="n">token-acc</span><span class="p">)</span><span class="w"> </span><span class="n">tokens-acc</span><span class="p">))])))))))</span><span class="w">
</span></code></pre></div><p>The rest of the parser makes more sense reading in reverse order. We start by splitting up the readme by code delimiters (triple backticks). This gives us chunks of alternating text and code, so we parse every other chunk as a block of code.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">code-delim</span><span class="w">
  </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="sc">\`</span><span class="w"> </span><span class="sc">\`</span><span class="w"> </span><span class="sc">\`</span><span class="p">)</span><span class="w">
  </span><span class="no">:code-delim</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">readme</span><span class="w">
  </span><span class="p">((</span><span class="nf">tokenise</span><span class="w"> </span><span class="n">code-delim</span><span class="p">)</span><span class="w"> </span><span class="n">?chunks</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">concat</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">code-block</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">take-nth</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">chunks</span><span class="p">)))))</span><span class="w">
</span></code></pre></div><p>We only want to look at code blocks that are marked as clojure code.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">code-block</span><span class="w">
  </span><span class="p">[</span><span class="sc">\c</span><span class="w"> </span><span class="sc">\l</span><span class="w"> </span><span class="sc">\o</span><span class="w"> </span><span class="sc">\j</span><span class="w"> </span><span class="sc">\u</span><span class="w"> </span><span class="sc">\r</span><span class="w"> </span><span class="sc">\e</span><span class="w"> </span><span class="sc">\n</span><span class="n">ewline</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nf">code-block-inner</span><span class="w"> </span><span class="n">?result</span><span class="p">)]</span><span class="w">
  </span><span class="n">result</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>A few of the code blocks don’t contain examples - we can detect these because they don’t start with a “user&gt; “ prompt. All the other blocks contain a list of examples separated by prompts.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">prompt</span><span class="w">
  </span><span class="p">(</span><span class="nf">prefix</span><span class="w"> </span><span class="sc">\u</span><span class="w"> </span><span class="sc">\s</span><span class="w"> </span><span class="sc">\e</span><span class="w"> </span><span class="sc">\r</span><span class="w"> </span><span class="sc">\&gt;</span><span class="w"> </span><span class="sc">\s</span><span class="n">pace</span><span class="p">)</span><span class="w">
  </span><span class="no">:prompt</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">code-block-inner</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">prompt</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
       </span><span class="p">((</span><span class="nf">tokenise</span><span class="w"> </span><span class="n">prompt</span><span class="p">)</span><span class="w"> </span><span class="n">?chunks</span><span class="p">))</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">example</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="n">chunks</span><span class="p">))</span><span class="w">

  </span><span class="n">_</span><span class="w"> </span><span class="c1">;; not a block of examples
</span><span class="w">  </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>An example consists of an input, which may be on multiple lines, zero or more lines of printed output and finally a result.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">example</span><span class="w">
  </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nf">line</span><span class="w"> </span><span class="n">?input-first</span><span class="p">)</span><span class="w">
   </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">zero-or-more-prefix</span><span class="w"> </span><span class="n">indented-line</span><span class="p">)</span><span class="w"> </span><span class="n">?input-rest</span><span class="p">)</span><span class="w">
   </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">one-or-more-prefix</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="n">?output-lines</span><span class="p">)]</span><span class="w">
  </span><span class="p">{</span><span class="no">:input</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w"> </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">line</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">input-first</span><span class="w"> </span><span class="n">input-rest</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="sc">\s</span><span class="n">pace</span><span class="p">)))</span><span class="w">
   </span><span class="no">:prints</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w"> </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">line</span><span class="w"> </span><span class="p">(</span><span class="nb">butlast</span><span class="w"> </span><span class="n">output-lines</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">line</span><span class="p">))))</span><span class="w">
   </span><span class="no">:result</span><span class="w"> </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="n">output-lines</span><span class="p">))})</span><span class="w">
</span></code></pre></div><p>The result is either a return value or an exception.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="c1">;; #"[a-zA-Z\.]"
</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">exception-chars</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="sc">\.</span><span class="w">
      </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="sc">\a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="sc">\z</span><span class="p">))</span><span class="w">
      </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="sc">\A</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="sc">\Z</span><span class="p">)))</span><span class="w">
  </span><span class="n">%</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">defview</span><span class="w"> </span><span class="n">result</span><span class="w">
  </span><span class="p">[</span><span class="sc">\E</span><span class="w"> </span><span class="sc">\x</span><span class="w"> </span><span class="sc">\c</span><span class="w"> </span><span class="sc">\e</span><span class="w"> </span><span class="sc">\p</span><span class="w"> </span><span class="sc">\t</span><span class="w"> </span><span class="sc">\i</span><span class="w"> </span><span class="sc">\o</span><span class="w"> </span><span class="sc">\n</span><span class="w"> </span><span class="sc">\I</span><span class="w"> </span><span class="sc">\n</span><span class="w"> </span><span class="sc">\f</span><span class="w"> </span><span class="sc">\o</span><span class="w"> </span><span class="sc">\s</span><span class="n">pace</span><span class="w">
   </span><span class="sc">\t</span><span class="w"> </span><span class="sc">\h</span><span class="w"> </span><span class="sc">\r</span><span class="w"> </span><span class="sc">\o</span><span class="w"> </span><span class="sc">\w</span><span class="w"> </span><span class="sc">\+</span><span class="w"> </span><span class="sc">\:</span><span class="w"> </span><span class="sc">\s</span><span class="n">pace</span><span class="w">
   </span><span class="sc">\#</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="nf">one-or-more</span><span class="w"> </span><span class="n">exception-chars</span><span class="p">)</span><span class="w"> </span><span class="n">?exception</span><span class="p">)</span><span class="w">
   </span><span class="o">&amp;</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="no">:throws</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">exception</span><span class="p">)]</span><span class="w">

  </span><span class="n">?data</span><span class="w">
  </span><span class="p">[</span><span class="no">:returns</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">data</span><span class="p">)])</span><span class="w">
</span></code></pre></div><p>That’s it - parsing done.<p>Now we just have to turn the results into unit tests. We have to be careful about comparing the results of the examples because they might contain closures, which look different every time.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">replace-fun</span><span class="w"> </span><span class="p">[</span><span class="n">unread-form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.replaceAll</span><span class="w"> </span><span class="n">unread-form</span><span class="w"> </span><span class="s">"#&lt;[^&gt;]*&gt;"</span><span class="w"> </span><span class="s">"#&lt;fun&gt;"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">prints-as</span><span class="w"> </span><span class="p">[</span><span class="n">string</span><span class="w"> </span><span class="n">form</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">replace-fun</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">replace-fun</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w"> </span><span class="p">(</span><span class="nb">pr</span><span class="w"> </span><span class="n">form</span><span class="p">)))))</span><span class="w">
</span></code></pre></div><p>Running the examples is a little tricky because some of them create bindings or classes that are used by later examples. We end up needing to eval the code at runtime.<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">example-test</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="n">prints</span><span class="w"> </span><span class="n">result</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">match</span><span class="w"> </span><span class="n">result</span><span class="w">
         </span><span class="p">[</span><span class="no">:returns</span><span class="w"> </span><span class="n">?value</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nf">do</span><span class="w">
           </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">prints-as</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">(</span><span class="nf">input</span><span class="p">)))</span><span class="w">
           </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">prints</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w"> </span><span class="p">(</span><span class="nf">input</span><span class="p">)))))</span><span class="w">

         </span><span class="p">[</span><span class="no">:throws</span><span class="w"> </span><span class="n">?exception</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nf">do</span><span class="w">
           </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nf">try+</span><span class="w"> </span><span class="p">(</span><span class="nf">input</span><span class="p">)</span><span class="w">
                     </span><span class="n">nil</span><span class="w">
                     </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">java.lang.Object</span><span class="w"> </span><span class="n">thrown</span><span class="w">
                       </span><span class="p">(</span><span class="nf">prints-as</span><span class="w"> </span><span class="n">exception</span><span class="w"> </span><span class="p">(</span><span class="nb">class</span><span class="w"> </span><span class="n">thrown</span><span class="p">)))))</span><span class="w">
           </span><span class="p">(</span><span class="nf">is</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">prints</span><span class="w"> </span><span class="p">(</span><span class="nb">with-out-str</span><span class="w">
                           </span><span class="p">(</span><span class="nf">try+</span><span class="w"> </span><span class="p">(</span><span class="nf">input</span><span class="p">)</span><span class="w">
                                 </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">java.lang.Object</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">nil</span><span class="p">))))))))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">insert-example-test</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">input</span><span class="w"> </span><span class="n">prints</span><span class="w"> </span><span class="n">result</span><span class="p">]}]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">example-test</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="o">'~</span><span class="ss">'strucjure</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nf">read-string</span><span class="w"> </span><span class="n">input</span><span class="p">))))</span><span class="w"> </span><span class="o">~</span><span class="n">prints</span><span class="w"> </span><span class="o">'~</span><span class="n">result</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">insert-readme-test</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="p">]</span><span class="w">
  </span><span class="o">`</span><span class="p">(</span><span class="nf">do</span><span class="w">
     </span><span class="o">~@</span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">example</span><span class="w"> </span><span class="p">(</span><span class="nf">run</span><span class="w"> </span><span class="n">readme</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">file</span><span class="p">))))]</span><span class="w">
         </span><span class="o">`</span><span class="p">(</span><span class="nf">insert-example-test</span><span class="w"> </span><span class="o">~</span><span class="n">example</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">readme-test</span><span class="w">
  </span><span class="p">(</span><span class="nf">insert-readme-test</span><span class="w"> </span><span class="s">"README.md"</span><span class="p">))</span><span class="w">
</span></code></pre></div><p>This is fun. Not only does strucjure parse its own syntax, it reads its own documentation!<p>Parts of this were a little painful. The next version of strucjure will definitely have improved string matching. I’m also looking at optimising/compiling views, as well as memoisation. Previous versions of strucjure supported both but were hard to maintain. For now I’m going to be moving on to using strucjure to build other useful DSLs.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
