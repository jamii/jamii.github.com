<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Binmaps: compressed bitmaps</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Binmaps: compressed bitmaps</h1></header><article role="main"><p>Lately I’ve been porting some code from c++. The code in question is a compressed bitmap used in <a href="http://libswift.org">swift</a> to track which parts of a download have already been retrieved. To reduce the memory usage the original uses lots of pointer tricks. Replicating these in ocaml is interesting.<p>Here is the basic idea. Conceptually a binmap is a tree of bitmaps. In a leaf at the bottom of the tree each bit in the bitmap represents one bit. In a leaf one layer above the bottom each bit in the bitmap represents two bits. In a leaf two layers above the bottom each bit in the bitmap represents four bits etc.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="n">t</span> <span class="p">=</span>
  <span class="p">{</span> <span class="n">layers</span> <span class="p">:</span> <span class="kt">int</span>
  <span class="p">;</span> <span class="n">tree</span> <span class="p">:</span> <span class="n">tree</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">tree</span> <span class="p">=</span>
  <span class="p">|</span> <span class="nc">Bitmap</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="p">|</span> <span class="nc">Branch</span> <span class="k">of</span> <span class="n">tree</span> <span class="p">*</span> <span class="n">tree</span>
</code></pre></div><p>Let’s pretend for simplicity our bitmaps are only 1 bit wide. Then the string 00000000 would be represented as:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="p">{</span> <span class="n">layers</span> <span class="p">=</span> <span class="mi">3</span>
<span class="p">;</span> <span class="n">tree</span> <span class="p">=</span> <span class="nc">Bitmap</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre></div><p>And the string 00001100 would be:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="p">{</span> <span class="n">layers</span> <span class="p">=</span> <span class="mi">3</span>
<span class="p">;</span> <span class="n">tree</span> <span class="p">=</span>
    <span class="nc">Branch</span>
      <span class="p">(</span><span class="nc">Bitmap</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nc">Branch</span>
        <span class="p">(</span><span class="nc">Bitmap</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nc">Bitmap</span> <span class="mi">0</span><span class="o">))</span> <span class="p">}</span>
</code></pre></div><p>The worst case for this data structure is the string 0101010101… In this case we use about 6.5x as much memory as needed by a plain bitmap (3 words for a Branch with two pointers, 4 words for a Bitmap with a pointer to a boxed Int32). The c++ version uses some simple tricks to reduce this overhead to just over 2x that of a plain bitmap. We can replicate these in ocaml by using a bigarray to simulate raw memory access.<p>Our data structure looks like this:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Array</span> <span class="p">=</span>
<span class="k">struct</span>
  <span class="k">include</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="nc">Array1</span>
  <span class="k">let</span> <span class="n">geti</span> <span class="kt">array</span> <span class="n">i</span> <span class="p">=</span> <span class="nn">Bitmap</span><span class="p">.</span><span class="n">to_int</span> <span class="p">(</span><span class="nn">Bigarray</span><span class="p">.</span><span class="nn">Array1</span><span class="p">.</span><span class="n">get</span> <span class="kt">array</span> <span class="n">i</span><span class="p">)</span>
  <span class="k">let</span> <span class="n">seti</span> <span class="kt">array</span> <span class="n">i</span> <span class="n">v</span> <span class="p">=</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="nn">Array1</span><span class="p">.</span><span class="n">set</span> <span class="kt">array</span> <span class="n">i</span> <span class="p">(</span><span class="nn">Bitmap</span><span class="p">.</span><span class="n">of_int</span> <span class="n">v</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">type</span> <span class="n">t</span> <span class="p">=</span>
    <span class="p">{</span> <span class="n">length</span> <span class="p">:</span> <span class="kt">int</span>
    <span class="p">;</span> <span class="n">layers</span> <span class="p">:</span> <span class="kt">int</span>
    <span class="p">;</span> <span class="k">mutable</span> <span class="kt">array</span> <span class="p">:</span> <span class="p">(</span><span class="nn">Bitmap</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="nn">Bitmap</span><span class="p">.</span><span class="n">bigarray_elt</span><span class="p">,</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="n">c_layout</span><span class="p">)</span> <span class="nn">Array</span><span class="p">.</span><span class="n">t</span>
    <span class="p">;</span> <span class="n">pointers</span> <span class="p">:</span> <span class="nn">Widemap</span><span class="p">.</span><span class="n">t</span>
    <span class="p">;</span> <span class="k">mutable</span> <span class="n">free</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">}</span>

<span class="k">type</span> <span class="n">node</span> <span class="p">=</span>
  <span class="p">|</span> <span class="nc">Bitmap</span> <span class="k">of</span> <span class="nn">Bitmap</span><span class="p">.</span><span class="n">t</span>
  <span class="p">|</span> <span class="nc">Pointer</span> <span class="k">of</span> <span class="kt">int</span>

<span class="k">let</span> <span class="n">get_node</span> <span class="n">binmap</span> <span class="n">node_addr</span> <span class="n">is_left</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">index</span> <span class="p">=</span> <span class="n">node_addr</span> <span class="o">+</span> <span class="p">(</span><span class="k">if</span> <span class="n">is_left</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">match</span> <span class="nn">Widemap</span><span class="p">.</span><span class="n">get</span> <span class="n">binmap</span><span class="p">.</span><span class="n">pointers</span> <span class="n">index</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">false</span> <span class="p">-&gt;</span> <span class="nc">Bitmap</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">get</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="n">index</span><span class="p">)</span>
  <span class="p">|</span> <span class="bp">true</span> <span class="p">-&gt;</span> <span class="nc">Pointer</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">geti</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="n">index</span><span class="p">)</span>

<span class="k">let</span> <span class="n">set_node</span> <span class="n">binmap</span> <span class="n">node_addr</span> <span class="n">is_left</span> <span class="n">node</span> <span class="p">=</span>
  <span class="k">let</span> <span class="n">index</span> <span class="p">=</span> <span class="n">node_addr</span> <span class="o">+</span> <span class="p">(</span><span class="k">if</span> <span class="n">is_left</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">node</span> <span class="k">with</span>
  <span class="p">|</span> <span class="nc">Bitmap</span> <span class="n">bitmap</span> <span class="p">-&gt;</span>
      <span class="nn">Widemap</span><span class="p">.</span><span class="n">set</span> <span class="n">binmap</span><span class="p">.</span><span class="n">pointers</span> <span class="n">index</span> <span class="bp">false</span><span class="p">;</span>
      <span class="nn">Array</span><span class="p">.</span><span class="n">set</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="n">index</span> <span class="n">bitmap</span>
  <span class="p">|</span> <span class="nc">Pointer</span> <span class="kt">int</span> <span class="p">-&gt;</span>
      <span class="nn">Widemap</span><span class="p">.</span><span class="n">set</span> <span class="n">binmap</span><span class="p">.</span><span class="n">pointers</span> <span class="n">index</span> <span class="bp">true</span><span class="p">;</span>
      <span class="nn">Array</span><span class="p">.</span><span class="n">seti</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="n">index</span> <span class="kt">int</span>
</code></pre></div><p>Each pair of cells in the array represents a branch. Leaves are hoisted into their parent branch, replacing the pointer. Widemap.t is an extensible bitmap which we use here to track whether a given cell in the array is a pointer or a bitmap. The length field is the number of bits represented by bitmap. The free field will be explained later.<p>Our previous example string 00001100 would now be represented like this:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="c">(*
  0 -&gt; Bitmap 0
  1 -&gt; Pointer 2
  2 -&gt; Bitmap 1
  3 -&gt; Bitmap 0
*)</span>

<span class="p">{</span> <span class="n">length</span> <span class="p">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">;</span> <span class="n">layers</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">;</span> <span class="kt">array</span> <span class="p">=</span> <span class="p">[|</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">|]</span>
<span class="p">;</span> <span class="n">pointers</span> <span class="p">=</span> <span class="nn">Widemap</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"0100"</span>
<span class="p">;</span> <span class="n">free</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre></div><p>When the bitmap is changed we may have to add or delete pairs eg if the above example changed to 00001111 it would be represented as:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="c">(*
  0 -&gt; Bitmap 0
  1 -&gt; Bitmap 1
  2 -&gt; ?
  3 -&gt; ?
*)</span>
</code></pre></div><p>We can grow and shrink the array as necessary, but since deleted pairs won’t necessarily be at the end of the used space the bigarray will become fragmented. To avoid wasting space we can write a linked list into the empty pairs to keep track of free space. 0 is always the root of the tree so we can use it as a list terminator. The free field marks the start of the list.<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">del_pair</span> <span class="n">binmap</span> <span class="n">node_addr</span> <span class="p">=</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">seti</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="n">node_addr</span> <span class="n">binmap</span><span class="p">.</span><span class="n">free</span><span class="p">;</span>
  <span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="p">&lt;-</span> <span class="n">node_addr</span>

<span class="c">(* double the size of a full array and then initialise the freelist *)</span>
<span class="k">let</span> <span class="n">grow_array</span> <span class="n">binmap</span> <span class="p">=</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="p">=</span> <span class="mi">0</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">old_len</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">dim</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">old_len</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="p">=</span> <span class="mi">0</span><span class="o">);</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">old_len</span> <span class="o">&lt;=</span> <span class="n">max_int</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">new_len</span> <span class="p">=</span> <span class="n">min</span> <span class="n">max_int</span> <span class="p">(</span><span class="mi">2</span> <span class="p">*</span> <span class="n">old_len</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">new_len</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="p">=</span> <span class="mi">0</span><span class="o">);</span>
  <span class="k">let</span> <span class="kt">array</span> <span class="p">=</span> <span class="n">create_array</span> <span class="n">new_len</span> <span class="k">in</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">blit</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">sub</span> <span class="kt">array</span> <span class="mi">0</span> <span class="n">old_len</span><span class="o">);</span>
  <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="p">&lt;-</span> <span class="kt">array</span><span class="p">;</span>
  <span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="p">&lt;-</span> <span class="n">old_len</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="p">=</span> <span class="n">old_len</span> <span class="k">to</span> <span class="n">new_len</span><span class="p">-</span><span class="mi">4</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="p">=</span> <span class="mi">0</span>  <span class="k">then</span> <span class="nn">Array</span><span class="p">.</span><span class="n">seti</span> <span class="kt">array</span> <span class="n">i</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">seti</span> <span class="kt">array</span> <span class="p">(</span><span class="n">new_len</span><span class="p">-</span><span class="mi">2</span><span class="p">)</span> <span class="mi">0</span>

<span class="k">let</span> <span class="n">add_pair</span> <span class="n">binmap</span> <span class="n">node_left</span> <span class="n">node_right</span> <span class="p">=</span>
  <span class="p">(</span><span class="k">if</span> <span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="p">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">grow_array</span> <span class="n">binmap</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">node_addr</span> <span class="p">=</span> <span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">free_next</span> <span class="p">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">geti</span> <span class="n">binmap</span><span class="p">.</span><span class="kt">array</span> <span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="k">in</span>
  <span class="n">binmap</span><span class="p">.</span><span class="n">free</span> <span class="p">&lt;-</span> <span class="n">free_next</span><span class="p">;</span>
  <span class="n">set_node</span> <span class="n">binmap</span> <span class="n">node_addr</span> <span class="bp">true</span> <span class="n">node_left</span><span class="p">;</span>
  <span class="n">set_node</span> <span class="n">binmap</span> <span class="n">node_addr</span> <span class="bp">false</span> <span class="n">node_right</span><span class="p">;</span>
  <span class="n">node_addr</span>
</code></pre></div><p>I haven’t yet written any code to shrink the array but it should be fairly straightforward to recursively copy the tree into a new array and rewrite the pointers.<p>With the freelist our modified example now looks like this:<div class="language-ocaml highlighter-rouge"><pre class="highlight"><code><span class="p">{</span> <span class="n">length</span> <span class="p">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">;</span> <span class="n">layers</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">;</span> <span class="kt">array</span> <span class="p">=</span> <span class="p">[|</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">|]</span>
<span class="p">;</span> <span class="n">pointers</span> <span class="p">=</span> <span class="nn">Widemap</span><span class="p">.</span><span class="n">of_string</span> <span class="s2">"0100"</span>
<span class="p">;</span> <span class="n">free</span> <span class="p">=</span> <span class="mi">2</span> <span class="p">}</span>
</code></pre></div><p>With the representation sorted the rest of the code more or less writes itself.<p>The only difficulty lies in choosing the width of the bitmaps used. Using smaller bitmaps increases the granularity of the binmap allowing better compression by compacting more nodes. Using larger bitmaps increases the size of the pointers allowing larger bitmaps to be represented. I’ve written the binmap code to be width-agnostic; it can easily be made into a functor of the bitmap module.<p>The paper linked below suggests using a layered address scheme to expand the effective pointer size, where the first bit of the pointer is a flag indicating which layer the address is in. I would suggest rather than putting the flag in the pointer it would be simper to use information implicit in the structure of the tree eg is the current layer mod 8 = 0. Either way, this hugely increases the size of the address space at a the cost of a little extra complexity.<p>The original version is <a href="https://github.com/gritzko/swift/blob/master/doc/binmaps-alenex.pdf">here</a> and my version is <a href="https://github.com/jamii/binmap">here</a>. This is just an experiment so far, I certainly wouldn’t suggest using it without some serious testing.<p>Overall I’m not sure how useful this particular data structure is but this method of compacting tree-like types in ocaml is certainly interesting. I suspect it could be at least partially automated.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
