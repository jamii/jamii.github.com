<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Zero-copy deserialization in Julia</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Zero-copy deserialization in Julia</h1></header><article role="main"><p>While working with <a href="http://relational.ai/">RelationalAI</a> I wrote a library for zero-copy deserialization in Julia. Not super exciting in itself, but it nicely demonstrates the kinds of zero-overhead abstractions that are possible in Julia.<h2 id="the-problem">The problem</h2><p>Folks at RelationalAI want to build various complex on-disk data-structures, with these constraints:<ul><li><p>The system is typically bottle-necked on memory bandwidth already, so deserializing on-disk data-structures into a separate in-memory data-structure is unacceptable. They need to operate directly on mmap-ed memory.<li><p>The data-structures will be mmap-ed into multiple different processes. The virtual memory mapping won’t stay the same, so the data-structures have to use relative offsets instead of absolute pointers.<li><p>The data-structures are large and most use-cases typically only touch a small portion of each mmap-ed chunk, so converting all offsets to pointers in place at load time (aka <a href="https://en.wikipedia.org/wiki/Pointer_swizzling">pointer swizzling</a>) is too wasteful of memory bandwidth.</ul><p>Additionally, the query compiler reading these data-structures is written in Julia. We still could implement the data-structures in C, but then the query compiler wouldn’t be able to benefit from specializing on the types of the data-structures. In other words, there is a potential performance boost if we can do the whole thing in Julia.<p>Let’s even throw in some additional constraints:<ul><li><p>When debugging, we want to do bounds-checking so we get exceptions instead of segfaults.<li><p>When not debugging, we want to have minimal overhead vs writing the same code in C.</ul><h2 id="building-blocks">Building blocks</h2><p>Julia offers pointers:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Libc</span><span class="o">.</span><span class="n">malloc</span><span class="x">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">5</span><span class="x">)</span>
<span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x00000000019887a0</span>
</code></pre></div><p>Pointers are typed, but we can cast them to other types freely:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">convert</span><span class="x">(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Int64</span><span class="x">},</span> <span class="n">p</span><span class="x">)</span>
<span class="n">Ptr</span><span class="x">{</span><span class="kt">Int64</span><span class="x">}</span> <span class="nd">@0x00000000019887a0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_store!</span><span class="x">(</span><span class="n">p</span><span class="x">,</span> <span class="mi">42</span><span class="x">)</span>
<span class="n">Ptr</span><span class="x">{</span><span class="kt">Int64</span><span class="x">}</span> <span class="nd">@0x00000000019887a0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_load</span><span class="x">(</span><span class="n">p</span><span class="x">)</span>
<span class="mi">42</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_store!</span><span class="x">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="x">,</span> <span class="mi">0</span><span class="x">)</span>
<span class="n">Ptr</span><span class="x">{</span><span class="kt">Int64</span><span class="x">}</span> <span class="nd">@0x00000000019887a1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_load</span><span class="x">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="x">)</span>
<span class="mi">0</span>
</code></pre></div><p>And we can use any plain-old-data type, not just primitives:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">Foo</span>
         <span class="n">x</span><span class="o">::</span><span class="kt">Int64</span>
         <span class="n">y</span><span class="o">::</span><span class="kt">Float64</span>
         <span class="n">z</span><span class="o">::</span><span class="kt">Bool</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">convert</span><span class="x">(</span><span class="n">Ptr</span><span class="x">{</span><span class="n">Foo</span><span class="x">},</span> <span class="n">p</span><span class="x">)</span>
<span class="n">Ptr</span><span class="x">{</span><span class="n">Foo</span><span class="x">}</span> <span class="nd">@0x00000000019887a0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_store!</span><span class="x">(</span><span class="n">p</span><span class="x">,</span> <span class="n">Foo</span><span class="x">(</span><span class="mi">42</span><span class="x">,</span> <span class="mf">3.14</span><span class="x">,</span> <span class="n">false</span><span class="x">))</span>
<span class="n">Ptr</span><span class="x">{</span><span class="n">Foo</span><span class="x">}</span> <span class="nd">@0x00000000019887a0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_load</span><span class="x">(</span><span class="n">p</span><span class="x">)</span>
<span class="n">Foo</span><span class="x">(</span><span class="mi">42</span><span class="x">,</span> <span class="mf">3.14</span><span class="x">,</span> <span class="n">false</span><span class="x">)</span>
</code></pre></div><p>In <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Write-%22type-stable%22-functions-1">type-stable</a> code, these operations compile down to the corresponding llvm primitives, producing the same asm you would expect from C:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">p</span><span class="x">)</span>
         <span class="n">p</span> <span class="o">+=</span> <span class="nb">sizeof</span><span class="x">(</span><span class="kt">Int64</span><span class="x">)</span> <span class="c"># skip Foo.x</span>
         <span class="n">p</span> <span class="o">=</span> <span class="nb">convert</span><span class="x">(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Float64</span><span class="x">},</span> <span class="n">p</span><span class="x">)</span>
         <span class="n">unsafe_load</span><span class="x">(</span><span class="n">p</span><span class="x">)</span> <span class="c"># read Foo.y</span>
       <span class="k">end</span>
<span class="n">f</span> <span class="x">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span class="n">method</span><span class="x">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@code_native</span> <span class="n">f</span><span class="x">(</span><span class="n">p</span><span class="x">)</span>
	<span class="o">.</span><span class="n">text</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">f</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">11</span><span class="x">]:</span><span class="mi">5</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">11</span><span class="x">]:</span><span class="mi">2</span>
	<span class="n">vmovsd</span>	<span class="mi">8</span><span class="x">(</span><span class="o">%</span><span class="n">rdi</span><span class="x">),</span> <span class="o">%</span><span class="n">xmm0</span>          <span class="c"># xmm0 = mem[0],zero</span>
<span class="x">;}}</span>
	<span class="n">retq</span>
	<span class="n">nopw</span>	<span class="o">%</span><span class="n">cs</span><span class="x">:(</span><span class="o">%</span><span class="n">rax</span><span class="x">,</span><span class="o">%</span><span class="n">rax</span><span class="x">)</span>
<span class="x">;}</span>
</code></pre></div><p>But like C they are totally unsafe:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">unsafe_load</span><span class="x">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="o">^</span><span class="mi">32</span><span class="x">)</span>

<span class="n">signal</span> <span class="x">(</span><span class="mi">11</span><span class="x">):</span> <span class="n">Segmentation</span> <span class="n">fault</span>
</code></pre></div><p>And they require us to do all our offset calculation and pointer arithmetic by hand.<h2 id="blobs">Blobs</h2><p>The <a href="https://github.com/jamii/Blobs.jl/tree/c1c9061659b8480f7b7264a8cd1d4d0075e6bd44">Blobs</a> library just adds some structure on top of these building blocks, while still compiling down to efficient native code.<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">using</span> <span class="n">Pkg</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pkg</span><span class="o">.</span><span class="n">add</span><span class="x">(</span><span class="n">PackageSpec</span><span class="x">(</span><span class="n">url</span><span class="o">=</span><span class="s">"git@github.com:jamii/Blobs.jl.git"</span><span class="x">,</span> <span class="n">rev</span><span class="o">=</span><span class="s">"c1c906"</span><span class="x">))</span>
<span class="o">...</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">using</span> <span class="n">Blobs</span>

</code></pre></div><p>Blobs are created from raw pointers:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}(</span><span class="n">Libc</span><span class="o">.</span><span class="n">malloc</span><span class="x">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">5</span><span class="x">),</span> <span class="mi">2</span><span class="o">^</span><span class="mi">5</span><span class="x">)</span>
<span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="mi">32</span><span class="x">)</span>
</code></pre></div><p>There is some syntax sugar for load/store:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="x">[]</span> <span class="o">=</span> <span class="n">Foo</span><span class="x">(</span><span class="mi">42</span><span class="x">,</span> <span class="mf">3.14</span><span class="x">,</span> <span class="n">false</span><span class="x">)</span>
<span class="n">Foo</span><span class="x">(</span><span class="mi">42</span><span class="x">,</span> <span class="mf">3.14</span><span class="x">,</span> <span class="n">false</span><span class="x">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="x">[]</span>
<span class="n">Foo</span><span class="x">(</span><span class="mi">42</span><span class="x">,</span> <span class="mf">3.14</span><span class="x">,</span> <span class="n">false</span><span class="x">)</span>
</code></pre></div><p>And for the pointer arithmetic needed to read individual fields:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span>
<span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc8</span><span class="x">,</span> <span class="mi">32</span><span class="x">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span>
<span class="mh">0x0000000000000008</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="x">[]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="x">[]</span>
<span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span><span class="x">[]</span>
<span class="n">Foo</span><span class="x">(</span><span class="mi">42</span><span class="x">,</span> <span class="mf">1.0</span><span class="x">,</span> <span class="n">false</span><span class="x">)</span>
</code></pre></div><p>Dereferenceing is bounds-checked<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="x">(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="x">)[]</span>
<span class="n">ERROR</span><span class="x">:</span> <span class="n">BoundsError</span><span class="x">:</span> <span class="n">attempt</span> <span class="n">to</span> <span class="n">access</span> <span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdbf</span><span class="x">,</span> <span class="mi">32</span><span class="x">)</span>
<span class="n">Stacktrace</span><span class="x">:</span>
 <span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="n">boundscheck</span> <span class="n">at</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">47</span> <span class="x">[</span><span class="n">inlined</span><span class="x">]</span>
 <span class="x">[</span><span class="mi">2</span><span class="x">]</span> <span class="n">getindex</span><span class="x">(</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span> <span class="n">at</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">53</span>
 <span class="x">[</span><span class="mi">3</span><span class="x">]</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">scope</span> <span class="n">at</span> <span class="n">none</span><span class="x">:</span><span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="x">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="o">^</span><span class="mi">5</span><span class="x">)[]</span>
<span class="n">ERROR</span><span class="x">:</span> <span class="n">BoundsError</span><span class="x">:</span> <span class="n">attempt</span> <span class="n">to</span> <span class="n">access</span> <span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fde0</span><span class="x">,</span> <span class="mi">32</span><span class="x">)</span>
<span class="n">Stacktrace</span><span class="x">:</span>
 <span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="n">boundscheck</span> <span class="n">at</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">47</span> <span class="x">[</span><span class="n">inlined</span><span class="x">]</span>
 <span class="x">[</span><span class="mi">2</span><span class="x">]</span> <span class="n">getindex</span><span class="x">(</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span> <span class="n">at</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">53</span>
 <span class="x">[</span><span class="mi">3</span><span class="x">]</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">scope</span> <span class="n">at</span> <span class="n">none</span><span class="x">:</span><span class="mi">0</span>
</code></pre></div><p>Bounds-checking can be turned off, either locally with the <code class="highlighter-rouge">@inbounds</code> macro or globally by starting julia with <code class="highlighter-rouge">--check-bounds=no</code>. With bounds-checking disabled, the only overhead is a single extra <code class="highlighter-rouge">movq</code> to unpack the <code class="highlighter-rouge">Blob</code> struct.<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
         <span class="nd">@inbounds</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="x">[]</span>
       <span class="k">end</span>
<span class="n">f</span> <span class="x">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span class="n">method</span><span class="x">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@code_native</span> <span class="n">f</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
	<span class="o">.</span><span class="n">text</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">f</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">24</span><span class="x">]:</span><span class="mi">2</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getproperty</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">150</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getindex</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">91</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">macro</span> <span class="n">expansion</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">95</span>
<span class="x">;</span> <span class="n">Function</span> <span class="o">+</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">32</span>
<span class="x">;</span> <span class="n">Function</span> <span class="o">+</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">155</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">Type</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">24</span><span class="x">]:</span><span class="mi">2</span>
	<span class="n">movq</span>	<span class="mi">8</span><span class="x">(</span><span class="o">%</span><span class="n">rdi</span><span class="x">),</span> <span class="o">%</span><span class="n">rax</span>
<span class="x">;}}}}}}</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getindex</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">54</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">110</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">macro</span> <span class="n">expansion</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">113</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
	<span class="n">vmovsd</span>	<span class="mi">8</span><span class="x">(</span><span class="o">%</span><span class="n">rax</span><span class="x">),</span> <span class="o">%</span><span class="n">xmm0</span>          <span class="c"># xmm0 = mem[0],zero</span>
<span class="x">;}}}}}</span>
	<span class="n">retq</span>
	<span class="n">nopw</span>	<span class="x">(</span><span class="o">%</span><span class="n">rax</span><span class="x">,</span><span class="o">%</span><span class="n">rax</span><span class="x">)</span>
<span class="x">;}</span>
</code></pre></div><p>Even for nested structs:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">Bar</span>
           <span class="n">x</span><span class="o">::</span><span class="kt">Int64</span>
           <span class="n">foo</span><span class="o">::</span><span class="n">Foo</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">Quux</span>
           <span class="n">bar</span><span class="o">::</span><span class="n">Bar</span>
           <span class="n">y</span><span class="o">::</span><span class="kt">Int64</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="n">Quux</span><span class="x">}(</span><span class="n">b</span><span class="x">)</span>
<span class="n">Blob</span><span class="x">{</span><span class="n">Quux</span><span class="x">}(</span><span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="n">Ptr</span><span class="x">{</span><span class="kt">Nothing</span><span class="x">}</span> <span class="nd">@0x0000000003a2fdc0</span><span class="x">,</span> <span class="mi">32</span><span class="x">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> g</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
           <span class="nd">@inbounds</span> <span class="n">b</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span><span class="n">y</span><span class="x">[]</span>
       <span class="k">end</span>
<span class="n">g</span> <span class="x">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span class="n">method</span><span class="x">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@code_native</span> <span class="n">g</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
	<span class="o">.</span><span class="n">text</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">g</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">29</span><span class="x">]:</span><span class="mi">2</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getproperty</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">150</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getindex</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">91</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">macro</span> <span class="n">expansion</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">95</span>
<span class="x">;</span> <span class="n">Function</span> <span class="o">+</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">32</span>
<span class="x">;</span> <span class="n">Function</span> <span class="o">+</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">155</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">Type</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">29</span><span class="x">]:</span><span class="mi">2</span>
	<span class="n">movq</span>	<span class="mi">8</span><span class="x">(</span><span class="o">%</span><span class="n">rdi</span><span class="x">),</span> <span class="o">%</span><span class="n">rax</span>
<span class="x">;}}}}}}</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getindex</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">54</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">110</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">macro</span> <span class="n">expansion</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">113</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
	<span class="n">vmovsd</span>	<span class="mi">16</span><span class="x">(</span><span class="o">%</span><span class="n">rax</span><span class="x">),</span> <span class="o">%</span><span class="n">xmm0</span>         <span class="c"># xmm0 = mem[0],zero</span>
<span class="x">;}}}}}</span>
	<span class="n">retq</span>
	<span class="n">nopw</span>	<span class="x">(</span><span class="o">%</span><span class="n">rax</span><span class="x">,</span><span class="o">%</span><span class="n">rax</span><span class="x">)</span>
<span class="x">;}</span>
</code></pre></div><h2 id="how-it-works">How it works</h2><p>Let’s unpack the magic step by step.<p>We start with a simple function call<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
  <span class="nd">@inbounds</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="x">[]</span>
<span class="k">end</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}(</span><span class="n">b</span><span class="x">)</span>

<span class="n">f</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
</code></pre></div><p><code class="highlighter-rouge">.</code> and <code class="highlighter-rouge">[]</code> are just syntactic sugar for <code class="highlighter-rouge">Base.getproperty</code> and <code class="highlighter-rouge">Base.getindex</code> respectively:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">getproperty</span><span class="x">(</span><span class="n">b</span><span class="x">,</span> <span class="x">:</span><span class="n">y</span><span class="x">)</span>
        <span class="n">getindex</span><span class="x">(</span><span class="n">tmp1</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Although the function has no type declarations, Julia does just-in-time type-inference and specialization. To begin with, all it can figure out is the type of the argument <code class="highlighter-rouge">b</code>, so we have something like:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">getproperty</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">},</span> <span class="x">:</span><span class="n">y</span><span class="x">)</span>
        <span class="n">getindex</span><span class="x">(</span><span class="n">tmp1</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Since it knows the types of all the arguments to <code class="highlighter-rouge">getproperty</code> it can find the correct method:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nd">@inline</span> <span class="k">function</span><span class="nf"> Base</span><span class="o">.</span><span class="n">getproperty</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">},</span> <span class="n">k</span><span class="o">::</span><span class="n">Symbol</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">===</span> <span class="x">:</span><span class="n">x</span>
        <span class="n">Blob</span><span class="x">{</span><span class="kt">Int64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">8</span><span class="x">)</span>
    <span class="k">elseif</span> <span class="n">k</span> <span class="o">===</span> <span class="x">:</span><span class="n">y</span>
        <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
    <span class="k">elseif</span> <span class="n">k</span> <span class="o">===</span> <span class="x">:</span><span class="n">z</span>
        <span class="n">Blob</span><span class="x">{</span><span class="kt">Bool</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">24</span><span class="x">)</span>
    <span class="k">else</span>
        <span class="nb">error</span><span class="x">(</span><span class="s">"type Blob{Foo} has no field </span><span class="si">$</span><span class="s">k"</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>And after inlining <code class="highlighter-rouge">Base.getproperty</code> our function looks like this:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">begin</span>
            <span class="k">if</span> <span class="x">:</span><span class="n">y</span> <span class="o">===</span> <span class="x">:</span><span class="n">x</span>
                <span class="n">Blob</span><span class="x">{</span><span class="kt">Int64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">8</span><span class="x">)</span>
            <span class="k">elseif</span> <span class="x">:</span><span class="n">y</span> <span class="o">===</span> <span class="x">:</span><span class="n">y</span>
                <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
            <span class="k">elseif</span> <span class="x">:</span><span class="n">y</span> <span class="o">===</span> <span class="x">:</span><span class="n">z</span>
                <span class="n">Blob</span><span class="x">{</span><span class="kt">Bool</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">24</span><span class="x">)</span>
            <span class="k">else</span>
                <span class="nb">error</span><span class="x">(</span><span class="s">"type Blob{Foo} has no field </span><span class="si">$</span><span class="s">(:y)"</span><span class="x">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">getindex</span><span class="x">(</span><span class="n">tmp1</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Constant propagation has a field day with expressions like <code class="highlighter-rouge">if :y === :x</code>, leaving us with:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
        <span class="n">getindex</span><span class="x">(</span><span class="n">tmp1</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Type inference kicks in again, figuring out the obvious type of <code class="highlighter-rouge">tmp</code>:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
        <span class="n">getindex</span><span class="x">(</span><span class="n">tmp1</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">})</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Now it can find the correct method for <code class="highlighter-rouge">getindex</code>:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">Base</span><span class="o">.</span><span class="nd">@propagate_inbounds</span> <span class="k">function</span><span class="nf"> Base</span><span class="o">.</span><span class="n">getindex</span><span class="x">(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">T</span><span class="x">})</span> <span class="n">where</span> <span class="n">T</span>
    <span class="n">boundscheck</span><span class="x">(</span><span class="n">blob</span><span class="x">)</span>
    <span class="n">unsafe_load</span><span class="x">(</span><span class="n">blob</span><span class="x">)</span>
<span class="k">end</span>

<span class="n">Base</span><span class="o">.</span><span class="nd">@propagate_inbounds</span> <span class="k">function</span><span class="nf"> boundscheck</span><span class="x">(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">T</span><span class="x">})</span> <span class="n">where</span> <span class="n">T</span>
    <span class="nd">@boundscheck</span> <span class="n">begin</span>
        <span class="k">if</span> <span class="o">!</span><span class="x">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">getfield</span><span class="x">(</span><span class="n">blob</span><span class="x">,</span> <span class="x">:</span><span class="n">offset</span><span class="x">)</span> <span class="o">-</span> <span class="n">getfield</span><span class="x">(</span><span class="n">blob</span><span class="x">,</span> <span class="x">:</span><span class="n">base</span><span class="x">)</span> <span class="o">&lt;=</span> <span class="n">getfield</span><span class="x">(</span><span class="n">blob</span><span class="x">,</span> <span class="x">:</span><span class="n">limit</span><span class="x">)</span> <span class="o">-</span> <span class="n">self_size</span><span class="x">(</span><span class="n">T</span><span class="x">))</span>
            <span class="nb">throw</span><span class="x">(</span><span class="n">BoundsError</span><span class="x">(</span><span class="n">blob</span><span class="x">))</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>After inlining again we have:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
        <span class="nd">@boundscheck</span> <span class="n">begin</span>
            <span class="k">if</span> <span class="o">!</span><span class="x">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">getfield</span><span class="x">(</span><span class="n">blob</span><span class="x">,</span> <span class="x">:</span><span class="n">offset</span><span class="x">)</span> <span class="o">-</span> <span class="n">getfield</span><span class="x">(</span><span class="n">blob</span><span class="x">,</span> <span class="x">:</span><span class="n">base</span><span class="x">)</span> <span class="o">&lt;=</span> <span class="n">getfield</span><span class="x">(</span><span class="n">blob</span><span class="x">,</span> <span class="x">:</span><span class="n">limit</span><span class="x">)</span> <span class="o">-</span> <span class="n">self_size</span><span class="x">(</span><span class="n">T</span><span class="x">))</span>
                <span class="nb">throw</span><span class="x">(</span><span class="n">BoundsError</span><span class="x">(</span><span class="n">blob</span><span class="x">))</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">unsafe_load</span><span class="x">(</span><span class="n">blob</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Any <code class="highlighter-rouge">@boundscheck</code> that is inside an <code class="highlighter-rouge">@inbounds</code>, either lexically or after inlining through <code class="highlighter-rouge">@propagate_inbounds</code>, is removed.<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">})</span>
    <span class="nd">@inbounds</span> <span class="n">begin</span>
        <span class="n">tmp1</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}</span> <span class="o">=</span> <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">}</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
        <span class="n">unsafe_load</span><span class="x">(</span><span class="n">blob</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Since we know at compile time that <code class="highlighter-rouge">tmp1</code> has type <code class="highlighter-rouge">Blob{Float64}</code>, which is an immutable value-type, it will be stack allocated, leaving us with some fairly tight LLVM bitcode:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@code_llvm</span> <span class="n">f</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>

<span class="x">;</span> <span class="n">Function</span> <span class="n">f</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">REPL</span><span class="x">[</span><span class="mi">31</span><span class="x">]:</span><span class="mi">2</span>
<span class="n">define</span> <span class="n">double</span> <span class="nd">@julia_f_36819</span><span class="x">({</span> <span class="n">i64</span><span class="x">,</span> <span class="n">i64</span><span class="x">,</span> <span class="n">i64</span> <span class="x">}</span> <span class="n">addrspace</span><span class="x">(</span><span class="mi">11</span><span class="x">)</span><span class="o">*</span> <span class="n">nocapture</span> <span class="n">nonnull</span> <span class="n">readonly</span> <span class="n">dereferenceable</span><span class="x">(</span><span class="mi">24</span><span class="x">))</span> <span class="x">{</span>
<span class="n">top</span><span class="x">:</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getproperty</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">150</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getindex</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">91</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">macro</span> <span class="n">expansion</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">95</span>
<span class="x">;</span> <span class="n">Function</span> <span class="o">+</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">32</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="n">inbounds</span> <span class="x">{</span> <span class="n">i64</span><span class="x">,</span> <span class="n">i64</span><span class="x">,</span> <span class="n">i64</span> <span class="x">},</span> <span class="x">{</span> <span class="n">i64</span><span class="x">,</span> <span class="n">i64</span><span class="x">,</span> <span class="n">i64</span> <span class="x">}</span> <span class="n">addrspace</span><span class="x">(</span><span class="mi">11</span><span class="x">)</span><span class="o">*</span> <span class="o">%</span><span class="mi">0</span><span class="x">,</span> <span class="n">i64</span> <span class="mi">0</span><span class="x">,</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="x">;</span> <span class="n">Function</span> <span class="o">+</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">155</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">Type</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">boot</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">728</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">bitcast</span> <span class="n">i64</span> <span class="n">addrspace</span><span class="x">(</span><span class="mi">11</span><span class="x">)</span><span class="o">*</span> <span class="o">%</span><span class="mi">1</span> <span class="n">to</span> <span class="n">i8</span><span class="o">*</span> <span class="n">addrspace</span><span class="x">(</span><span class="mi">11</span><span class="x">)</span><span class="o">*</span>
  <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="nb">load</span> <span class="n">i8</span><span class="o">*</span><span class="x">,</span> <span class="n">i8</span><span class="o">*</span> <span class="n">addrspace</span><span class="x">(</span><span class="mi">11</span><span class="x">)</span><span class="o">*</span> <span class="o">%</span><span class="mi">2</span><span class="x">,</span> <span class="n">align</span> <span class="mi">8</span>
<span class="x">;}</span>
  <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">getelementptr</span> <span class="n">i8</span><span class="x">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="mi">3</span><span class="x">,</span> <span class="n">i64</span> <span class="mi">16</span>
<span class="x">;}}}}}</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">getindex</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">54</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">110</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">macro</span> <span class="n">expansion</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jamie</span><span class="o">/.</span><span class="n">julia</span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">Blobs</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">blob</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">113</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
<span class="x">;</span> <span class="n">Function</span> <span class="n">unsafe_load</span><span class="x">;</span> <span class="x">{</span>
<span class="x">;</span> <span class="n">Location</span><span class="x">:</span> <span class="n">pointer</span><span class="o">.</span><span class="n">jl</span><span class="x">:</span><span class="mi">105</span>
  <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="n">bitcast</span> <span class="n">i8</span><span class="o">*</span> <span class="o">%</span><span class="mi">4</span> <span class="n">to</span> <span class="n">double</span><span class="o">*</span>
  <span class="o">%</span><span class="mi">6</span> <span class="o">=</span> <span class="nb">load</span> <span class="n">double</span><span class="x">,</span> <span class="n">double</span><span class="o">*</span> <span class="o">%</span><span class="mi">5</span><span class="x">,</span> <span class="n">align</span> <span class="mi">1</span>
<span class="x">;}}}}}</span>
  <span class="n">ret</span> <span class="n">double</span> <span class="o">%</span><span class="mi">6</span>
<span class="x">}</span>
</code></pre></div><h2 id="generated-functions">Generated functions</h2><p>I glossed over one important step - where did this method of <code class="highlighter-rouge">Base.getproperty</code> come from?<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nd">@inline</span> <span class="k">function</span><span class="nf"> Base</span><span class="o">.</span><span class="n">getproperty</span><span class="x">(</span><span class="n">b</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">Foo</span><span class="x">},</span> <span class="n">k</span><span class="o">::</span><span class="n">Symbol</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">===</span> <span class="x">:</span><span class="n">x</span>
        <span class="n">Blob</span><span class="x">{</span><span class="kt">Int64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">8</span><span class="x">)</span>
    <span class="k">elseif</span> <span class="n">k</span> <span class="o">===</span> <span class="x">:</span><span class="n">y</span>
        <span class="n">Blob</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">16</span><span class="x">)</span>
    <span class="k">elseif</span> <span class="n">k</span> <span class="o">===</span> <span class="x">:</span><span class="n">z</span>
        <span class="n">Blob</span><span class="x">{</span><span class="kt">Bool</span><span class="x">}(</span><span class="n">blob</span> <span class="o">+</span> <span class="mi">24</span><span class="x">)</span>
    <span class="k">else</span>
        <span class="nb">error</span><span class="x">(</span><span class="s">"type Blob{Foo} has no field </span><span class="si">$</span><span class="s">k"</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Obviously, we don’t want to write this by hand.<p>We could do some metaprogramming trick where we register the types we want to use and this creates all the appropriate methods:<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> register_blob_type</span><span class="x">(</span><span class="n">T</span><span class="x">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">quote</span>
        <span class="k">function</span><span class="nf"> Base</span><span class="o">.</span><span class="n">getproperty</span><span class="x">(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="o">$</span><span class="n">T</span><span class="x">},</span> <span class="n">field</span><span class="o">::</span><span class="n">Symbol</span><span class="x">)</span>
           <span class="o">$</span><span class="x">(</span><span class="n">Expr</span><span class="x">(:</span><span class="n">meta</span><span class="x">,</span> <span class="x">:</span><span class="n">inline</span><span class="x">))</span>
           <span class="o">$</span><span class="x">(</span><span class="nd">@splice</span> <span class="x">(</span><span class="n">i</span><span class="x">,</span> <span class="n">fieldname</span><span class="x">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="x">(</span><span class="n">fieldnames</span><span class="x">(</span><span class="n">T</span><span class="x">))</span> <span class="n">quote</span>
               <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="o">$</span><span class="n">fieldname</span>
                   <span class="k">return</span> <span class="n">Blob</span><span class="x">{</span><span class="o">$</span><span class="x">(</span><span class="n">fieldtype</span><span class="x">(</span><span class="n">T</span><span class="x">,</span> <span class="n">i</span><span class="x">))}(</span><span class="n">blob</span> <span class="o">+</span> <span class="n">blob_offset</span><span class="x">(</span><span class="n">T</span><span class="x">,</span> <span class="o">$</span><span class="x">(</span><span class="n">Val</span><span class="x">{</span><span class="n">i</span><span class="x">})))</span>
               <span class="k">end</span>
           <span class="k">end</span><span class="x">)</span>
           <span class="nb">error</span><span class="x">(</span><span class="s">"type </span><span class="si">$</span><span class="s">T has no field </span><span class="si">$</span><span class="s">field"</span><span class="x">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">eval</span><span class="x">(</span><span class="n">code</span><span class="x">)</span>
<span class="k">end</span>

<span class="n">register_blob_type</span><span class="x">(</span><span class="n">Foo</span><span class="x">)</span>
</code></pre></div><p>But Julia offers us something nicer. Rather than registering types in advance, we can make a ‘generated’ function, one which hooks into Julia’s just-in-time specialization and decides what code to compile based on the types of it’s arguments.<div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nd">@generated</span> <span class="k">function</span><span class="nf"> Base</span><span class="o">.</span><span class="n">getproperty</span><span class="x">(</span><span class="n">blob</span><span class="o">::</span><span class="n">Blob</span><span class="x">{</span><span class="n">T</span><span class="x">},</span> <span class="n">field</span><span class="o">::</span><span class="n">Symbol</span><span class="x">)</span> <span class="n">where</span> <span class="n">T</span>
    <span class="n">quote</span>
        <span class="o">$</span><span class="x">(</span><span class="n">Expr</span><span class="x">(:</span><span class="n">meta</span><span class="x">,</span> <span class="x">:</span><span class="n">inline</span><span class="x">))</span>
        <span class="o">$</span><span class="x">(</span><span class="nd">@splice</span> <span class="x">(</span><span class="n">i</span><span class="x">,</span> <span class="n">fieldname</span><span class="x">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="x">(</span><span class="n">fieldnames</span><span class="x">(</span><span class="n">T</span><span class="x">))</span> <span class="n">quote</span>
            <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="o">$</span><span class="n">fieldname</span>
                <span class="k">return</span> <span class="n">Blob</span><span class="x">{</span><span class="o">$</span><span class="x">(</span><span class="n">fieldtype</span><span class="x">(</span><span class="n">T</span><span class="x">,</span> <span class="n">i</span><span class="x">))}(</span><span class="n">blob</span> <span class="o">+</span> <span class="n">blob_offset</span><span class="x">(</span><span class="n">T</span><span class="x">,</span> <span class="o">$</span><span class="x">(</span><span class="n">Val</span><span class="x">{</span><span class="n">i</span><span class="x">})))</span>
            <span class="k">end</span>
        <span class="k">end</span><span class="x">)</span>
        <span class="nb">error</span><span class="x">(</span><span class="s">"type </span><span class="si">$</span><span class="s">T has no field </span><span class="si">$</span><span class="s">field"</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>From the outside, generated functions behave just like a normal function. This allows seamlessly mixing metaprogrammed code generation into normal code, without changing the outward interface or requiring consumers of the library to pre-register types.<h2 id="and-the-rest">And the rest</h2><p>The rest of the library packs in custom memory layout by adding new methods to the layout functions (which is how nested Blobs are <a href="https://github.com/jamii/Blobs.jl/blob/c1c9061659b8480f7b7264a8cd1d4d0075e6bd44/src/blob.jl#L157-L172">converted to/from offsets on read/write</a>), implementations of <a href="https://github.com/jamii/Blobs.jl/blob/c1c9061659b8480f7b7264a8cd1d4d0075e6bd44/src/vector.jl">fixed size vectors</a> / <a href="https://github.com/jamii/Blobs.jl/blob/c1c9061659b8480f7b7264a8cd1d4d0075e6bd44/src/bit_vector.jl">bitvectors</a> / <a href="https://github.com/jamii/Blobs.jl/blob/c1c9061659b8480f7b7264a8cd1d4d0075e6bd44/src/string.jl">strings</a> and <a href="https://github.com/jamii/Blobs.jl/blob/c1c9061659b8480f7b7264a8cd1d4d0075e6bd44/src/layout.jl">helper functions for initialization of complex data-structures</a>. All with similarly minimal overhead vs C.<p>As with the examples here, most of the work is done by the combination of type inference, type specialization and generated functions, with occasional uses of forced inlining to guarantee constant propagation. Unlike, say, a tracing JIT, this is predictable and deterministic. With some experience, it’s easy to write this kind of code and predict what Julia will do with it, allowing libraries like Blobs to provide abstractions without runtime overhead.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
