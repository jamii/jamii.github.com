<!DOCTYPE html><html lang="en"><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Three months of Rust</title><meta name="author" content="Jamie Brandon" /><link rel="alternate" type="application/rss+xml" title="Scattered Thoughts - " href="/feed.xml" /><style> @import url("https://fonts.googleapis.com/css?family=Fira+Code:400,700|Fira+Sans:400,400i,700,700i&display=swap");progress,sub,sup{vertical-align:baseline}button,hr,input{overflow:visible}html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}figcaption,menu,article,aside,details,figure,footer,header,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=submit],[type=reset],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}code{background:#ffffff}.highlight{background:#ffffff}.highlight pre{background-color:#fff;font-size:16px}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#fdd}.highlight .gd .x{color:#000000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000000;background-color:#dfd}.highlight .gi .x{color:#000000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:bold}.highlight .kd{font-weight:bold}.highlight .kp{font-weight:bold}.highlight .kr{font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.highlight .lineno{color:rgba(0,0,0,0.3);padding:0 10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none}.lineno::-moz-selection{background-color:transparent}.lineno::selection{background-color:transparent}body{padding:32px;color:#333333;background-color:#ffffff;font-family:Fira Sans, serif}.container{max-width:45em;margin:0 auto;font-size:20px}body blockquote{border-left:2px solid #333333 !important}article{font-size:1em}h1,h2,h3{font-weight:800;font-family:Fira Sans, sans-serif}h1{text-align:center;font-size:2.0em}h2{text-align:center;font-size:1.2em;margin-top:4em}h3{text-align:center;font-size:1em}h4{text-align:center}a{text-decoration:underline;font-weight:normal}a,a:visited,a:hover,a:active{color:#0085a1}*{max-width:100%}pre,figure,.wp-caption{margin:0px -10px 20px -10px;padding:0px 10px 0px 10px}blockquote{margin:0;padding:0px 10px 0px 10px;border-radius:5px}p>img:only-child,p>a:only-child>img:only-child,.wp-caption img,figure img{display:block}img{margin-left:auto;margin-right:auto}.caption,.wp-caption-text,figcaption{font-size:0.9em;line-height:1.48em;font-style:italic}code,pre{white-space:pre;overflow:visible;font-family:Fira Code, monospace}ul,ol{padding:0}ul{padding-left:30px;list-style:disc}ol{padding-left:30px;list-style:decimal}.post-link{padding-bottom:10px;text-align:center}.post-link a{text-decoration:none;color:#333333}.post-link a:focus,.post-link a:hover{color:#0085a1}.post-link .post-title{margin:0;font-size:18px}nav{text-align:center}nav a{font-size:1.4em}nav a,nav a:visited{text-decoration:none;color:#333333}nav a:focus,nav a:hover{color:#0085a1}.menu ul{list-style:none;padding:0;margin:0}header{margin:2em 0 2em 0;text-align:center}header h1{margin:0}footer{margin-top:4em;text-align:center;font-style:italic}iframe{width:560px;height:315px;display:block;margin:0 auto;padding-top:1em}table{margin-left:auto;margin-right:auto;border-collapse:collapse}table,th,td{padding:0.5em;border:0.5px solid #333333}hr{width:7em;margin-top:3em;margin-bottom:3em;border:0;height:1px;background-image:linear-gradient(to right, transparent, rgba(0,0,0,0.75), transparent)}</style><nav> <a href="/"> JAMIE BRANDON </a></nav><div class="container"><header><h1>Three months of Rust</h1></header><article role="main"><p>I work on <a href="http://incidentalcomplexity.com/">Eve</a>, a functional-relational programming language and environment. Since the Eve editor has to run in a browser we built the first few versions entirely in javascript. This has been pretty painful, so a little over three months ago we started looking at other options.<p>The only hard requirements for the runtime are a) we need control over memory layout and b) we need to safely execute untrusted Eve code. Preemptive threads and the ability to compile to efficient javascript would also be valuable.<p>Javascript <em>can</em> support manual memory layout but provides very little help in getting it right. Native objects have some <a href="https://news.ycombinator.com/item?id=8793817">necessary limitations</a> and asm.js is impractical to write by hand.<p>C can run in the browser via Emscripten but the available evidence suggests that writing secure C is not a thing that mortals are good at.<p>Rust is an unknown. It provides control over memory layout, has a community with a strong focus on safety and <em>may</em> support Emscripten in the future. It also promises a minimum of <a href="http://www.urbandictionary.com/define.php?term=footgun&amp;defid=7493319">footguns</a>, which is an attractive feature after many months of javascript and ArrayBuffers. Our initial experiments were promising, so we decided that in the next version of Eve we would write the query planner and runtime in Rust.<p>(“You should look at language X!”. We did, and then we decided to use Rust. We can still be friends.)<p>There are a number of things that made this much less risky than it sounds. First, the query planner is on the way to being bootstrapped and the remaining runtime is only a few thousand lines of code. Most of the development time is spent experimenting with different language semantics and evaluation strategies, rather than building up a large codebase that would tie us to Rust. Second, we have two escape hatches if Rust doesn’t work out. We can use the FFI to gradually port components to C, or we can use the websocket interface to the editor to gradually port components to javascript.<p>So here is what I think after three months of working with Rust full-time. TLDR: mostly impressive, a few worrying quirks, probably the best option for us right now.<h2 id="community">Community</h2><p>The Rust community seems to be populated entirely by human beings. I have no idea how this was done. I suspect Graydon Hoare deserves a large share of the credit for leading by example but everyone I have interacted with in the community has been friendly and patient.<p>Despite my concerns over the size and complexity of the compiler and the LLVM toolchain, I haven’t encountered any compiler bugs and only a <a href="https://github.com/rust-lang/rust/issues/24557">single bug</a> in the standard library. The community’s attitude towards reliability and safety is by far the strongest point in favour of us continuing to use Rust.<h2 id="tooling">Tooling</h2><p>Compile times are brutal. For our 2400 loc it takes 20s for a dev build and 70s for a release build. Word is that compile time just hasn’t been a focus so far and will improve in future releases. Type checking occurs very early in that 20s so running <code class="highlighter-rouge">cargo build</code> in a loop gives reasonably fast feedback on type errors, but any time we want to add an extra print statement we pay the full price. Moving the Eve editor into Rust would simplify the overall architecture but the people writing the editor refuse to wait 20s for a page refresh.<p>Error messages are better than any other tool I have used. For most errors the compiler not only clearly explains the problem but also offers the correct solution. There is no secret sauce, it’s just the result of long hours from the compiler team and a culture of caring about usability.<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="n">src</span><span class="err">/</span><span class="n">relation</span><span class="py">.rs</span><span class="p">:</span><span class="mi">110</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span> <span class="mi">110</span><span class="p">:</span><span class="mi">38</span> <span class="n">error</span><span class="p">:</span> <span class="n">unresolved</span> <span class="n">name</span> <span class="err">`</span><span class="n">before_op</span><span class="err">`</span><span class="py">. Did</span> <span class="n">you</span> <span class="n">mean</span> <span class="err">`</span><span class="n">before_opt</span><span class="err">`?</span>
<span class="n">src</span><span class="err">/</span><span class="n">relation</span><span class="py">.rs</span><span class="p">:</span><span class="mi">110</span>                             <span class="n">before_op</span> <span class="o">=</span> <span class="n">befores</span><span class="nf">.next</span><span class="p">();</span>
</code></pre></div><div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="n">src</span><span class="err">/</span><span class="n">relation</span><span class="py">.rs</span><span class="p">:</span><span class="mi">121</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span> <span class="mi">121</span><span class="p">:</span><span class="mi">33</span> <span class="n">error</span><span class="p">:</span> <span class="n">attempted</span> <span class="n">to</span> <span class="n">take</span> <span class="n">value</span> <span class="n">of</span> <span class="n">method</span> <span class="err">`</span><span class="n">iter</span><span class="err">`</span> <span class="n">on</span> <span class="k">type</span> <span class="err">`</span><span class="nn">collections</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">collections</span><span class="p">::</span><span class="nn">string</span><span class="p">::</span><span class="nb">String</span><span class="o">&gt;</span><span class="err">`</span>
<span class="n">src</span><span class="err">/</span><span class="n">relation</span><span class="py">.rs</span><span class="p">:</span><span class="mi">121</span>         <span class="k">let</span> <span class="n">ix</span> <span class="o">=</span> <span class="k">self</span><span class="py">.names.iter</span><span class="nf">.position</span><span class="p">(|</span><span class="n">my_name</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">my_name</span><span class="p">[</span><span class="err">..</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                                                <span class="o">^~~~</span>
<span class="n">src</span><span class="err">/</span><span class="n">relation</span><span class="py">.rs</span><span class="p">:</span><span class="mi">121</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span> <span class="mi">121</span><span class="p">:</span><span class="mi">33</span> <span class="n">help</span><span class="p">:</span> <span class="n">maybe</span> <span class="n">a</span> <span class="err">`</span><span class="p">()</span><span class="err">`</span> <span class="n">to</span> <span class="n">call</span> <span class="n">it</span> <span class="n">is</span> <span class="n">missing</span><span class="err">?</span> <span class="n">If</span> <span class="n">not</span><span class="p">,</span> <span class="n">try</span> <span class="n">an</span> <span class="n">anonymous</span> <span class="n">function</span>
</code></pre></div><div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="n">src</span><span class="err">/</span><span class="n">value</span><span class="py">.rs</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span> <span class="mi">14</span><span class="p">:</span><span class="mi">20</span> <span class="n">error</span><span class="p">:</span> <span class="n">cannot</span> <span class="k">move</span> <span class="n">out</span> <span class="n">of</span> <span class="n">borrowed</span> <span class="n">content</span>
<span class="n">src</span><span class="err">/</span><span class="n">value</span><span class="py">.rs</span><span class="p">:</span><span class="mi">14</span>         <span class="k">match</span> <span class="o">*</span><span class="k">self</span> <span class="p">{</span>
                              <span class="o">^~~~~</span>
<span class="n">src</span><span class="err">/</span><span class="n">value</span><span class="py">.rs</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span> <span class="mi">17</span><span class="p">:</span><span class="mi">33</span> <span class="n">note</span><span class="p">:</span> <span class="n">attempting</span> <span class="n">to</span> <span class="k">move</span> <span class="n">value</span> <span class="n">to</span> <span class="n">here</span>
<span class="n">src</span><span class="err">/</span><span class="n">value</span><span class="py">.rs</span><span class="p">:</span><span class="mi">17</span>             <span class="nn">Value</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">string</span><span class="nf">.fmt</span><span class="p">(</span><span class="n">formatter</span><span class="p">),</span>
                                          <span class="o">^~~~~~</span>
<span class="n">src</span><span class="err">/</span><span class="n">value</span><span class="py">.rs</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span> <span class="mi">17</span><span class="p">:</span><span class="mi">33</span> <span class="n">help</span><span class="p">:</span> <span class="n">to</span> <span class="n">prevent</span> <span class="n">the</span> <span class="k">move</span><span class="p">,</span> <span class="k">use</span> <span class="err">`</span><span class="k">ref</span> <span class="n">string</span><span class="err">`</span> <span class="n">or</span> <span class="err">`</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">string</span><span class="err">`</span> <span class="n">to</span> <span class="n">capture</span> <span class="n">value</span> <span class="n">by</span> <span class="n">reference</span>
</code></pre></div><p>Cargo is solid. Building projects, versioning dependencies and running tests/benchmarks are all easy. I would like to see <code class="highlighter-rouge">cargo bench</code> produce comparison graphs (like <a href="https://github.com/garybernhardt/readygo">readygo</a>). I’m also looking forward to <a href="https://github.com/nrc/rustfmt">rustfmt</a> since most editors currently do a pretty poor job of auto-indenting.<p>Javascript profilers tend to tell me that the Eve runtime spends 100% of its time in <code class="highlighter-rouge">main</code> and calls no other functions. With Rust I get to use valgrind and perf which actually return useful information.<p>Debugging is less exciting - both GDB and LLDB work and there is a <a href="https://michaelwoerister.github.io/2015/03/27/rust-xxdb.html">macros package</a> that makes them more useful but the Chrome debugger is still far more useable (when it doesn’t crash).<h2 id="ownership">Ownership</h2><p>One of the unique features of Rust is that the type system tracks ownership of data. Shared mutability is the root of many bugs and vulnerabilities, especially in concurrent environments. Functional languages address this by removing or strictly controlling mutability. Rust addresses this by tracking and controlling sharing. See the <a href="https://doc.rust-lang.org/book/ownership.html">documentation</a> for the gory details.<p>Most code I write now compiles without error. Most errors I see are clearly mistakes on my part and are easy to fix. About once a week, I hit an error that causes some headscratching. In most case I fume for a while before realising that I was trying to blow my foot off.<div class="highlighter-rouge"><pre class="highlight"><code>src/view.rs:205:70: 205:81 error: `outer_items` does not live long enough
src/view.rs:205                     output_pairs.push((&amp;aggregate.outer.fields[..], &amp;outer_items[..]));

                                                                                     ^~~~~~~~~~~
note: in expansion of for loop expansion
src/view.rs:172:17: 212:18 note: expansion site
src/view.rs:203:47: 212:18 note: reference must be valid for the block suffix following statement 3 at 203:46...
src/view.rs:203                         ).collect::&lt;Vec&lt;_&gt;&gt;();
src/view.rs:204                     let outer_items = vec![outer_values];
src/view.rs:205                     output_pairs.push((&amp;aggregate.outer.fields[..], &amp;outer_items[..]));
src/view.rs:206                     if aggregate.selects_inner {
src/view.rs:207                         output_pairs.push((&amp;aggregate.inner.fields[..], group))
src/view.rs:208                     }
                ...
src/view.rs:204:58: 212:18 note: ...but borrowed value is only valid for the block suffix following statement 4 at 204:57
src/view.rs:204                     let outer_items = vec![outer_values];
src/view.rs:205                     output_pairs.push((&amp;aggregate.outer.fields[..], &amp;outer_items[..]));
src/view.rs:206                     if aggregate.selects_inner {
src/view.rs:207                         output_pairs.push((&amp;aggregate.inner.fields[..], group))
src/view.rs:208                     }
src/view.rs:209                     let mut tuples = Vec::with_capacity(output_pairs.len());
</code></pre></div><p>It took me a while to realise that this error is trying to tell me is that <code class="highlighter-rouge">output_pairs</code> is declared one line before <code class="highlighter-rouge">outer_items</code>. Declarations for a block are freed in reverse order, so <code class="highlighter-rouge">outer_items</code> will be freed first and there will be a dangling pointer when <code class="highlighter-rouge">output_pairs</code> is freed. All I have to do to fix it is declare <code class="highlighter-rouge">output_pairs</code> after <code class="highlighter-rouge">outer_items</code>.<p>Most of my confusion looks like this. There is some pattern that I didn’t think about before and now that I understand it I won’t struggle with that kind of error again. As the language matures I expect that these patterns will be collected and documented.<p>There are also some patterns that the borrow checker can’t understand (or, more accurately, there is no matching pattern in the standard library). This is a heavily simplified version of a common pattern in the query engine:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">step</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="p">[</span><span class="nb">String</span><span class="p">],</span> <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">table</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">results</span><span class="nf">.push</span><span class="p">(</span><span class="n">state</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="nf">.to_owned</span><span class="p">())</span><span class="nf">.collect</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">table</span><span class="nf">.len</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c">// some complicated condition</span>
        <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
        <span class="n">state</span><span class="nf">.pop</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"some new thing"</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
        <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
        <span class="n">state</span><span class="nf">.pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">let</span> <span class="n">table</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"a"</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="s">"b"</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="s">"c"</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="s">"d"</span><span class="nf">.to_owned</span><span class="p">()];</span>
   <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
   <span class="k">let</span> <span class="k">mut</span> <span class="n">results</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
   <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="err">..</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">results</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Which produces this error:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="mi">10</span><span class="p">:</span><span class="mi">22</span> <span class="n">error</span><span class="p">:</span> <span class="err">`</span><span class="n">s</span><span class="err">`</span> <span class="n">does</span> <span class="n">not</span> <span class="n">live</span> <span class="n">long</span> <span class="n">enough</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">10</span>         <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
                              <span class="o">^</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">95</span><span class="p">:</span> <span class="mi">14</span><span class="p">:</span><span class="mi">2</span> <span class="n">note</span><span class="p">:</span> <span class="n">reference</span> <span class="n">must</span> <span class="n">be</span> <span class="n">valid</span> <span class="k">for</span> <span class="n">the</span> <span class="n">lifetime</span> <span class="err">'</span><span class="n">a</span> <span class="k">as</span> <span class="n">defined</span> <span class="n">on</span> <span class="n">the</span> <span class="n">block</span> <span class="n">at</span> <span class="mi">1</span><span class="p">:</span><span class="mi">94</span><span class="err">...</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">1</span> <span class="k">fn</span> <span class="n">step</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="p">[</span><span class="nb">String</span><span class="p">],</span> <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">2</span>     <span class="k">if</span> <span class="n">table</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">3</span>         <span class="n">results</span><span class="nf">.push</span><span class="p">(</span><span class="n">state</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="nf">.to_owned</span><span class="p">())</span><span class="nf">.collect</span><span class="p">());</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">4</span>     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">table</span><span class="nf">.len</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c">// some complicated condition</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">5</span>         <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">6</span>         <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
         <span class="err">...</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">40</span><span class="p">:</span> <span class="mi">13</span><span class="p">:</span><span class="mi">6</span> <span class="n">note</span><span class="p">:</span> <span class="err">..</span><span class="py">.but</span> <span class="n">borrowed</span> <span class="n">value</span> <span class="n">is</span> <span class="n">only</span> <span class="n">valid</span> <span class="k">for</span> <span class="n">the</span> <span class="n">block</span> <span class="n">suffix</span> <span class="n">following</span> <span class="n">statement</span> <span class="mi">0</span> <span class="n">at</span> <span class="mi">9</span><span class="p">:</span><span class="mi">39</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">9</span>         <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"some new thing"</span><span class="nf">.to_owned</span><span class="p">();</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">10</span>         <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">11</span>         <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">12</span>         <span class="n">state</span><span class="nf">.pop</span><span class="p">();</span>
<span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">13</span>     <span class="p">}</span>
</code></pre></div><p>The core problem is that I’m pushing a value <code class="highlighter-rouge">s</code> into a vector which lives longer than <code class="highlighter-rouge">s</code>. The borrow checker isn’t capable of proving that I remove the value again before it is freed. I could build a wrapper around the vector library that understands this pattern, or I could just promise the borrow checker that I know what I’m doing:<div class="language-rust highlighter-rouge"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"some new thing"</span><span class="nf">.to_owned</span><span class="p">();</span>
    <span class="c">// promise the borrow checker that we will pop s before we exit this scope</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">transmute</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="nb">String</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
    <span class="n">state</span><span class="nf">.pop</span><span class="p">();</span>
</code></pre></div><p>I like this pragmatic approach to safety. When the type-system understands what I’m doing I get the full benefit. When it doesn’t I can escape and do my own reasoning. If a particular pattern appears frequently I can put that reasoning into a library (like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> or <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>) and expose a safe interface that the type system understands. It feels like having an extensible type system that can learn to understand the way each project manages memory.<p>EDIT <a href="http://www.reddit.com/r/rust/comments/38ljzu/three_months_of_rust/crw6f9m">quxxy</a> suggested a better solution, using the copy-on-write type to allow the vec to own some of the strings and borrow the others:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Cow</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">step</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="p">[</span><span class="nb">String</span><span class="p">],</span> <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Cow</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">results</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">table</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">results</span><span class="nf">.push</span><span class="p">(</span><span class="n">state</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="p">(</span><span class="o">**</span><span class="n">s</span><span class="p">)</span><span class="nf">.to_owned</span><span class="p">())</span><span class="nf">.collect</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">table</span><span class="nf">.len</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c">// some complicated condition</span>
        <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Cow</span><span class="p">::</span><span class="nf">Borrowed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="err">..</span><span class="p">]));</span>
        <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
        <span class="n">state</span><span class="nf">.pop</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"some new thing"</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="n">state</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="err">..</span><span class="p">],</span> <span class="n">state</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
        <span class="n">state</span><span class="nf">.pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="control">Control</h2><p>Rust has <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data-types</a> that layout data consecutively. Pointers are opt-in. Gaining a similar level of control in javascript <em>is</em> possible but it requires some mightily unpleasant gymnastics. Rust feels like a high-level language most of the time but manages to do it without vomiting all over the cache.<p>Rust doesn’t help at all with <a href="http://bitsquid.blogspot.com/2010/02/blob-and-i.html">blobs</a> though. They have to be handled with ‘unsafe’ code which subverts the normal Rust guarantees. The unsafe code could be wrapped in a library (like <a href="https://github.com/frankmcsherry/columnar">columnar</a>) to ensure that clients use it correctly but the library code itself will still need very careful review. And speaking of review…<h2 id="unsafe">Unsafe</h2><p>There is a very recent effort to define <a href="http://cglab.ca/~abeinges/blah/rust-unsafe-intro/">exactly what unsafe code has to do</a> to not ruin all the guarantees that Rust works so hard to provide. The list of <a href="https://doc.rust-lang.org/reference.html#behavior-considered-undefined">undefined behaviour</a> is long and scary. It looks like consensus and documentation is on the way but until then … here be dragons.<h2 id="zero-cost">Zero cost</h2><p>Rust provides a lot of high-level abstractions which LLVM then optimises away. For example, large chains of iterator functions usually optimise into imperative loops. And the word ‘usually’ is what makes me worry. So far Rust has behaved but I have been bitten badly by other ‘sufficiently smart’ compilers.<p>Modern machines are a huge pile of opaque and unreliable heuristics and the current trend is to add more and more layers on top. The vast majority of systems are built this way and it is by all accounts a successful strategy. That doesn’t mean I have to like it.<h2 id="syntax">Syntax</h2><p>Doesn’t matter that much. I got used to it.<h2 id="namespaces">Namespaces</h2><p>There are effectively three kinds of namespaces.<p>Modules behave like most static languages - you can call functions using their full path or you can import them under a short name eg<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="p">::</span><span class="nn">my</span><span class="p">::</span><span class="nn">global</span><span class="p">::</span><span class="nn">namespace</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>

<span class="k">use</span> <span class="nn">my</span><span class="p">::</span><span class="nn">global</span><span class="p">::</span><span class="n">namespace</span><span class="p">;</span>
<span class="nn">namespace</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>

<span class="k">use</span> <span class="nn">my</span><span class="p">::</span><span class="nn">global</span><span class="p">::</span><span class="nn">namespace</span><span class="p">::</span><span class="n">foo</span><span class="p">;</span>
<span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
</code></pre></div><p>There is some funkiness around how modules are structured and how they are scoped relative to each other that I haven’t taken the trouble to understand. I only need one level of namespaces.<p>Types can also be namespaces. You can add a method to a type and access it either through the type or through the dot syntax.<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Bar</span><span class="p">{</span>
  <span class="err">...</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Bar</span><span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span><span class="err">...</span><span class="p">}</span>
<span class="p">}</span>

<span class="nn">Bar</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="n">bar</span><span class="nf">.foo</span><span class="p">();</span>
</code></pre></div><p>Lastly, traits can attach methods to types. To prevent collisions, the methods are namespaced by the trait.<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Bar</span> <span class="p">{</span>
  <span class="err">...</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Foo</span><span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Bar</span> <span class="p">{</span><span class="err">...</span><span class="p">}</span>

<span class="nn">Foo</span><span class="p">::</span><span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>

<span class="k">use</span> <span class="n">Foo</span><span class="p">;</span> <span class="c">// import foo for the dot syntax</span>
<span class="n">bar</span><span class="nf">.foo</span><span class="p">();</span>
</code></pre></div><p>Not unreasonable so far. It can sometimes be hard to track down where a particular method came from but the dispatch is at least direct. No inheritance or prototype chains to deal with.<h2 id="traits">Traits</h2><p>Haskell suffers from an excess of magic. Typeclass methods can dispatch on the type of any argument (or on the return type!) but the types are usually inferred. Reading haskell code that overuses typeclasses may require running the inference algorithms in your head, which is difficult and error-prone. This can also lead to bugs when an edit in one place changes a type, causing a different instance to be silently selected somewhere else (Don Stewart warned against this in his <a href="http://code.haskell.org/~dons/talks/padl-keynote-2012-01-24.pdf">PADL keynote</a>).<p>OCaml leans entirely the other way. Code is very readable and maintainable because all the information needed to follow the dispatch is written down explicitly. On the other hand, printing a simple data-structure can require chaining together multiple lines of functors to get to the correct function.<p>Rust has very similar capabilities to haskell but (so far) abuses them less often. There are only a few cases so far where I felt lost in types - <a href="http://cyderize.github.io/rust-websocket/doc/websocket/index.html">rust-websocket</a> being the biggest offender.<p>EDIT The section here on constraints was completely wrong and has been removed - see the <a href="https://news.ycombinator.com/item?id=9664017">discussion</a> that corrected me.<h2 id="auto-deref">Auto-deref</h2><p>Method calls are not as simple as they look at first. Suppose we have:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">x</span><span class="nf">.foo</span><span class="p">()</span>
</code></pre></div><p>If <code class="highlighter-rouge">x</code> implements <code class="highlighter-rouge">Foo</code> then life is simple. If <code class="highlighter-rouge">x</code> doesn’t implement <code class="highlighter-rouge">Foo</code> but does implement <code class="highlighter-rouge">Deref</code> then the compiler will change the call to <code class="highlighter-rouge">x.deref().foo()</code>. This continues with <code class="highlighter-rouge">x.deref().deref().foo()</code> and so on until compiler finds a type that doesn’t implement <code class="highlighter-rouge">Deref</code> or a type that does implement <code class="highlighter-rouge">Foo</code>. This is great ergonomically - it means you can call methods on a smart pointer as it were the pointed-at object. But it only works on the self argument - other arguments have to be manually deref-ed.<p>Similarly, if a method is declared to take <code class="highlighter-rouge">&amp;self</code> or <code class="highlighter-rouge">&amp;mut self</code> the compiler will insert the appropriate borrow before making the call. <code class="highlighter-rouge">foo.bar()</code> could desugar to <code class="highlighter-rouge">bar(foo)</code> or <code class="highlighter-rouge">bar(&amp;foo)</code> or <code class="highlighter-rouge">bar(&amp;mut foo)</code> depending on the type of <code class="highlighter-rouge">bar</code>.<p>Auto-deref and auto-borrow can interact unpleasantly with traits and inference. Here is a real example that totally confused me:<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">:</span>
<span class="nf">print_type_of</span><span class="p">(</span><span class="n">x</span><span class="nf">.to_owned</span><span class="p">());</span> <span class="c">// prints String</span>

<span class="k">let</span> <span class="n">xs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"foo"</span><span class="p">];</span>
<span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="n">xs</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">print_type_of</span><span class="p">(</span><span class="n">x</span><span class="nf">.to_owned</span><span class="p">());</span> <span class="c">// prints String</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">xs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"foo"</span><span class="p">];</span>
<span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="n">xs</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">print_type_of</span><span class="p">(</span><span class="n">x</span><span class="nf">.to_owned</span><span class="p">());</span> <span class="c">// prints &amp;str</span>
<span class="p">)</span>
</code></pre></div><p>What’s going on? The standard library has the following implementations:<div class="highlighter-rouge"><pre class="highlight"><code>impl ToOwned for str {
  type Owned = String
  ...
}

impl&lt;T&gt; ToOwned for T where T: Clone {
  type Owned = T
  ...
}

impl Clone for &amp;T
</code></pre></div><p>The type of <code class="highlighter-rouge">x</code> in the first two examples is <code class="highlighter-rouge">&amp;str</code> which auto-derefs to <code class="highlighter-rouge">str</code> and gets <code class="highlighter-rouge">Owned = String</code>. The type of <code class="highlighter-rouge">x</code> in the third example is <code class="highlighter-rouge">&amp;&amp;str</code> (because iter borrows elements of the vec). <code class="highlighter-rouge">&amp;str</code> implements <code class="highlighter-rouge">Clone</code> so <code class="highlighter-rouge">&amp;&amp;str</code> implements <code class="highlighter-rouge">ToOwned</code> directly and does not auto-deref to <code class="highlighter-rouge">str</code>.<p>This is a risk for traits in general, but auto-deref exacerbates it by creating multiple types that might choose an instance. In this case it caused a type error but you can imagine cases where adding a new trait implementation silently changes the selected instance of a seemingly unrelated call in far away code. Very difficult for code review to catch.<p>A similar mistake can happen if both the dereferenced type and the pointer type implement a method with the same name, but it looks like the standard library authors are aware of this and have stopped implementing methods directly on pointer types.<h2 id="learning-curve">Learning curve</h2><p>The borrow checker was initially huge impediment to productivity but I reached the break-even point around the second month. Ownership and borrowing have become intuitive and I no longer have to contort designs around them.<p>Safety is an enormous productivity boon. I’ve checked in a total of 10k lines of Rust code and written many more experiments that didn’t make it to master, and in that time I haven’t had a single segfault, nor any bugs caused by accidental mutation, aliasing, type errors or null pointers. The vast majority of typing mistakes are also caught at compile time (the exceptions being interactions with dynamically typed Eve data).<p>Despite the restrictions of the type system, I am more productive in Rust than I am in either Javascript or Haskell. It manages somehow to hit a sweet spot between safety and ease of use.<p>By far, the feature I miss most is interactive development. The <a href="https://github.com/murarth/rusti">repl</a> is only a thin layer over the compiler - it’s equally slow and nukes all state between every eval. Adding interactivity to a language that wasn’t designed for it is generally unsatisfying so this is not something that it likely to be fixed.<h2 id="for-eve">For Eve</h2><p>One of the core values of Eve is radical simplicity, in the same vein as the <a href="http://www.vpri.org/pdf/tr2011004_steps11.pdf">STEPS</a> and <a href="http://boom.cs.berkeley.edu/">BOOM</a> projects. We have to make compromises if we want to ever ship, but sitting atop Rust, LLVM and possibly Emscripten feels like a pretty big compromise.<p>The complexity in Rust exists to create a general-purpose systems language with an array of features and zero-cost abstractions that are incredibly useful for building large projects. But we aren’t building a large project, by design, and we don’t <em>need</em> most of the features.<p>The only places where we absolutely need manual layout so far are for Eve data and indexes. Those are nicely self-contained - no pointers to the outside world - and have a well-defined life-cycle. I wonder how far we could get with an approach like <a href="http://terralang.org/">Terra</a>, writing the core data-structures and algorithms in some scary unsafe language and interact with them safely from a managed language. With a staged approach we could build just the safety mechanisms that we need and avoid carrying around the complexity of the rest. Javascript seems to have all the features needed to make this kind of approach work but it doesn’t have the tools needed to make it bearable. Creating one programming language is hard enough - we probably shouldn’t start on another.<p>Regardless, Rust is an incredible language in general. Even if we end up using something else for Eve, I can see myself using Rust for other projects where I care about performance, safety or reliability.</article><footer><div>Questions? Comments? Just want to chat?</div><div><a href="mailto:jamie@scattered-thoughts.net>jamie@scattered-thoughts.net">jamie@scattered-thoughts.net</a></div><br><p><a href="/feed.xml"><img src="/img/rss.png"></img></a></footer></div>
