<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ocaml | Scattered Thoughts]]></title>
  <link href="http://scattered-thoughts.net/blog/categories/ocaml/atom.xml" rel="self"/>
  <link href="http://scattered-thoughts.net/"/>
  <updated>2013-11-24T07:30:10+00:00</updated>
  <id>http://scattered-thoughts.net/</id>
  <author>
    <name><![CDATA[Jamie Brandon]]></name>
    <email><![CDATA[jamie@scattered-thoughts.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Binmaps: compressed bitmaps]]></title>
    <link href="http://scattered-thoughts.net/blog/2012/01/03/binmaps-compressed-bitmaps/"/>
    <updated>2012-01-03T06:16:00+00:00</updated>
    <id>http://scattered-thoughts.net/blog/2012/01/03/binmaps-compressed-bitmaps</id>
    <content type="html"><![CDATA[<p>Lately I&rsquo;ve been porting some code from c++. The code in question is a compressed bitmap used in <a href="http://libswift.org">swift</a> to track which parts of a download have already been retrieved. To reduce the memory usage the original uses lots of pointer tricks. Replicating these in ocaml is interesting.</p>

<!--more-->


<p>Here is the basic idea. Conceptually a binmap is a tree of bitmaps. In a leaf at the bottom of the tree each bit in the bitmap represents one bit. In a leaf one layer above the bottom each bit in the bitmap represents two bits. In a leaf two layers above the bottom each bit in the bitmap represents four bits etc.</p>

<p>``` ocaml
type t =
  { layers : int
  ; tree : tree }</p>

<p>type tree =
  | Bitmap of int
  | Branch of tree * tree
```</p>

<p>Let&rsquo;s pretend for simplicity our bitmaps are only 1 bit wide. Then the string 00000000 would be represented as:</p>

<p><code>ocaml
{ layers = 3
; tree = Bitmap 0 }
</code></p>

<p>And the string 00001100 would be:</p>

<p>``` ocaml
{ layers = 3
; tree =</p>

<pre><code>Branch
  (Bitmap 0)
  (Branch
    (Bitmap 1)
    (Bitmap 0)) }
</code></pre>

<p>```</p>

<p>The worst case for this data structure is the string 0101010101&hellip; In this case we use about 6.5x as much memory as needed by a plain bitmap (3 words for a Branch with two pointers, 4 words for a Bitmap with a pointer to a boxed Int32). The c++ version uses some simple tricks to reduce this overhead to just over 2x that of a plain bitmap. We can replicate these in ocaml by using a bigarray to simulate raw memory access.</p>

<p>Our data structure looks like this:</p>

<p>``` ocaml
module Array =
struct
  include Bigarray.Array1
  let geti array i = Bitmap.to_int (Bigarray.Array1.get array i)
  let seti array i v = Bigarray.Array1.set array i (Bitmap.of_int v)
end</p>

<p>type t =</p>

<pre><code>{ length : int
; layers : int
; mutable array : (Bitmap.t, Bitmap.bigarray_elt, Bigarray.c_layout) Array.t
; pointers : Widemap.t
; mutable free : int }
</code></pre>

<p>type node =
  | Bitmap of Bitmap.t
  | Pointer of int</p>

<p>let get_node binmap node_addr is_left =
  let index = node_addr + (if is_left then 0 else 1) in
  match Widemap.get binmap.pointers index with
  | false &ndash;> Bitmap (Array.get binmap.array index)
  | true &ndash;> Pointer (Array.geti binmap.array index)</p>

<p>let set_node binmap node_addr is_left node =
  let index = node_addr + (if is_left then 0 else 1) in
  match node with
  | Bitmap bitmap &ndash;></p>

<pre><code>  Widemap.set binmap.pointers index false;
  Array.set binmap.array index bitmap
</code></pre>

<p>  | Pointer int &ndash;></p>

<pre><code>  Widemap.set binmap.pointers index true;
  Array.seti binmap.array index int
</code></pre>

<p>```</p>

<p>Each pair of cells in the array represents a branch. Leaves are hoisted into their parent branch, replacing the pointer. Widemap.t is an extensible bitmap which we use here to track whether a given cell in the array is a pointer or a bitmap. The length field is the number of bits represented by bitmap. The free field will be explained later.</p>

<p>Our previous example string 00001100 would now be represented like this:</p>

<p>``` ocaml
(<em>
  0 &ndash;> Bitmap 0
  1 &ndash;> Pointer 2
  2 &ndash;> Bitmap 1
  3 &ndash;> Bitmap 0
</em>)</p>

<p>{ length = 8;
; layers = 3;
; array = [| 0, 2, 1, 0 |]
; pointers = Widemap.of_string &ldquo;0100&rdquo;
; free = 0 }
```</p>

<p>When the bitmap is changed we may have to add or delete pairs eg if the above example changed to 00001111 it would be represented as:</p>

<p><code>ocaml
(*
  0 -&gt; Bitmap 0
  1 -&gt; Bitmap 1
  2 -&gt; ?
  3 -&gt; ?
*)
</code></p>

<p>We can grow and shrink the array as necessary, but since deleted pairs won&rsquo;t necessarily be at the end of the used space the bigarray will become fragmented. To avoid wasting space we can write a linked list into the empty pairs to keep track of free space. 0 is always the root of the tree so we can use it as a list terminator. The free field marks the start of the list.</p>

<p>``` ocaml
let del_pair binmap node_addr =
  Array.seti binmap.array node_addr binmap.free;
  binmap.free &lt;&ndash; node_addr</p>

<p>(<em> double the size of a full array and then initialise the freelist </em>)
let grow_array binmap =
  assert (binmap.free = 0);
  let old_len = Array.dim binmap.array in
  assert (old_len mod 2 = 0);
  assert (old_len &lt;= max_int);
  let new_len = min max_int (2 * old_len) in
  assert (new_len mod 2 = 0);
  let array = create_array new_len in
  Array.blit binmap.array (Array.sub array 0 old_len);
  binmap.array &lt;&ndash; array;
  binmap.free &lt;&ndash; old_len;
  for i = old_len to new_len-4 do</p>

<pre><code>if i mod 2 = 0  then Array.seti array i (i+2)
</code></pre>

<p>  done;
  Array.seti array (new_len-2) 0</p>

<p>let add_pair binmap node_left node_right =
  (if binmap.free = 0 then grow_array binmap);
  let node_addr = binmap.free in
  let free_next = Array.geti binmap.array binmap.free in
  binmap.free &lt;&ndash; free_next;
  set_node binmap node_addr true node_left;
  set_node binmap node_addr false node_right;
  node_addr
```</p>

<p>I haven&rsquo;t yet written any code to shrink the array but it should be fairly straightforward to recursively copy the tree into a new array and rewrite the pointers.</p>

<p>With the freelist our modified example now looks like this:</p>

<p><code>ocaml
{ length = 8;
; layers = 3;
; array = [| 0, 2, 0, 0 |]
; pointers = Widemap.of_string "0100"
; free = 2 }
</code></p>

<p>With the representation sorted the rest of the code more or less writes itself.</p>

<p>The only difficulty lies in choosing the width of the bitmaps used. Using smaller bitmaps increases the granularity of the binmap allowing better compression by compacting more nodes. Using larger bitmaps increases the size of the pointers allowing larger bitmaps to be represented. I&rsquo;ve written the binmap code to be width-agnostic; it can easily be made into a functor of the bitmap module.</p>

<p>The paper linked below suggests using a layered address scheme to expand the effective pointer size, where the first bit of the pointer is a flag indicating which layer the address is in. I would suggest rather than putting the flag in the pointer it would be simper to use information implicit in the structure of the tree eg is the current layer mod 8 = 0. Either way, this hugely increases the size of the address space at a the cost of a little extra complexity.</p>

<p>The original version is <a href="https://github.com/gritzko/swift/blob/master/doc/binmaps-alenex.pdf">here</a> and my version is <a href="https://github.com/jamii/binmap">here</a>. This is just an experiment so far, I certainly wouldn&rsquo;t suggest using it without some serious testing.</p>

<p>Overall I&rsquo;m not sure how useful this particular data structure is but this method of compacting tree-like types in ocaml is certainly interesting. I suspect it could be at least partially automated.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimising texsearch: memory usage]]></title>
    <link href="http://scattered-thoughts.net/blog/2010/12/19/optimising-texsearch-memory-usage/"/>
    <updated>2010-12-19T06:16:00+00:00</updated>
    <id>http://scattered-thoughts.net/blog/2010/12/19/optimising-texsearch-memory-usage</id>
    <content type="html"><![CDATA[<p>In my last post I discussed the new search algorithm behind texsearch. There is a significant speed improvement over previous versions but it now consumes a ridiculous amount of memory. The instance running <a href="http://latexsearch.com">latexsearch.com</a> wavers around 4.7 gb during normal operation and reaches 7-8 gb when updating the index. This pushes other services out of main memory and everything is horribly slow until they swap back in.</p>

<!--more-->


<p>he main data structure looks like this:</p>

<p><code>ocaml
type 'a t =
  { latexs : Latex.t DynArray.t
  ; opaques : 'a DynArray.t
  ; deleted : bool DynArray.t
  ; mutable next_id : id
  ; mutable array : (id * pos) array
  ; mutable unsorted : ('a * Latex.t) list }
</code></p>

<p>The array field is responsible for the vast majority of the memory usage. Each cell in the array contains a pointer to a tuple containing two integers for a total of 4 words per suffix. The types id and pos are both small integers so if we pack them into a single unboxed integer we can reduce this to 1 word per suffix. We have a new module suffix.ml with some simple bit-munging:</p>

<p>``` ocaml
type id = int
type pos = int</p>

<p>type t = int</p>

<p>let pack_size = (Sys.word_size / 2) &ndash; 1
let max_size = 1 lsl pack_size</p>

<p>exception Invalid_suffix of id * pos</p>

<p>let pack (id, pos) =
  if (id &lt; 0) || (id >= max_size)
  || (pos &lt; 0) || (pos >= max_size)
  then raise (Invalid_suffix (id, pos))
  else pos lor (id lsl pack_size)</p>

<p>let unpack suffix =
  let id = suffix lsr pack_size in
  let pos = suffix land (max_size &ndash; 1) in
  (id, pos)
```</p>

<p>Notice how confusing infix functions are in ocaml.</p>

<p>The suffix array type becomes:</p>

<p><code>ocaml
type 'a t =
  { latexs : Latex.t DynArray.t
  ; opaques : 'a DynArray.t
  ; deleted : bool DynArray.t
  ; mutable next_id : id
  ; mutable array : Suffix.t array
  ; mutable unsorted : ('a * Latex.t) list }
</code></p>

<p>With this change the memory usage drops down to 1.4 gb. The mean search time also improves. It seems that having fewer cache misses makes up for the extra computation involved in unpacking the suffixes.</p>

<p>Now that the array field is a single block it is easy to move it out of the heap entirely so the gc never has to scan it.</p>

<p><code>ocaml
let ancientify sa =
  sa.array &lt;- Ancient.follow (Ancient.mark sa.array);
  Gc.full_major ()
</code></p>

<p>This eliminates the annoyingly noticeable gc pauses.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimising texsearch]]></title>
    <link href="http://scattered-thoughts.net/blog/2010/12/08/optimising-texsearch/"/>
    <updated>2010-12-08T06:16:00+00:00</updated>
    <id>http://scattered-thoughts.net/blog/2010/12/08/optimising-texsearch</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/jamii/texsearch">Texsearch</a> is a search engine for LaTeX formulae. It forms part of the backend for <a href="http://latexsearch.com">latexsearch.com</a> which indexes the entire Springer corpus. It is also crazy slow, until today.</p>

<!--more-->


<p>Intuitively, when searching within LaTeX content we want results that represent the same formulae as the search term. Unfortunately LaTeX presents plenty of opportunities for obfuscating content with macros, presentation commands and just plain weird lexing.</p>

<p>Texsearch uses <a href="http://plastex.sourceforge.net/">PlasTeX</a> to parse LaTeX formulae and expand macros. The preprocessor then discards any LaTeX elements which relate to presentation rather than content (font, weight, colouring etc). The remaining LaTeX elements are each hashed into a 63 bit integer. This massively reduces the memory consumption, allowing the entire corpus and search index to be held in RAM. Collisions should be rare given that there are far less than 2<sup>63</sup> possible elements.</p>

<p>At the core of texsearch is a search algorithm which performs approximate searches over the search corpus. Specifically, given a search term S and a search radius R we want to return all corpus terms T such that the <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> between S and some substring of T is less than R. This is a common problem in bioinformatics and NLP and there is a <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.7225&amp;rep=rep1&amp;type=pdf">substantial amount of research</a> on how to solve this efficiently. I have been through a range of different algorithms in previous iterations of texsearch and have only recently achieved reasonable performance (mean search time is now ~300ms for a corpus of 1.5m documents). The code is available <a href="https://github.com/jamii/texsearch">here</a>.</p>

<p>We define the distance from latexL to latexR as the minimum Levenshtein distance between latexL and any substring of latexR. With this definition we can specify the results of the search algorithm more simply as returning all corpus terms with distance R of S.</p>

<p>``` ocaml
let distance latexL latexR =
  let maxl, maxr = Array.length latexL, Array.length latexR in
  if maxl = 0 then 0 else
  if maxr = 0 then maxl else
  (<em> cache.(l).&reg; is the distance between latexL[l to maxl] and latexR[r to maxr] </em>)
  let cache = Array.make_matrix (maxl + 1) (maxr + 1) 0 in
  (<em> Must match everything on the left </em>)
  for l = maxl &ndash; 1 downto 0 do</p>

<pre><code>cache.(l).(maxr) &lt;- 1 + cache.(l+1).(maxr)
</code></pre>

<p>  done;
  (<em> General matching </em>)
  for l = maxl &ndash; 1 downto 1 do</p>

<pre><code>for r = maxr - 1 downto 0 do
  cache.(l).(r) &lt;-
      minimum
        (1 + cache.(l).(r+1))
        (1 + cache.(l+1).(r))
        ((abs (compare latexL.(l) latexR.(r))) + cache.(l+1).(r+1))
</code></pre>

<p>  done done;
  (<em> Non-matches on the right dont count until left starts matching </em>)
  for r = maxr &ndash; 1 downto 0 do</p>

<pre><code>cache.(0).(r) &lt;-
    minimum
      (cache.(0).(r+1))
      (1 + cache.(1).(r))
      ((abs (compare latexL.(0) latexR.(r))) + cache.(1).(r+1))
</code></pre>

<p>  done;
  cache.(0).(0)
```</p>

<p>The search algorithm is built around a <a href="http://en.wikipedia.org/wiki/Suffix_array">suffix array</a> presenting the following interface:</p>

<p>``` ocaml
type &lsquo;a t</p>

<p>val create : unit &ndash;> &lsquo;a t
val add : 'a t &ndash;> ('a * Latex.t) list &ndash;> unit
val prepare : 'a t &ndash;> unit</p>

<p>val delete : &lsquo;a t &ndash;> ('a &ndash;> bool) &ndash;> unit</p>

<p>val find_exact : &lsquo;a t &ndash;> Latex.t &ndash;> (int * 'a) list
val find_approx : 'a t &ndash;> float &ndash;> Latex.t &ndash;> (int * 'a) list
val find_query : 'a t &ndash;> float &ndash;> Query.t &ndash;> (int * 'a) list
```</p>

<p>The data structure is pretty straightforward. We store the LaTeX elements in a DynArray and represent suffixes by a pair of pointers &ndash; the first into the DynArray and the second into the LaTeX term itself. Each LaTeX term is matched to an opaque object which is used by the consumer of this module to id the terms.</p>

<p>``` ocaml
type id = int
type pos = int</p>

<p>type &lsquo;a t =
  { latexs : Latex.t DynArray.t
  ; opaques : 'a DynArray.t
  ; mutable next_id : id
  ; mutable array : (id * pos) array
  ; mutable unsorted : ('a * Latex.t) list }</p>

<p>let create () =
  { latexs = DynArray.create ()
  ; opaques = DynArray.create ()
  ; next_id = 0
  ; array = Array.make 0 (0,0)
  ; unsorted = []}
```</p>

<p>The suffix array is built in a completely naive way. We just throw all the suffixes into a list and sort it. There are much more efficient methods known but this is fast enough, especially since we do updates offline. The building is separated into two functions to make incremental updates easier.</p>

<p>``` ocaml
let add sa latexs =
  sa.unsorted &lt;&ndash; latexs @ sa.unsorted</p>

<p>let insert sa (opaque, latex) =
  let id = sa.next_id in
  sa.next_id &lt;&ndash; id + 1;
  DynArray.add sa.opaques opaque;
  DynArray.add sa.latexs latex;
  id</p>

<p>let prepare sa =
  let ids = List.map (insert sa) sa.unsorted in
  let new_suffixes = Util.concat_map (suffixes sa) ids in
  let cmp = compare_suffix sa in
  let array = Array.of_list (List.merge cmp (List.fast_sort cmp new_suffixes) (Array.to_list sa.array)) in
  sa.unsorted &lt;&ndash; [];
  sa.array &lt;&ndash; array
```</p>

<p>So now we have a sorted array of suffixes of all our corpus terms. If we want to find all exact matches for a given search term we just do a binary search to find the first matching suffix and then scan through the array until the last matching suffix. For reasons that will make more sense later, we divide this into two stages. Most of the work is done in gather_exact (better name, anyone?), where we perform the search and dump the resulting LaTeX term ids into a HashSet. Then find_exact runs through the HashSet and looks up the matching opaques.</p>

<p>``` ocaml
(<em> binary search </em>)
let gather_exact ids sa latex =
  (<em> find beginning of region </em>)
  (<em> lo &lt; latex </em>)
  (<em> hi >= latex </em>)
  let rec narrow lo hi =</p>

<pre><code>let mid = lo + ((hi-lo) / 2) in
if lo = mid then hi else
if leq sa latex sa.array.(mid)
then narrow lo mid
else narrow mid hi in
</code></pre>

<p>  let n = Array.length sa.array in
  let rec traverse index =</p>

<pre><code>if index &gt;= n then () else
let (id, pos) = sa.array.(index) in
if is_prefix sa latex (id, pos)
then
  begin
Hashset.add ids id; 
traverse (index+1)
  end
else () in
</code></pre>

<p>  traverse (narrow (-1) (n-1))</p>

<p>let exact_match sa id =
  (0, DynArray.get sa.opaques id)</p>

<p>let find_exact sa latex =
  let ids = Hashset.create 0 in
  gather_exact ids sa latex;
  List.map (exact_match sa) (Hashset.to_list ids)
```</p>

<p>Now for the clever part &ndash; approximate search. First, convince yourself of the following. Suppose the distance from our search term S to some corpus term T is strictly less than the search radius R. Then if we split S into R pieces at least one of those pieces must match a substring of T exactly. So our approximate search algorithm is to perform exact searches for each of the R pieces and then calculate the distance to each of the results. Notice the similarity in structure to the previous algorithm. You can also see now that the exact search is split into two functions so that we can reuse gather_exact.</p>

<p>``` ocaml
let gather_approx sa precision latex =
  let k = Latex.cutoff precision latex in
  let ids = Hashset.create 0 in
  List.iter (gather_exact ids sa) (Latex.fragments latex k);
  ids</p>

<p>let approx_match sa precision latexL id =
  let latexR = DynArray.get sa.latexs id in
  match Latex.similar precision latexL latexR with
  | Some dist &ndash;></p>

<pre><code>  let opaque = DynArray.get sa.opaques id in
  Some (dist, opaque) 
</code></pre>

<p>  | None &ndash;></p>

<pre><code>  None
</code></pre>

<p>let find_approx sa precision latex =
  let ids = gather_approx sa precision latex in
  Util.filter_map (approx_match sa precision latex) (Hashset.to_list ids)
```</p>

<p>We can also extend this to allow boolean queries.</p>

<p>``` ocaml
let rec gather_query sa precision query =
  match query with
  | Query.Latex (latex, _) &ndash;> gather_approx sa precision latex
  | Query.And (query1, query2) &ndash;> Hashset.inter (gather_query sa precision query1) (gather_query sa precision query2)
  | Query.Or (query1, query2) &ndash;> Hashset.union (gather_query sa precision query1) (gather_query sa precision query2)</p>

<p>let query_match sa precision query id =
  let latexR = DynArray.get sa.latexs id in
  match Query.similar precision query latexR with
  | Some dist &ndash;></p>

<pre><code>  let opaque = DynArray.get sa.opaques id in
  Some (dist, opaque)
</code></pre>

<p>  | None &ndash;></p>

<pre><code>  None
</code></pre>

<p>let find_query sa precision query =
  let ids = gather_query sa precision query in
  Util.filter_map (query_match sa precision query) (Hashset.to_list ids)
```</p>

<p>This is a lot simpler than my previous approach, which required some uncomfortable reasoning about overlapping regions in quasi-metric spaces.</p>

<p>It is instructive to compare texsearch with other math search engines. Texsearch is effectively a brute force solution that gave us an ok search engine search engine with minimal risk. It has minimal understanding of LaTeX and no understanding of the structure of the formulae it searches in. <a href="http://uniquation.com/en/">Uniquation</a> accepts only a small (but widely used) subset of LaTeX but understands the structure of the equation itself and so can infer scope and perform variable substitution when searching. I am not sure yet how much content they are indexing or how well they handle searching within full LaTeX content but hopefully this approach can scale up to big corpuses. <a href="http://haskell.org/hoogle/">Hoogle</a> is a search engine for haskell types which can handle even more sophisticated equivalences than uniquation thanks to its specialised domain. <a href="https://trac.kwarc.info/arXMLiv/">ArXMLiv</a> is developing tools for inferring semantic information from LaTeX content in order to convert it to Semantic MathML, which is much easier for search engines to handle.</p>

<p>So, in summary, LaTeX is a pain in the ass.</p>
]]></content>
  </entry>
  
</feed>
