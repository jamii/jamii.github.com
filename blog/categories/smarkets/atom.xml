<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: smarkets | Scattered Thoughts]]></title>
  <link href="http://scattered-thoughts.net/blog/categories/smarkets/atom.xml" rel="self"/>
  <link href="http://scattered-thoughts.net/"/>
  <updated>2014-11-15T14:23:50-08:00</updated>
  <id>http://scattered-thoughts.net/</id>
  <author>
    <name><![CDATA[Jamie Brandon]]></name>
    <email><![CDATA[jamie@scattered-thoughts.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Transactional mealy machines]]></title>
    <link href="http://scattered-thoughts.net/blog/2011/03/16/transactional-mealy-machines/"/>
    <updated>2011-03-16T06:16:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2011/03/16/transactional-mealy-machines</id>
    <content type="html"><![CDATA[<p>This is a hugely overdue post about an interesting system I worked on almost a year ago whilst at <a href="http://smarkets.com">Smarkets</a> and never got around to writing about. Unfortunately I don&rsquo;t have the code in front of me but the overall idea is simple enough to explain without examples.</p>

<!--more-->


<p>Smarkets is a betting exchange (effectively a small stock exchange for buying and selling bets). The exchange system which handles all the money and manages the markets has quite stringent requirements. We want events to be serializable (because ordering is very important in a fast moving market), low latency and ideally distributed across more than one machine. However the exchange also has to handle a large number of bursty updates focused on a small number of records (popular markets, power users). I&rsquo;m told that the early prototypes using postgres simply couldn&rsquo;t handle the high contention so a move to a more loosely coupled system was necessary.</p>

<p>The architecture in place when I arrived at Smarkets was based on <a href="http://www.cidrdb.org/cidr2007/papers/cidr07p15.pdf">this paper</a> which I highly recommend reading. The main idea is that serializability across machines is difficult verging on impossible and that systems which try to paper over this (eg fully ACID distributed transactions) tend to be fragile at scale. The proposed solution is to identify specific sets of actions which must be serializable and handle each set with a single actor on a single machine. These actors then communicate with each other via asynchronous messages. In Smarkets' case the actors are individual markets, users, accounts and orders. These can be modeled nicely as <a href="http://en.wikipedia.org/wiki/Mealy_machine">mealy machines</a> where the output value is a list of messages, hence the title.</p>

<p>This idea was very effective but the implementation at Smarkets was some of the scariest code in the repository (thanks mostly to being the oldest code). Each actor was implemented as a single erlang process which archived messages (using couchdb) after reading them. There was a lot of repetitive boilerplate code, it was hard to test (because the actors message each other directly) and worst of all there were ways to lose messages before they were archived (eg process inbox is lost if the process dies, messages between machines can be dropped silently).</p>

<p>I wrote a new system to handle the actor implementation whilst keeping the domain-specific logic of each actor mostly unchanged. Each actor is defined by a pair of callback functions (a behaviour, in erlang-speak). The <em>init</em> function sets the initial state of the actor. The <em>transition</em> function takes the current state and an incoming message and returns the new state and possibly some outgoing messages. Everything else is handled by a generic module which takes this behaviour and turns it into a running actor. Each actor consists of an inbox, outbox and a current state, all of which are persisted using mnesia. Each actor also has a unique id used for addressing messages. The transition process &ndash; pop a message off the inbox queue, run the transition function, store the new state, push outgoing messages to the outbox &ndash; is implemented as a single ACID transaction using mnesia. For actors on the same machine messages are moved directly from one actorâ€™s outbox to another&rsquo;s inbox directly using mnesia transactions. For actors on different machines the outbox using erlang messages and sends repeatedly (with exponential backoff) until the receiver confirms receipt. The outbox attaches auto-incrementing message ids to each message which, together with the actor id of the sender, allows the receiver to ignore duplicate messages.</p>

<p>In this way the domain-specific logic is separated from message handling and storage. This led to much less repetition and a more maintainable system. It also made it easy to setup tests or replay past events without recreating the whole system. Last, but certainly not least, it can only lose messages if the database or disk fails and even then is easier to restore from backup than the previous system.</p>

<p>Note that this explanation is somewhat simplified. I have glossed over some fiddly implementation details like error handling (if an actor fails to handle a message the sender needs to be notified in many cases) and also left out extra features like subscribing to state changes (eg notify me when this order is filled). There is also a knack to designing actors which must cooperate without <a href="http://en.wikipedia.org/wiki/Common_knowledge_%28logic%29">common knowledge</a>. Hopefully the <a href="https://smarkets.com/about/contact/">Smarkets team</a> will find some time to open-source the actual code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smarkets API documentation]]></title>
    <link href="http://scattered-thoughts.net/blog/2010/07/30/smarkets-api-documentation/"/>
    <updated>2010-07-30T06:16:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2010/07/30/smarkets-api-documentation</id>
    <content type="html"><![CDATA[<p>I want to write a little about the documentation system I wrote for the smarkets API. The main concern I had with the documentation was that it would be incorrect or become out of sync with the code, especially since I didn&rsquo;t really understand the system when I started documenting it. To prevent this I built a couple of documentation tools that have paid for themselves many times over.</p>

<!--more-->


<p>We have our own home-grown and slightly crappy web framework which powers the public API. A typical resource declaration looks like this:</p>

<p>``` erlang
   #a{m=[fun rest_aux:user_id/1, emails,</p>

<pre><code>     fun rest_aux:email/1, fun rest_aux:hash/1],
  f=[{'PUT', fun rest_users:user_or_admin/3}],
  scope=[{'PUT', private}],
  pu=fun(UserId, Email, Hash, _Auth, Ctx) -&gt;
         case users:verify_email(UserId, Email, Hash) of
           ok -&gt;
             smarkets_rest:nc(Ctx);
           {error, conflict} -&gt;
             smarkets_rest:cfl(Ctx);
           {error, not_found} -&gt;
             smarkets_rest:nf(Ctx)
         end
     end}
</code></pre>

<p>```</p>

<p>To this I added a documentation field for each method:</p>

<p>``` erlang
   #a{m=[fun rest_aux:user_id/1, emails,</p>

<pre><code>     fun rest_aux:email/1, fun rest_aux:hash/1],
  f=[{'PUT', fun rest_users:user_or_admin/3}],
  scope=[{'PUT', private}],
  pu_doc = #'doc.method'{
    doc = "Verify the specified email using the hash code sent to the user",
    responses =
      [{200, "Successful"}
      ,{404, "Specified user or email does not exist"}
      ,{409, "Incorrect hash code"}]},
  pu=fun(UserId, Email, Hash, _Auth, Ctx) -&gt;
         case users:verify_email(UserId, Email, Hash) of
           ok -&gt;
             smarkets_rest:nc(Ctx);
           {error, conflict} -&gt;
             smarkets_rest:cfl(Ctx);
           {error, not_found} -&gt;
             smarkets_rest:nf(Ctx)
         end
     end}
</code></pre>

<p>```</p>

<p>From this the documentation system generates a json object which is stored in couchdb:</p>

<p>``` json
{
   &ldquo;<em>id&rdquo;: &ldquo;users/{user_id}/emails/{email}/{hash}&rdquo;,
   &ldquo;</em>rev&rdquo;: &ldquo;1-0c4c3aad1227a62429ffb0c05a7059f1&rdquo;,
   &ldquo;type&rdquo;: &ldquo;doc.action&rdquo;,
   &ldquo;term&rdquo;: {</p>

<pre><code>   "methods": {
       "PUT": {
           "type": "doc.method",
           "term": {
               "headers": {
               },
               "opt_params": {
               },
               "req_params": {
               },
               "scope": "private",
               "role": "rest_users.user_or_admin",
               "auth": "needs_user",
               "responses": {
                   "200": "Successful",
                   "404": "Specified user or email does not exist",
                   "409": "Incorrect hash code"
               },
               "doc": "Verify the specified email using the hash code sent to the user"
           }
       }
   },
   "path": "users/{user_id}/emails/{email}/{hash}"
</code></pre>

<p>   }
}
```</p>

<p>This json object is used by a couple of different scripts. Both the <a href="http://smarkets.com/api/documentation/">public api reference</a> and our own internal api reference are produced from these json objects. I also added a fuzzer which can read the json documentation and generate calls with both random data and records pulled from the development database. The fuzzer logs the results of these calls like this:</p>

<p>``` json
{
   &ldquo;<em>id&rdquo;: &ldquo;320f2a4bc956334c66c84a4d9f6160a0&rdquo;,
   &ldquo;</em>rev&rdquo;: &ldquo;1-a109f7aa2906e2452e45a49d649674cb&rdquo;,
   &ldquo;body&rdquo;: &ldquo;{}&rdquo;,
   &ldquo;code&rdquo;: 403,
   &ldquo;path_spec&rdquo;: &ldquo;users/{user_id}/emails/{email}/{hash}&rdquo;,
   &ldquo;method&rdquo;: &ldquo;PUT&rdquo;,
   &ldquo;headers&rdquo;: {</p>

<pre><code>   "Content-type": "application/json",
   "Authorization": "UserLogin token=\"O3bHthtJ6wumlt0yjf0q8OrYURMBKiRbfNRmhfGLJNCXhcXkSrzyPVzm47MoWD_lt6UdOJlA8wf1AWY~\""
</code></pre>

<p>   },
   &ldquo;path&rdquo;: &ldquo;users/54ad2cc2a1dd2871518c528a11a40f00/emails/jMt%40XPqKYLNx/50584d82c756b2e4a53c8695553ae34a&rdquo;,
   &ldquo;response&rdquo;: null,
   &ldquo;port&rdquo;: 9000
}
```</p>

<p>Another set of scripts then combs through these tables looking for errors. Anything that returns &lsquo;500 internal server error&rsquo; is flagged. Calls which return &lsquo;400 bad request&rsquo; and are not tagged as being deliberately malformed are also flagged. Same goes for any response code which isn&rsquo;t documented for that call and any documented response code which isn&rsquo;t observed in the fuzzer table. One particularly useful script lists methods which are accessible via the public port.</p>

<p>This system has worked out quite well so far. The documentation is embedded directly next to the related code so its hard to forget to update it when changing the code. The fuzzer is worth its weight in gold and has uncovered countless bugs and weird corner cases. For such a crude fuzzer it generates suprisingly good code coverage. The next step is to combine the fuzzer with a smallcheck-style test system in order to better narrow down errors in long sequences of calls.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smarkets API]]></title>
    <link href="http://scattered-thoughts.net/blog/2010/07/15/smarkets-api/"/>
    <updated>2010-07-15T06:16:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2010/07/15/smarkets-api</id>
    <content type="html"><![CDATA[<p>Since the beginning of June I have been working at <a href="http://smarkets.com">smarkets</a>. Smarkets is a betting exchange, something like a cross between a traditional bookies and a stock exchange. You can buy and sell contracts like &lsquo;England will lose the world cup&rsquo; whose value is determined by events in the real world. Trading continues right up until the contracts are settled so you can watch the market prices change in real time during a live event.</p>

<p>One of my main responsibilities is the public api, which has just been released after the best part of a month of work. This first release contains enough functionality to create your own interface to the smarkets backend or to run automated trading robots. Documentation will soon be available on the main site &ndash; for now it is living <a href="http://smarkets.com/api/documentation/">here</a> until the sphinx default stylesheets have been replaced with smarkety goodness. You will, of course, need a smarkets account to get started.</p>

<p>Have fun, play nice.</p>
]]></content>
  </entry>
  
</feed>
