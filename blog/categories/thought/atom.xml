<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: thought | Scattered Thoughts]]></title>
  <link href="http://scattered-thoughts.net/blog/categories/thought/atom.xml" rel="self"/>
  <link href="http://scattered-thoughts.net/"/>
  <updated>2015-06-04T17:19:01-07:00</updated>
  <id>http://scattered-thoughts.net/</id>
  <author>
    <name><![CDATA[Jamie Brandon]]></name>
    <email><![CDATA[jamie@scattered-thoughts.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Three months of Rust]]></title>
    <link href="http://scattered-thoughts.net/blog/2015/06/04/three-months-of-rust/"/>
    <updated>2015-06-04T16:30:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2015/06/04/three-months-of-rust</id>
    <content type="html"><![CDATA[<p>I work on <a href="http://incidentalcomplexity.com/">Eve</a>, a functional-relational programming language and environment. Since the Eve editor has to run in a browser we built the first few versions entirely in javascript. This has been pretty painful, so a little over three months ago we started looking at other options.</p>

<p>The only hard requirements for the runtime are a) we need control over memory layout and b) we need to safely execute untrusted Eve code. Preemptive threads and the ability to compile to efficient javascript would also be valuable.</p>

<p>Javascript <em>can</em> support manual memory layout but provides very little help in getting it right. Native objects have some <a href="https://news.ycombinator.com/item?id=8793817">necessary limitations</a> and asm.js is impractical to write by hand.</p>

<p>C can run in the browser via Emscripten but the available evidence suggests that writing secure C is not a thing that mortals are good at.</p>

<p>Rust is an unknown. It provides control over memory layout, has a community with a strong focus on safety and <em>may</em> support Emscripten in the future. It also promises a minimum of <a href="http://www.urbandictionary.com/define.php?term=footgun&amp;defid=7493319">footguns</a>, which is an attractive feature after many months of javascript and ArrayBuffers. Our initial experiments were promising, so we decided that in the next version of Eve we would write the query planner and runtime in Rust.</p>

<p>There are a number of things that made this much less risky than it sounds. First, the query planner is on the way to being bootstrapped and the remaining runtime is only a few thousand lines of code. Most of the development time is spent experimenting with different language semantics and evaluation strategies, rather than building up a large codebase that would tie us to Rust. Second, we have two escape hatches if Rust doesn&rsquo;t work out. We can use the FFI to gradually port components to C, or we can use the websocket interface to the editor to gradually port components to javascript.</p>

<p>(&ldquo;You should look at language X!&rdquo;. We did, and then we decided to use Rust. We can still be friends.)</p>

<p>So here is what I think after three months of working with Rust full-time. TLDR: mostly impressive, a few worrying quirks, probably the best option for us right now.</p>

<h2>Community</h2>

<p>The Rust community seems to be populated entirely by human beings. I have no idea how this was done. I suspect Graydon Hoare deserves a large share of the credit for leading by example but everyone I have interacted with in the community has been friendly and patient.</p>

<p>Despite my concerns over the size and complexity of the compiler and the LLVM toolchain, I haven&rsquo;t encountered any compiler bugs and only a <a href="https://github.com/rust-lang/rust/issues/24557">single bug</a> in the standard library. The community&rsquo;s attitude towards reliability and safety is by far the strongest point in favour of us continuing to use Rust.</p>

<h2>Tooling</h2>

<p>Compile times are brutal. For our 2400 loc it takes 20s for a dev build and 70s for a release build. Word is that compile time just hasn&rsquo;t been a focus so far and will improve in future releases. Type checking occurs very early in that 20s so running <code>cargo build</code> in a loop gives reasonably fast feedback on type errors, but any time we want to add an extra print statement we pay the full price. Moving the Eve editor into Rust would simplify the overall architecture but the people writing the editor refuse to wait 20s for a page refresh.</p>

<p>Error messages are better than any other tool I have used. For most errors the compiler not only clearly explains the problem but also offers the correct solution. There is no secret sauce, it&rsquo;s just the result of long hours from the compiler team and a culture of caring about usability.</p>

<p><code>rust
src/relation.rs:110:29: 110:38 error: unresolved name `before_op`. Did you mean `before_opt`?
src/relation.rs:110                             before_op = befores.next();
</code></p>

<p><code>`` rust
src/relation.rs:121:29: 121:33 error: attempted to take value of method</code>iter<code>on type</code>collections::vec::Vec&lt;collections::string::String>`
src/relation.rs:121         let ix = self.names.iter.position(|my_name| &amp;my_name[..] == name).unwrap();</p>

<pre><code>                                            ^~~~
</code></pre>

<p>src/relation.rs:121:29: 121:33 help: maybe a <code>()</code> to call it is missing? If not, try an anonymous function
```</p>

<p>``` rust
src/value.rs:14:15: 14:20 error: cannot move out of borrowed content
src/value.rs:14         match *self {</p>

<pre><code>                          ^~~~~
</code></pre>

<p>src/value.rs:17:27: 17:33 note: attempting to move value to here
src/value.rs:17             Value::String(string) => string.fmt(formatter),</p>

<pre><code>                                      ^~~~~~
</code></pre>

<p>src/value.rs:17:27: 17:33 help: to prevent the move, use <code>ref string</code> or <code>ref mut string</code> to capture value by reference
```</p>

<p>Cargo is solid. Building projects, versioning dependencies and running tests/benchmarks are all easy. I would like to see <code>cargo bench</code> produce comparison graphs (like <a href="https://github.com/garybernhardt/readygo">readygo</a>). I&rsquo;m also looking forward to <a href="https://github.com/nrc/rustfmt">rustfmt</a> since most editors currently do a pretty poor job of auto-indenting.</p>

<p>Javascript profilers tend to tell me that the Eve runtime spends 100% of its time in <code>main</code> and calls no other functions. With Rust I get to use valgrind and perf which actually return useful information.</p>

<p>Debugging is less exciting &ndash; both GDB and LLDB work and there is a <a href="https://michaelwoerister.github.io/2015/03/27/rust-xxdb.html">macros package</a> that makes them more useful but the Chrome debugger is still far more useable (when it doesn&rsquo;t crash).</p>

<h2>Ownership</h2>

<p>One of the unique features of Rust is that the type system tracks ownership of data. Shared mutability is the root of many bugs and vulnerabilities, especially in concurrent environments. Functional languages address this by removing or strictly controlling mutability. Rust addresses this by tracking and controlling sharing. See the <a href="https://doc.rust-lang.org/book/ownership.html">documentation</a> for the gory details.</p>

<p>Most code I write now compiles without error. Most errors I see are clearly mistakes on my part and are easy to fix. About once a week, I hit an error that causes some headscratching. In most case I fume for a while before realising that I was trying to blow my foot off.</p>

<p><code>``
src/view.rs:205:70: 205:81 error:</code>outer_items` does not live long enough
src/view.rs:205                     output_pairs.push((&amp;aggregate.outer.fields[..], &amp;outer_items[..]));</p>

<pre><code>                                                                                 ^~~~~~~~~~~
</code></pre>

<p>note: in expansion of for loop expansion
src/view.rs:172:17: 212:18 note: expansion site
src/view.rs:203:47: 212:18 note: reference must be valid for the block suffix following statement 3 at 203:46&hellip;
src/view.rs:203                         ).collect::&lt;Vec&lt;_>>();
src/view.rs:204                     let outer_items = vec![outer_values];
src/view.rs:205                     output_pairs.push((&amp;aggregate.outer.fields[..], &amp;outer_items[..]));
src/view.rs:206                     if aggregate.selects_inner {
src/view.rs:207                         output_pairs.push((&amp;aggregate.inner.fields[..], group))
src/view.rs:208                     }</p>

<pre><code>            ...
</code></pre>

<p>src/view.rs:204:58: 212:18 note: &hellip;but borrowed value is only valid for the block suffix following statement 4 at 204:57
src/view.rs:204                     let outer_items = vec![outer_values];
src/view.rs:205                     output_pairs.push((&amp;aggregate.outer.fields[..], &amp;outer_items[..]));
src/view.rs:206                     if aggregate.selects_inner {
src/view.rs:207                         output_pairs.push((&amp;aggregate.inner.fields[..], group))
src/view.rs:208                     }
src/view.rs:209                     let mut tuples = Vec::with_capacity(output_pairs.len());
```</p>

<p>It took me a while to realise that this error is trying to tell me is that <code>output_pairs</code> is declared one line before <code>outer_items</code>. Declarations for a block are freed in reverse order, so <code>outer_items</code> will be freed first and there will be a dangling pointer when <code>output_pairs</code> is freed. All I have to do to fix it is declare <code>output_pairs</code> after <code>outer_items</code>.</p>

<p>Most of my confusion looks like this. There is some pattern that I didn&rsquo;t think about before and now that I understand it I won&rsquo;t struggle with that kind of error again. As the language matures I expect that these patterns will be collected and documented.</p>

<p>There are also some patterns that the borrow checker can&rsquo;t understand (or, more accurately, there is no matching pattern in the standard library). This is a heavily simplified version of a common pattern in the query engine:</p>

<p>``` rust
fn step&lt;&lsquo;a>(table: &amp;'a [String], state: &amp;mut Vec&lt;&amp;'a String>, results: &amp;mut Vec&lt;Vec<String>>) {</p>

<pre><code>if table.len() == 0 {
    results.push(state.iter().map(|s| (*s).to_owned()).collect());
} else if table.len() % 2 == 0 { // some complicated condition
    state.push(&amp;table[0]);
    step(&amp;table[1..], state, results);
    state.pop();
} else {
    let s = "some new thing".to_owned();
    state.push(&amp;s);
    step(&amp;table[1..], state, results);
    state.pop();
}
</code></pre>

<p>}</p>

<p>fn main() {
   let table = vec![&ldquo;a&rdquo;.to_owned(), &ldquo;b&rdquo;.to_owned(), &ldquo;c&rdquo;.to_owned(), &ldquo;d&rdquo;.to_owned()];
   let mut state = vec![];
   let mut results = vec![];
   step(&amp;table[..], &amp;mut state, &amp;mut results);
}
```</p>

<p>Which produces this error:</p>

<p><code>`` rust
&lt;anon&gt;:10:21: 10:22 error:</code>s` does not live long enough
<anon>:10         state.push(&amp;s);</p>

<pre><code>                          ^
</code></pre>

<p><anon>:1:95: 14:2 note: reference must be valid for the lifetime &lsquo;a as defined on the block at 1:94&hellip;
<anon>:1 fn step&lt;'a>(table: &amp;'a [String], state: &amp;mut Vec&lt;&amp;'a String>, results: &amp;mut Vec&lt;Vec<String>>) {
<anon>:2     if table.len() == 0 {
<anon>:3         results.push(state.iter().map(|s| (*s).to_owned()).collect());
<anon>:4     } else if table.len() % 2 == 0 { // some complicated condition
<anon>:5         state.push(&amp;table[0]);
<anon>:6         step(&amp;table[1..], state, results);</p>

<pre><code>     ...
</code></pre>

<p><anon>:9:40: 13:6 note: &hellip;but borrowed value is only valid for the block suffix following statement 0 at 9:39
<anon>:9         let s = &ldquo;some new thing&rdquo;.to_owned();
<anon>:10         state.push(&amp;s);
<anon>:11         step(&amp;table[1..], state, results);
<anon>:12         state.pop();
<anon>:13     }
```</p>

<p>The core problem is that I&rsquo;m pushing a value <code>s</code> into a vector which lives longer than <code>s</code>. The borrow checker isn&rsquo;t capable of proving that I remove the value again before it is freed. I could build a wrapper around the vector library that understands this pattern, or I could just promise the borrow checker that I know what I&rsquo;m doing:</p>

<p>``` rust</p>

<pre><code>let s = "some new thing".to_owned();
// promise the borrow checker that we will pop s before we exit this scope
let s = unsafe { ::std::mem::transmute::&lt;&amp;String, &amp;'a String&gt;(&amp;s) };
state.push(s);
step(&amp;table[1..], state, results);
state.pop();
</code></pre>

<p>```</p>

<p>I like this pragmatic approach to safety. When the type-system understands what I&rsquo;m doing I get the full benefit. When it doesn&rsquo;t I can escape and do my own reasoning. If a particular pattern appears frequently I can put that reasoning into a library (like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> or <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>) and expose a safe interface that the type system understands. It feels like having an extensible type system that can learn to understand the way each project manages memory.</p>

<h2>Control</h2>

<p>Rust has <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data-types</a> that layout data consecutively. Pointers are opt-in. Gaining a similar level of control in javascript <em>is</em> possible but it requires some mightily unpleasant gymnastics. Rust feels like a high-level language most of the time but manages to do it without vomiting all over the cache.</p>

<p>Rust doesn&rsquo;t help at all with <a href="http://bitsquid.blogspot.com/2010/02/blob-and-i.html">blobs</a> though. They have to be handled with &lsquo;unsafe&rsquo; code which subverts the normal Rust guarantees. The unsafe code could be wrapped in a library (like <a href="https://github.com/frankmcsherry/columnar">columnar</a>) to ensure that clients use it correctly but the library code itself will still need very careful review. And speaking of review&hellip;</p>

<h2>Unsafe</h2>

<p>There is a very recent effort to define <a href="http://cglab.ca/~abeinges/blah/rust-unsafe-intro/">exactly what unsafe code has to do</a> to not ruin all the guarantees that Rust works so hard to provide. The list of <a href="https://doc.rust-lang.org/reference.html#behavior-considered-undefined">undefined behaviour</a> is long and scary. It looks like consensus and documentation is on the way but until then &hellip; here be dragons.</p>

<h2>Zero cost</h2>

<p>Rust provides a lot of high-level abstractions which LLVM then optimises away. For example, large chains of iterator functions usually optimise into imperative loops. And the word &lsquo;usually&rsquo; is what makes me worry. So far Rust has behaved but I have been bitten badly by other &lsquo;sufficiently smart&rsquo; compilers.</p>

<p>Modern machines are a huge pile of opaque and unreliable heuristics and the current trend is to add more and more layers on top. The vast majority of systems are built this way and it is by all accounts a successful strategy. That doesn&rsquo;t mean I have to like it.</p>

<h2>Syntax</h2>

<p>Doesn&rsquo;t matter that much. I got used to it.</p>

<p>There is a hint of object-orientation in that one can write <code>foo.bar(x, y, z)</code> and it desugars to something like <code>bar(foo, x, y, z)</code>. If it was only sugar I would be happy enough, but it also has non-trivial interactions with namespaces, trait dispatch, auto-deref and auto-borrow which I will go into below. There is a whole pile of intertwined design decisions here that have been made for totally valid ergonomic reasons but give rise to some interactions that make me nervous.</p>

<h2>Namespaces</h2>

<p>There are effectively three kinds of namespaces.</p>

<p>Modules behave like most static languages &ndash; you can call functions using their full path or you can import them under a short name eg</p>

<p>``` rust
::my::global::namespace::foo(bar)</p>

<p>use my::global::namespace;
namespace::foo(bar);</p>

<p>use my::global::namespace::foo;
foo(bar);
```</p>

<p>There is some funkiness around how modules are structured and how they are scoped relative to each other that I haven&rsquo;t taken the trouble to understand. I only need one level of namespaces.</p>

<p>Types can also be namespaces. You can add a method to a type and access it either through the type or through the dot syntax.</p>

<p>``` rust
struct Bar{
  &hellip;
}</p>

<p>impl Bar{
  fn foo(self) {&hellip;}
}</p>

<p>Bar::foo(bar);
bar.foo();
```</p>

<p>Lastly, traits can attach methods to types. To prevent collisions, the methods are namespaced by the trait.</p>

<p>``` rust
struct Bar {
  &hellip;
}</p>

<p>trait Foo{
  fn foo(self);
}</p>

<p>impl Foo for Bar {&hellip;}</p>

<p>Foo::foo(bar);</p>

<p>use Foo; // import foo for the dot syntax
bar.foo();
```</p>

<p>Not unreasonable so far. It can sometimes be hard to track down where a particular method came from but the dispatch is at least direct. No inheritance or prototype chains to deal with.</p>

<h2>Traits</h2>

<p>Haskell suffers from an excess of magic. Typeclass methods can dispatch on the type of any argument (or on the return type!) but the types are usually inferred. Reading haskell code that overuses typeclasses may require running the inference algorithms in your head, which is difficult and error-prone. This can also lead to bugs when an edit in one place changes a type, causing a different instance to be silently selected somewhere else (Don Stewart warned against this in his <a href="http://code.haskell.org/~dons/talks/padl-keynote-2012-01-24.pdf">PADL keynote</a>).</p>

<p>OCaml leans entirely the other way. Code is very readable and maintainable because all the information needed to follow the dispatch is written down explicitly. On the other hand, printing a simple data-structure can require chaining together multiple lines of functors to get to the correct function.</p>

<p>Rust has very similar capabilities to haskell but (so far) abuses them less often. There are only a few cases so far where I felt lost in types &ndash; <a href="http://cyderize.github.io/rust-websocket/doc/websocket/index.html">rust-websocket</a> being the biggest offender.</p>

<p>Traits have different syntax for the distinguished <code>self</code> argument and I never get it right. Nor am I totally sure what the tradeoffs are between having a <code>self</code> argument and not. You can put constraints directly on <code>self</code> but for other arguments you must use a <code>where</code> clause:</p>

<p>``` rust
trait Foo<B> {
  fn foo(self, B)
}</p>

<p>fn do_stuff&lt;A: Foo<B>, B>(a: A, b: B) { .. }</p>

<p>trait Foo&lt;A, B> {
  fn(a: A, b: B)
}</p>

<p>fn do_stuff&lt;A,B>(a: A, b: B) where Foo&lt;A, B> { .. }
```</p>

<p>Some kinds of constraints <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">cannot be used in where clauses</a>, so I <em>believe</em> the former is strictly more powerful.</p>

<p>It also affect associated types:</p>

<p>``` rust
fn next_path&lt;N: Iterator>(nibbles: &amp;mut N) &ndash;> u32 where <N as Iterator>::Item = u8</p>

<p>fn next_path&lt;N: Iterator&lt;Item=u8>>(nibbles: &amp;mut N) &ndash;> u32
```</p>

<p>At the time I wrote that code, only the latter version worked. Which means that <code>Iterator</code> <em>has</em> to have chosen to use a self type for this function to be written. It looks like there may be cases where choosing the wrong argument to promote to <code>self</code> can prevent me from writing certain constraints?</p>

<h2>Auto-deref</h2>

<p>Self types are further privileged. Suppose we have:</p>

<p>``` rust
trait Foo {
  fn foo(self);
}</p>

<p>x.foo()
```</p>

<p>If <code>x</code> implements <code>Foo</code> then life is simple. If <code>x</code> doesn&rsquo;t implement <code>Foo</code> but does implement <code>Deref</code> then the compiler will change the call to <code>x.deref().foo()</code>. This continues with <code>x.deref().deref().foo()</code> and so on until compiler finds a type that doesn&rsquo;t implement <code>Deref</code> or a type that does implement <code>Foo</code>. This is great ergonomically &ndash; it means you can call methods on a smart pointer as it were the pointed-at object. But it only works on the self argument &ndash; other arguments have to be manually deref-ed.</p>

<p>Similarly, if a method is declared to take <code>&amp;self</code> or <code>&amp;mut self</code> the compiler will insert the appropriate borrow before making the call. <code>foo.bar()</code> could desugar to <code>bar(foo)</code> or <code>bar(&amp;foo)</code> or <code>bar(&amp;mut foo)</code> depending on the type of <code>bar</code>.</p>

<p>Auto-deref and auto-borrow can interact unpleasantly with traits and inference. Here is a real example that totally confused me:</p>

<p>``` rust
let x = &ldquo;foo&rdquo;:
print_type_of(x.to_owned()); // prints String</p>

<p>let xs = vec![&ldquo;foo&rdquo;];
for x in xs.into_iter() {
  print_type_of(x.to_owned()); // prints String
}</p>

<p>let xs = vec![&ldquo;foo&rdquo;];
for x in xs.iter() {
  print_type_of(x.to_owned()); // prints &amp;str
)
```</p>

<p>What&rsquo;s going on? The standard library has the following implementations:</p>

<p>```
impl ToOwned for str {
  type Owned = String
  &hellip;
}</p>

<p>impl<T> ToOwned for T where T: Clone {
  type Owned = T
  &hellip;
}</p>

<p>impl Clone for &amp;T
```</p>

<p>The type of <code>x</code> in the first two examples is <code>&amp;str</code> which auto-derefs to <code>str</code> and gets <code>Owned = String</code>. The type of <code>x</code> in the third example is <code>&amp;&amp;str</code> (because iter borrows elements of the vec). <code>&amp;str</code> implements <code>Clone</code> so <code>&amp;&amp;str</code> implements <code>ToOwned</code> directly and does not auto-deref to <code>str</code>.</p>

<p>This is a risk for traits in general, but auto-deref exacerbates it by creating multiple types that might choose an instance. In this case it caused a type error but you can imagine cases where adding a new trait implementation silently changes the selected instance of a seemingly unrelated call in far away code. Very difficult for code review to catch.</p>

<p>A similar mistake can happen if both the dereferenced type and the pointer type implement a method with the same name, but it looks like the standard library authors are aware of this and have stopped implementing methods directly on pointer types.</p>

<h2>Learning curve</h2>

<p>The borrow checker was initially huge impediment to productivity but I reached the break-even point around the second month. Ownership and borrowing have become intuitive and I no longer have to contort designs around them.</p>

<p>Safety is an enormous productivity boon. I&rsquo;ve checked in a total of 10k lines of Rust code and written many more experiments that didn&rsquo;t make it to master, and in that time I haven&rsquo;t had a single segfault, nor any bugs caused by accidental mutation, aliasing, type errors or null pointers. The vast majority of typing mistakes are also caught at compile time (the exceptions being interactions with dynamically typed Eve data).</p>

<p>Despite the restrictions of the type system, I am more productive in Rust than I am in either Javascript or Haskell. It manages somehow to hit a sweet spot between safety and ease of use.</p>

<p>By far, the feature I miss most is interactive development. The <a href="https://github.com/murarth/rusti">repl</a> is only a thin layer over the compiler &ndash; it&rsquo;s equally slow and nukes all state between every eval. Adding interactivity to a language that wasn&rsquo;t designed for it is generally unsatisfying so this is not something that it likely to be fixed.</p>

<h2>For Eve</h2>

<p>One of the core values of Eve is radical simplicity, in the same vein as the <a href="http://www.vpri.org/pdf/tr2011004_steps11.pdf">STEPS</a> and <a href="http://boom.cs.berkeley.edu/">BOOM</a> projects. We have to make compromises if we want to ever ship, but sitting atop Rust, LLVM and possibly Emscripten feels like a pretty big compromise.</p>

<p>The complexity in Rust exists to create a general-purpose systems language with an array of features and zero-cost abstractions that are incredibly useful for building large projects. But we aren&rsquo;t building a large project, by design, and we don&rsquo;t <em>need</em> most of the features.</p>

<p>The only places where we absolutely need manual layout so far are for Eve data and indexes. Those are nicely self-contained &ndash; no pointers to the outside world &ndash; and have a well-defined life-cycle. I wonder how far we could get with an approach like <a href="http://terralang.org/">Terra</a>, writing the core data-structures and algorithms in some scary unsafe language and interact with them safely from a managed language. With a staged approach we could build just the safety mechanisms that we need and avoid carrying around the complexity of the rest. Javascript seems to have all the features needed to make this kind of approach work but it doesn&rsquo;t have the tools needed to make it bearable. Creating one programming language is hard enough &ndash; we probably shouldn&rsquo;t start on another.</p>

<p>Regardless, Rust is an incredible language in general. Even if we end up using something else for Eve, I can see myself using Rust for other projects where I care about performance, safety or reliability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scaling down]]></title>
    <link href="http://scattered-thoughts.net/blog/2015/02/09/scaling-down/"/>
    <updated>2015-02-09T13:42:00-08:00</updated>
    <id>http://scattered-thoughts.net/blog/2015/02/09/scaling-down</id>
    <content type="html"><![CDATA[<p>The programming world is obsessed with scaling up. How many million lines of code can we maintain? How many petabytes of data can we process? How deeply can I customise this editor? More code, more data, more people, more machines.</p>

<p>Nobody talks about scaling down.</p>

<!--more-->


<p>The vast majority of programs are never written. Ideas die stillborn because the startup cost is too high to bear. When we focus entirely on the asymptotic cost of developing large systems we neglect the constant costs that make tedious grinds out of simple tasks.</p>

<p>There is a great deal to be gained from switching the focus from <em>what we can do</em> to <em>what we can get done</em>, from creating the most <em>expressive</em> tools to creating the most <em>efficient</em> tools. To do this we need to become conscious of the friction imposed by our tools. When we scale up, the concerns are performance, modularity, maintainability, expressiveness. A toolset optimised for small-scale programming must have different metrics:</p>

<ul>
<li><p>How long does it take to create a project? Creating a github repo, making a build file, editing the project template, opening editors, starting repls, launching dev servers.</p></li>
<li><p>How long does it take to get results on the screen? Compare to how long it takes to get bored and lose interest.</p></li>
<li><p>How long does it take to leverage libraries? Figuring out which library to use, installing the correct version, understanding the documentation, making a successful api call.</p></li>
<li><p>How long does it take to deploy? Serving a website, uploading a package, emailing a self-contained script, installing a cron job.</p></li>
<li><p>How hard is it to see what is going on? Can you inspect variables, set breakpoints, trace messages, rewind time?</p></li>
<li><p>How quickly are bugs found and corrected? How much time passes between making a mistake, noticing the damage, reproducing the trigger, understanding what went wrong and applying the fix?</p></li>
<li><p>How much time do you spend on incidental tasks? Installing libraries, committing to version control, drawing module boundaries, constructing class hierarchies, writing build scripts. Anything that is supporting the process rather than directly solving the original problem.</p></li>
<li><p>How easy is it to collaborate with another person? What is the latency of sharing? Can you work together in real time? How long does it take before the other person is in a state to work on the code?</p></li>
<li><p>How quickly can you change the program when your goals change? Are you stuck with your architectural mistakes? Is everything tangled together? Do all the boundaries have to change?</p></li>
</ul>


<p>The instinctive reaction is that the problems are overblown and everything would be fine if everybody would just use language / tool / methodology X.</p>

<p>So let&rsquo;s try it. Pick one of these programs and solve it however you think best. Record a video and afterwards break down your activity minute by minute.</p>

<ul>
<li><p>Fairly queue song choices in the office.</p></li>
<li><p>Display a notification whenever an email arrives from a specific address.</p></li>
<li><p>Record audio whenever some hardware button is held on your phone lock-screen and save in a browseable / playable list.</p></li>
<li><p>Fetch transaction records from your online bank, break down costs by regex categories and display a pie-chart for each month.</p></li>
</ul>


<p>So much of what we actually do goes unnoticed after years of practice and routine. The reality may be quite different from what you imagine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Humans should learn maths]]></title>
    <link href="http://scattered-thoughts.net/blog/2014/11/15/humans-should-learn-maths/"/>
    <updated>2014-11-15T14:19:00-08:00</updated>
    <id>http://scattered-thoughts.net/blog/2014/11/15/humans-should-learn-maths</id>
    <content type="html"><![CDATA[<p>In the history of humanity there have been three major inventions that have enabled people to think in entirely new ways. They allow us to learn more, think bigger thoughts and solve harder problems. They are:</p>

<ul>
<li>Writing: a means to store knowledge in a brain-independent form that can be easily replicated, transmitted and preserved</li>
<li>Mathematics: a methodology for constructing abstract systems, reasoning about them precisely and finding connections between them</li>
<li>Science: a methodology for finding abstract systems which map closely to the real world</li>
</ul>


<p>The reason why we teach these in schools to everyone everywhere is that they are part of your cultural inheritance as a human. It is your right to have these tools. Over the last few hundred years they have empowered us to eradicate diseases, light the dark and explore the stars.</p>

<!--more-->


<p>Recently there has been a fourth major tool added to the list:</p>

<ul>
<li>Computing: a way to arrange inanimate systems to simulate arbitrary abstract systems</li>
</ul>


<p>Take a step back and think about what a remarkable idea it is a universal computer is even possible. We can take this inanimate system and arrange it so that it&rsquo;s behaviour gives us information about another, completely unrelated system. We sit down and press buttons for a while and the machine churns and the screen glows and suddenly we know whether or not it will rain tomorrow. We discovered that the same system can be implemented using digital circuits or vacuum tubes or the atmosphere of a planet. Somehow the physical substrate doesn&rsquo;t matter &ndash; the system has a life independent of it&rsquo;s physical existence.</p>

<p>This idea of <a href="http://yudkowsky.net/rational/the-simple-truth">entangling</a> unrelated systems so that the heap of silicon you hold can tell you what the weather will be tomorrow or what just happened on the other side of the world is impossibly and wonderfully strange and yet hardly even noticed.</p>

<p>The process of entangling one of these miraculous devices is called programming. At some point the internet collectively decided to have a civilised debate about whether or not programming is maths. The implied subtext wavers between &ldquo;if you don&rsquo;t know category theory you are a bad programmer and should feel bad&rdquo; and &ldquo;maths ought to stay up in its ivory tower where it belongs and stop getting in the way of good honest engineering&rdquo;.</p>

<p>Aside from being nonsensical, the question is missing the point. For a start, it&rsquo;s not clear that either side of the argument agrees on what math even is. Tragically, most people&rsquo;s exposure to mathematics consists solely of memorising algorithms to solve numerical problems expressed in arcane syntax without reference to anything that they might ever care about. <a href="https://www.maa.org/external_archive/devlin/LockhartsLament.pdf">Lockhart</a> has more and better to say on this topic than I can manage. Suffice to say that most of what you endured in school is the math equivalent of making you compile java into binary in your head for six years without ever showing you a computer or explaining why you might want to write a program in the first place.</p>

<p>But if you can get past the childhood trauma, the poor presentation and the awful syntax there is a whole world of important and beautiful ideas to explore. Mathematics is not about calculation and memorisation, but about building and studying different abstract systems and the connections between them.</p>

<p>Mathematics is:</p>

<ul>
<li>A set of methods for thinking correctly and precisely about abstract systems</li>
<li>A body of knowledge generated by those methods</li>
<li>A collection of conventions, notations and terminology for talking about that knowledge</li>
</ul>


<p><a href="http://worrydream.com/oatmeal/changing-minds.jpg">&ldquo;An average ninth-grade mathematics student plus a particular inscription system yields a material intelligence that surpasses Galileo&rsquo;s intelligence&rdquo;</a></p>

<p>Andy diSessa notes that Galileo&rsquo;s proofs of the laws of uniform motion cover page after page to establish complicated relationships that young students today can express and remember simply as &rsquo;d=vt'. Notation matters. Not the little details of what particular symbols we use or the arrangement of characters but the frameworks within which we hang our ideas. Galileo was one of the greatest minds of his century but his seminal work could today be performed trivially by anyone with a passing knowledge of algebra. This represents a massive increase in humanities collective intelligence.</p>

<p>If you are an experienced programmer, you have likely already developed a natural talent for proof and abstraction. But talent alone has limited use. Knowledge is leverage. For hundreds of years mathematicians have been creating tools for understanding the world; tools that are applicable to almost every human endeavour. Those tools belong to you.</p>

<h1>How to learn</h1>

<p>To gain access to these tools, you must first perform several rituals. These rituals don&rsquo;t just give you access to the body of knowledge accumulated over hundreds of years, they also give you the tools to build your own. Even if the problem you are working on has never been studied before, you can approach it with a huge collection of tools and techniques as well as the experience and confidence to apply them correctly.</p>

<ul>
<li>Ritual 1: Learn to read and write proofs</li>
</ul>


<p>A proof is just an argument which is sufficiently detailed to convince the listener. In most cases the listener is just a more suspicious and pessimistic version of yourself &ndash; suspicious because they have learned that humans are not good at reasoning precisely about abstract structures. As a programmer, you spend a great deal of time forming informal proofs about your code and the systems it interacts with. After all, you have to convince yourself that the code you have written actually does what you want it to do, all the time, on every input. Many of the established practices for writing good code &ndash; separation of concerns, clean interfaces, isolation of effects &ndash; boil down to making reasoning easier by reducing the amount of complexity you have to handle at once.</p>

<p>Anyone who was forced to study mathematics at a university level probably has unpleasant memories of being asked to prove some simple obvious fact in tedious detail. Every pedantic little mistake or ambiguity is picked out and criticised. For many people the whole experience is frustrating and seems pointless.</p>

<p>The goal of this exercise is to debug your thought process. It is surprising how many things are totally obvious and yet not true. How many times have you been convinced that a program is absolutely definitely correct this time only for blatant bugs to emerge within minutes? By becoming conscious of the reasoning process itself and by correcting it&rsquo;s mistakes you can learn to reason correctly and precisely. These skills are initially practiced on the solid ground of trivial theorems so that they are second nature by the time you reach less sure footing.</p>

<p>As your skills develop you can return to more fast-and-loose reasoning most of the time. As <a href="http://terrytao.wordpress.com/career-advice/there%E2%80%99s-more-to-mathematics-than-rigour-and-proofs/">Terence Tao explains</a>, the purpose of rigour is to develop and guide intuition. The working mathematician proceeds in rapid leaps and bounds when on familiar ground, only resorting to careful tiptoeing proofs when in unfamiliar territory. Through practice they develop a good sense of when a detailed proof is needed to catch mistakes and when they can get away with just a sketch and a wave, in the same way that a good programmer knows which code can be churned out in a moment and which needs careful thought, review and testing.</p>

<p>Intuition also guides proof. A student unfamiliar with a particular subject will stumble around trying to construct a proof by brute force but an experienced practitioner will find the correct proof just emerges fully formed in their head as if by magic. To paraphrase <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Rich Hickey</a>: proofs are guard rails &ndash; they are essential for safety but you don&rsquo;t drive by bouncing back and forth off the guard rails. Somehow the image of mathematics has become one of drudgery and endless formality when the reality is a balance between the intuitive leaps of understanding and the pillars of proof that prop them up afterwards.</p>

<ul>
<li>Ritual 2: Learn the language</li>
</ul>


<p>You need at least a passing familiarity with numbers, functions, sets, relations, vectors, matrices, graphs and predicates as well as the syntax used to describe them, their basic properties and how they relate to each other. The amount of knowledge may seem intimidating, but your average math undergraduate learns all this in their first year whilst mostly drunk. You are smarter than them and possibly more sober.</p>

<p>One of the huge benefits of the second ritual is that the knowledge starts to link together. Each fact slots into a huge web with many connections so that you have multiple pathways to remember and understand it. The more different ways you have to look at a subject, the more likely it is that one of them will click and make sense. Theorems and definitions are no longer handed down from on high to be memorized, but seem intuitive and natural because you understand <em>why</em> they are true.</p>

<ul>
<li>Ritual 3: Practice</li>
</ul>


<p>Mathematical theories are tools and only by applying them repeatedly in different contexts will you learn to wield them properly. Like any other skill, mathematical thinking becomes truly powerful when it is so practiced that it no longer requires conscious effort or awareness. It just becomes another lens through which you can see the world.</p>

<p>Read books. Expect this to be hard. Studying maths texts is less like reading a novel and more like trying to unravel a knot. If something doesn&rsquo;t make sense, skip it and come back later. Study it again and again, in different orders. Don&rsquo;t just read passively, <a href="http://web.stonehill.edu/compsci/history_math/math-read.htm">fight back</a>. Can you find concrete examples of each theorem? Can you find counter-examples? Can you find alternate proofs of key theorems? Can you make the result of a theorem stronger by adding more conditions? If you take away conditions, can you prove a weaker version? Why prove this theorem at all &ndash; what does it mean and what problems can you use it to solve?</p>

<p>Find your own puzzles to solve. When walking to work, is it always fastest to take the first green light at an intersection? Does it depend on the timing of the lights? Is it possible to get to work earlier by leaving later to avoid rush hour traffic? If there were half as many cars but they were twice as long, would traffic be better or worse? Would adding more roads relieve traffic by reducing the density or increase traffic by adding more intersections? Write down the proof and send it to a friend. Tear holes in their proofs. Find ways to falsify your own proofs. The only way to know if your foundations are solid is to kick the shit out of them and see if they fall down.</p>

<h1>Where to start</h1>

<p>The high school math syllabus across most of the western world was designed to create rocket scientists. Literally. Trigonometry, laws of motion and calculus gained pride of place during the space race over fears that Soviet schooling was producing superior rocket scientists. Rote calculation and memorisation were vital skills before the advent of computers. It&rsquo;s little surprise that students don&rsquo;t see maths as being relevant to their lives.</p>

<p>The programming world is little better. Any discussion of maths in programming quickly turns to lambda calculus, type theory or category theory. These topics may be interesting in their own right, but the ratio of time-invested to problem-solving-abilities-gained is less than compelling. Automata theory and complexity theory fare a little better but still don&rsquo;t inspire much.</p>

<p>It&rsquo;s easy to forget that programmers do more than program. The entire goal of programming is to solve problems in the real world and maths has been helping solve those problems for hundreds of years in every field. If you want to learn, study whatever you find interesting and apply it to whatever you enjoy doing.</p>

<p>Find a friend to study with. It&rsquo;s easy to get stuck or misunderstand something but the chances of you both making the same mistake is much lower. Talking it over with someone else is often the quickest way to make sense of a problem.</p>

<p>The transition from high school memorise-and-calculate to real problem solving is legendarily jarring. Suddenly there is not a correct path laid out for you but a bewildering swamp which can only be navigated by skilled reasoning. Learning to think and communicate <em>precisely</em> is useful everywhere but is especially vital when reasoning about complex algorithms or concurrent/distributed systems. <a href="http://www.amazon.com/How-Solve-Mathematical-Princeton-Science-ebook/dp/B0073X0IOA/">How To Solve It</a> is a classic text on tactics for solving hard problems in general. <a href="http://www.amazon.com/How-Prove-It-Structured-Approach-ebook/dp/B009XBOBL6">How To Prove It</a> deals more specifically with finding and expressing proofs and also covers the core constructs of mathematics (logic, numbers, sets, relations, functions).</p>

<p>Depending on how long ago you broke up with maths, you may need to brush up on the foundations. If you need to consciously think about basic algebra and logic you won&rsquo;t have enough brain power left over to handle more advanced material. Whenever you get stuck with something, head over to <a href="https://www.khanacademy.org/">Khan Academy</a> and make sure that you are completely fluent in the prerequisites. <a href="https://www.khanacademy.org/math/algebra">Algebra I</a> is especially important. Khan Academy focuses more on developing concrete intuition than on abstraction and rigour so it&rsquo;s a good complement to more theoretical sources.</p>

<h1>Where to go</h1>

<p>You won&rsquo;t live long enough to learn more than a tiny fraction of all there is to know. Ideas have costs in the time it takes to learn them, the amount of maintenance required to remember them and the amount of effort it takes to apply them. Prefer ideas that have a high power-to-cost ratio. Some of my personal favourites:</p>

<ul>
<li><p><strong>Randomised algorithms</strong> are often faster, simpler and easier to understand than the best deterministic algorithms. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.8277">The Power of Two Random Choices</a> gives a laundry list of important applications for one simple idea. <a href="www.amazon.com/Probability-Computing-Randomized-Algorithms-Probabilistic/dp/0521835402/">Probability and Computing</a> covers the entire field from the absolute basics of probability to the most sophisticated modern applications.</p></li>
<li><p><strong>Entropy</strong> is a very simple concept that governs compression and error-correcting codes, without which modern communications would be impossible. <a href="http://cm.bell-labs.com/cm/ms/what/shannonday/shannon1948.pdf">A Mathematical Theory of Communication</a> managed to lay the foundations for an entire field whilst still being readable by anyone with a basic knowledge of probability.</p></li>
<li><p><strong>The possible-worlds model</strong> is a powerful way to reason about distributed algorithms. <a href="www.cs.cornell.edu/home/halpern/papers/usingrak.pdf">Using Reasoning about Knowledge to Analyze Distributed Systems</a> introduces the model and shows how it simplifies reasoning about a variety of famous algorithms and impossibility proofs.</p></li>
<li><p><strong>Denotational design</strong> is a technique for designing composable abstractions. While it is commonly used, the only explicit description I have encountered is in <a href="http://conal.net/papers/type-class-morphisms/">Denotational design with type class morphisms</a>. For a real world example see <a href="http://www.gecode.org/papers/Tack_PhD_2009.pdf">Constraint Propagation &ndash; Models, Techniques, Implementation</a> which smoothly transitions from a simple mathematical model of finite-domain constraints to one of the faster constraint solvers in the world.</p></li>
</ul>


<p>Surf wikipedia. Get a sense the major areas of study in mathematics and what kinds of problems they deal with. That way, when you encounter a new and scary problem you at least know where to look for the solution.</p>

<p>Keep reading. Read textbooks. Read papers. Read <a href="http://terrytao.wordpress.com/career-advice/">blogs</a>. Read <a href="http://www.amazon.com/s/ref=nb_sb_noss_1?url=search-alias%3Daps&amp;field-keywords=martin+gardner">puzzle books</a>. Watch <a href="https://www.youtube.com/user/Vihart">videos</a>.</p>

<p>Play around. Don&rsquo;t limit yourself to learning &lsquo;official&rsquo; theory &ndash; discover and invent new ideas for yourself.</p>

<p>Teach somebody. The best way to really understand something is to try and explain it to someone else.</p>

<p>Enjoy yourself. Life is too short not to.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Imperative thinking and the making of sandwiches]]></title>
    <link href="http://scattered-thoughts.net/blog/2014/07/21/imperative-thinking-and-the-making-of-sandwiches/"/>
    <updated>2014-07-21T14:37:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2014/07/21/imperative-thinking-and-the-making-of-sandwiches</id>
    <content type="html"><![CDATA[<p>People regularly tell me that imperative programming is the natural form of programming because &lsquo;people think imperatively&rsquo;. I can see where they are coming from. Why, just the other day I found myself saying, &ldquo;Hey Chris, I&rsquo;m hungry. I need you to walk into the kitchen, open the cupboard, take out a bag of bread, open the bag, remove a slice of bread, place it on a plate&hellip;&rdquo; Unfortunately, I hadn&rsquo;t specified where to find the plate so at this point Chris threw a null pointer exception and died.</p>

<!--more-->


<p>The truth is that people think in a variety of different ways in different situations. Most people resort to detailed imperative instructions only when describing complicated or unfamiliar tasks (or when explaining how to interact with a machine, which is itself indicative of how pervasive this mindset is in programming). Even then, the resulting communication is unlikely to resemble a perfectly sequential program and will be full of ambiguity, missing steps and contextual assumptions. Anyone who has ever tried to assemble Ikea furniture knows that clearly communicating or precisely following a series of instructions is actually quite difficult. Indeed, one of the hardest things that beginner programmers have to learn is how to break down a task into a series of simple instructions with no ambiguity. It takes years of practice before the process becomes natural, and meanwhile programming courses have a high failure rate.</p>

<p>If we are going to base the design of our tools on poorly thought-out metaphorical comparisons to making lunch then let&rsquo;s at least be realistic about it. &lsquo;Make me a ham sandwich, there is bread in the cupboard&rsquo; will indeed cause Chris to look in the cupboard. But if there is in fact no bread there, instead of exploding he will probably look elsewhere or ask for clarification. Rather than providing detailed instructions, I provide a goal (sandwich) and hints on how to execute it (try looking for bread in the cupboard). Further constraints are inferred from context and general knowledge (the sandwich should be less than one foot long, there should not be mayo all over the counter afterwards). Chris calculates a series of actions that will produce the desired result and modifies that plan as new information and constraints come to light (no bread in the cupboard).</p>

<p>The reason for communicating in this way is that <em>I don&rsquo;t care</em> exactly how the sandwich is made, so long as it is done neatly and quickly. Communicating my exact intent makes the resulting &lsquo;program&rsquo; simpler and more flexible. I may give additional hints and restrictions when they necessary to speed up the process and Chris may ask for clarification if at any point he is unable to plan a path to the goal, but I never have to resort to a full imperative description of the problem.</p>

<p>Today&rsquo;s computers don&rsquo;t have enough contextual knowledge to make me a sandwich but there are lots of domains where this approach excels. The classic example is SQL databases. Rather than specifying exact data-structures and operations, the user specifies a high-level schema and sends descriptions of queries. It is the responsibility of the database to choose storage types, manage concurrent changes and generate query plans. It makes these decisions based on cost models, runtime information and constrained search (e.g., postgres uses a genetic search algorithm to choose efficient plans for large queries). If the database makes bad decisions, the user can help it out by adding size hints, specifying indexes and overriding query plans. So long as the process of turning intent into plans is transparent and interactive there is no need to invoke a <a href="http://c2.com/cgi/wiki?SufficientlySmartCompiler">sufficiently smart compiler</a>. A dumb compiler can do the easy but tedious legwork and the human can supervise and correct mistakes. This saves programmer time, makes the intent of the resulting program easier to understand (because it is not cluttered with irrelevant details) and makes it easier to change parts of the system independently (eg adding an index does not require rewriting all of your queries). There is a reason why SQL databases became a standard storage mechanism &ndash; this model of programming works incredibly well in this domain.</p>

<p>Indeed, the most painful part of using an SQL database is the interface back to purely imperative programming. The <a href="http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch">Object-Relational mismatch</a> is often seen as a failure of SQL databases. But consider the relative strengths and learning curves of the two technologies. SQL is often still used for its original goal: enabling non-programmers to mine data. The database handles choice of serialization protocol, data structures for storage and indexing, query algorithms and manages concurrency. For the majority of applications it makes good enough decisions that the user never needs to provide any hints beyond index choice. Imperative programming, on the other hand, requires the user to handle all of these decisions and requires years of practice before the user can reliably build the same kinds of applications. In that light, it is interesting that the popular trend is towards making databases more like imperative languages (NoSQL, object databases) rather than making programming look more like SQL.</p>

<p>To be clear, SQL is a mess. I claim that it is successful <em>despite</em> its many flaws because of the power of the core ideas:</p>

<ul>
<li>separate goals from plans</li>
<li>separate logical data models from physical data-structures</li>
<li>automatically handle the translation from goals to plans and from logical to physical models</li>
<li>make the translation transparent and allow the user to provide hints or override sections</li>
</ul>


<p>These ideas allow the programming environment to capture the correct level of detail (&lsquo;make me a sandwich&rsquo; rather than &lsquo;go to the kitchen, open the cupboard&hellip;&rsquo;). This separates meaning from optimisation giving both the user and the compiler more leeway to change the operational details of the program without modifying the specification. The transparency allows us to build this without requiring a SufficientlySmartCompiler.</p>

<p>This model is well understood in the database world and is the subject of decades of research. Unfortunately the database world and the programming language world rarely interact and so the results are mostly confined to data management systems and rarely extend to general purpose programming, with the possible exception of the <a href="http://www.infoq.com/presentations/Datalog">recent revival of the datalog family</a>.</p>

<p>So what would a general purpose language look like if it took these ideas to heart? Our current prototype takes inspiration from <a href="http://shaffner.us/cs/papers/tarpit.pdf">Out of the Tar Pit</a> and <a href="http://www.vpri.org/pdf/m2009001_prog_as.pdf">Programming as Planning</a>, using a <a href="http://en.wikipedia.org/wiki/Temporal_logic">temporal logic</a> language to write specifications and a variety of extensible constraint solvers to execute plans. That may sound complicated, but the interface for most users looks like a cross between <a href="https://ifttt.com/">IFTTT</a> and a simplified version of SQL. Like SQL, the compiler is able to make good decisions for simple programs so the user doesn&rsquo;t need to think about data structures, algorithms or concurrency. We haven&rsquo;t yet begun to work on surfacing and altering its decisions in the cases where it needs help, but I&rsquo;m hopeful that by bootstrapping the compiler and by providing <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CB0QFjAA&amp;url=http%3A%2F%2Fdb.cis.upenn.edu%2FDL%2Fwhywhere.pdf&amp;ei=spTJU5jPAcWTyATT8IHgBA&amp;usg=AFQjCNHovRJYd3vBwhtxze_EuL2w6zIT_w&amp;sig2=4oKCgSECEnZnCOB98Tk0Xw&amp;bvm=bv.71198958,d.aWw">data provenance</a> in the IDE we can go a long way towards easing the learning curve on that front too.</p>

<p>There is a lot of hard work still to go but we have finally have the basic core of our system nailed down and have enough working prototypes to be confident that this approach is compelling.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pain we forgot]]></title>
    <link href="http://scattered-thoughts.net/blog/2014/05/17/pain-we-forgot/"/>
    <updated>2014-05-17T09:54:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2014/05/17/pain-we-forgot</id>
    <content type="html"><![CDATA[<p>Much of the pain in programming is taken for granted. After years of repetition it fades into the background and is forgotten. The first step in making programming easier is to be concious of what makes it hard. So let&rsquo;s put ourselves in the shoes of a smart but inexperienced end user trying to build, test and maintain a simple application.</p>

<!--more-->


<p>Anon the intern is charged with managing lunch orders and quickly realises that their job could be done by a computer: Every day at 1000, send each employee an email with a link to a form where they can choose what they want for lunch. At 1200, gather up the replies and email the list to the catering company. At the end of every month, tally up what each person owes and send the list to accounting. While this a simple program, it covers all the basics: data input, validation, error handling, calculation, presentation, communication, reactivity, scheduling, deployment etc. There are probably dedicated apps that cover this particular example but we are more concerned with how an end-user would solve this kind of problem in general and the difficulties they will encounter along the way.</p>

<p>A lot of the problems we will encounter seem unavoidable &ndash; they are forced on us by outside constraints. Most of these constraints though are the product not of deliberate choices but of historical accident. We still program like it&rsquo;s 1960 because there are powerful path dependencies that incentivise pretending your space age computing machine is actually an 80 character tty. We are trapped in a local maximum.</p>

<p>One might also argue that these tools are simple enough once you learn to use them. I would only point out that, emperically, that bar is too high. Despite the clear benefits, the vast majority of the world was chosen to remain illiterate. Even tools for which there is a clear need (eg version control) have largely failed to make a dent. Clearly there is a need for a less hostile programming environment.</p>

<p>It is tempting to believe that this is the best we can do and that programming is naturally this complex. But as we work through our lunch app, consider how little of the work we have to do actually relates to the problem of specifying the application.</p>

<h2>Getting started</h2>

<p>First we need to get a development environment running. Let&rsquo;s try clojure:</p>

<p><code>bash
lein new lunch_app
cd lunch_app
mkdir resources
touch resources/index.html
LightTable resources/index.html # insert script tag for web repl
firefox resources/index.html
LightTable clj/lunch_app/core.clj # server side, fire up compiler, connect to repl
LightTable cljs/lunch_app/core.cljs # client side, connect to web repl
</code></p>

<p>At this point you have already lost 99% of the population and we haven&rsquo;t even touched on css or templates yet. Worse, none of this was discoverable. I happen to already know how to setup a simple client-server web app so all these steps seem obvious to me. But Anon the intern needs to be able to open up Programming and click &lsquo;New Web Form&rsquo;. Intellij does a reasonable job on this front &ndash; you can start a new web project, compile and open the result in a browser in a few button clicks. But in most environments you need a tutorial just to start a new project.</p>

<h2>Finding help</h2>

<p>So Anon is now staring at a blinking cursor on a blank editor page. What next? How does one go about making a web form, or send a email? For common tasks google will probably find you entire code samples or at the very least some javadocs. The samples will be missing lots of implicit information such as how to install the necessary libraries and how to deal with missing dependencies and version conflicts. Transcribing and modifying the examples may lead to bugs that suck up time. It&rsquo;s not terrible, mostly thanks to sites like stackoverflow, but it&rsquo;s still a lot of unnecessary distractions from the task at hand.</p>

<p>I want to just type &lsquo;email&rsquo; and see a list of functions and libraries relating to email. If I select a function from autocomplete, its dependencies should be automatically added to the project without any fuss. Missing dependencies or version conflicts should be presented alongside suggestions for resolution (click here to choose version A). <a href="http://blogs.msdn.com/b/visualstudio/archive/2014/02/17/introducing-bing-code-search-for-c.aspx">Bing Code Search</a> takes this idea even further and autocompletes code for common tasks.</p>

<h2>Writing code</h2>

<p>Even for experts, programming is an exploratory process. We experiment with libraries, run through examples and iteratively build up features. One of the most painful lessons beginners have to learn is just how often everyone is wrong about everything. Tightening the feedback loop between writing code and seeing the results reduces the damage caused by wrong assumptions, lightens the cognitive load of tracking what should be happening and helps build accurate mental models of the system. The latter is especially important for beginners who often suffer from miscomprehensions about even the basic semantics of the language. Unfortunately, the most you are likely get is automatically refreshing your browser. Maybe a REPL if you are lucky.</p>

<p>Imagine a spreadsheet where every time you change something you must open a terminal, run the compiler and scan through the cell / value pairs in the printout to see the effects of your change. We wouldn&rsquo;t put up with UX that appalling in any other tool but somehow that is still the state of the art for programming tools. I suspect a lot of the blame lies in our failure to find a model for GUI tools that is as flexible and composable as plain text. I see a lot of potential in Paul Chiusano&rsquo;s ideas for <a href="http://pchiusano.blogspot.com/2013/05/the-future-of-software-end-of-apps-and.html">killing the application</a> and in Eskil Steenburgs <a href="https://www.youtube.com/watch?feature=player_detailpage&amp;v=f90R2taD1WQ#t=1837">Verse</a>.</p>

<p>Light Table at least gives you <a href="https://www.youtube.com/watch?v=gtXpOD6jFls">inline eval</a>, <a href="https://www.youtube.com/watch?v=d8-b6QEN-rk">watches</a> and the <a href="https://www.youtube.com/watch?v=YY6B9EHbH24">instarepl</a>. This type of interaction is taken further by ideas like <a href="http://gbracha.blogspot.com/2012/11/debug-mode-is-only-mode.html">Debug Mode is the Only Mode</a> and <a href="http://www.subtext-lang.org/OOPSLA04.pdf">Example Centric Programming</a>). Instead of having a separate editor, compiler, repl, debugger etc you develop everything by editing code in the debugger. It is a similar idea to JIT compilers &ndash; the IDE has more information available at runtime then at compile time so it can make better decisions and provide better feedback (eg by generating example inputs and outputs as you write a function).</p>

<p>Plain text is also very limiting. Language is very good for conveying meaning but not so great for displaying data. Being able to quickly throw up graphs and diagrams (like in <a href="https://github.com/ztellman/rhizome">rhizome</a>, <a href="https://github.com/ztellman/automat">automat</a> or <a href="https://github.com/ztellman/lamina/wiki/Channels">lamina</a>) is incredibly useful. Light Table&rsquo;s <a href="http://www.chris-granger.com/images/040/ipygraphs.png">inline graphs</a> are a start but we haven&rsquo;t otherwise made much use of visualisation. First person to implement inline graphviz gets a cookie.</p>

<h2>Running code</h2>

<p>Surprisingly, one of the most common difficulties we have heard from beginners is just running code. Even if we were to hand Anon the entire lunch_app source code they would likely still struggle to actually use it. They have to install dependencies, compile code, start servers and open ports. At each step the errors are difficult to diagnose and time-consuming to fix. The tools that are intended to fix this are often even worse themselves (every time I write a blog post in octopress I find rvm has somehow broken again). IDEs like Intellij and Visual Studio do a reasonable job of standardising the build process and capturing dependencies so that it is usually possible to import a project and just hit run, but that only goes as far as development. For deployment we have tools like Docker which make deployment highly repeatable but don&rsquo;t help much with capturing the process in the first place. None of these really help Anon the intern deploy lunch_app.</p>

<p>The lunch app is going to need scheduling too, and error logging and monitoring. Anon needs to be alerted if the emails don&rsquo;t go out or if there are no reponses. Setting up even the simplest logging, monitoring and restarting is a hassle even for professional programmers.</p>

<p>Wolfram&rsquo;s Language <a href="https://www.wolfram.com/universal-deployment-system/">workflow</a> is pretty close to ideal. You work in a notebook where code runs and updates instantly with no manual compile step. Deploying to a cloud server is just a single function call which automatically collects code and dependencies and returns a url where your program is now running. No need to think about files or libraries, no project files, no build artefacts, no messing about setting up servers and opening ports.</p>

<p>From there it doesn&rsquo;t take much imagination to add easy task scheduling and an error logger that emails Anon when something goes wrong. None of this requires giving up control either. You could just as easily replace &lsquo;cloud server&rsquo; with &lsquo;departmental server&rsquo; or &lsquo;little black box that came with our internet&rsquo;. The important point is that there are sensible defaults for deployment and that it is &lsquo;batteries included&rsquo; in the language or IDE.</p>

<h2>What?</h2>

<p>The simplest question we could ask about our application is &lsquo;what is the current state&rsquo;. Bizaarely, very few programming environments give you any help on this front. Many programmers get by with nothing but print statements. If you are lucky you may have a debugger or watches, but you still end up looking at your application through a keyhole. You have to actively insert instrumentation by hand to view the state of each tiny part of the application. If you want to modify that state you have to mentally work backwards and construct the correct piece of code to find and change the variable that you are looking at. It may not even have a name that is accessible from the repl (eg a variable in an anonymous closure). Viewing and modifying the state of the application should be a fundamental interaction and yet it&rsquo;s made unreasonably difficult by our languages and tools.</p>

<p>Compare this to a tool like Excel or <a href="http://www.youtube.com/watch?v=kvFDV1oM-ZA">Django Admin</a> where <em>all</em> the data is laid out for easy browsing without any active effort from the user and can be <em>directly</em> modified just by clicking and typing. The tooling itself isn&rsquo;t difficult but it requires rethinking the way we manage state in programming languages. All mainstream languages, regardless of paradigm, encourage <a href="http://scattered-thoughts.net/blog/2014/02/17/local-state-is-harmful/">anonymous local state</a> which can&rsquo;t be easily observed and modified.</p>

<p>Once we have managed state, whether using a relational model like <a href="http://bloom-lang.net/">Bloom</a> or more traditional functional data-structures like <a href="http://infoscience.epfl.ch/record/136776">Opis</a>, we can easily record history too. Tools like <a href="http://chrononsystems.com/products/chronon-time-travelling-debugger">time travelling debuggers</a> that require huge engineering effort in traditional languages become trivial when you can cheaply record or reconstruct the past. Reproducing bugs is easier when you can just snapshot your history and mail it to the developer. Bloom and Opis are also both able to determine dataflow topologies from source code so when stepping into an unfamiliar project you can quickly get a visual overview of how the various components communicate (examples are buried <a href="http://db.cs.berkeley.edu/papers/cidr11-bloom.pdf">here</a> and <a href="http://infoscience.epfl.ch/record/136776/files/DagandETAL09Opis.pdf">here</a>).</p>

<h2>Why?</h2>

<p>Traditional debuggers focus entirely on the <em>what</em> &ndash; walking through a narrow slice of state on step at a time. But when debugging the question one usually starts with is <em>why</em>? Why are the lunch options in the wrong order? Why didn&rsquo;t the lunch email go out? Why is everyones bill for the month zero? These questions typically involve reasoning backwards from effect to cause whereas debuggers walk you forward from cause to effect. The result is that debugging consists mostly not of finding the problem but manually walking backwards along the chain of causes by setting up isolated test cases and repeatedly rerunning them under the debugger.</p>

<p><a href="http://blog.brackets.io/2013/08/28/theseus-javascript-debugger-for-chrome-and-nodejs/">Theseus</a> improves on this slightly by capturing arguments at the entrace to each event callback, so that you don&rsquo;t have to repeatedly rerun. Ko and Myer&rsquo;s <a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=1165&amp;context=hcii">causal debugger</a> explicitly answers the questions <em>why</em> and <em>why not</em> by tracing the tree of causes for each state change, so that the process of walking backwards from effect to cause is entirely automated and you can just focus on figuring out where things went wrong.</p>

<p>The problem gets even worse with scale. Debugging by following control flow works poorly in large systems where what really matters is <em>data flow</em>. Answering questions like &lsquo;why do orders sometimes get lost&rsquo; requires tracing through an enourmous graph, one which is not even recorded in most systems and instead has to be inferred from logs, like piecing together ancient civilisations from broken pottery. <a href="http://db.cs.berkeley.edu/papers/eurosys10-boom.pdf">BOOM analytics</a> deals with this by reflecting all data, from error logs and persistent data to message queues and profiling data, into relational tables that are made available to overlog &ndash; the same distributed query language that runs the rest of the system. This means you can directly run queries over the causality graph, such as &lsquo;for each order that was entered into the system but not completed, give me a list of every message was linked to that order by some chain of rules&rsquo;. Since the recording of this data was itself governed by overlog rules you can switch on detailed logging at runtime for specific kinds of data eg &lsquo;record all messages concerning order 197 originating from cluster C and forward them to me&rsquo;.</p>

<h2>Change</h2>

<p>Outside of the software world, version control and collaboration software is limited to saving lunch_app.v07 and attaching it to an email. Collaborating on a single project is difficult and slow. The standard tools of the trade for programmers (git, mercurial etc) are vastly more powerful and solve a pressing problem but present an interface that <a href="http://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/">baffles and frustrates many users</a>. The underlying model is elegant and powerful but even the graphical interfaces require a significant investment of time and effort to understand.</p>

<p>What Anon needs is somewhere between <a href="http://www.emacswiki.org/emacs/UndoTree">undo-tree</a> (without the ascii art) and <a href="http://etherpad.org/">etherpad</a>. Changes should be automatically recorded and (optionally) retroactively tagged with commit messages. Real-time collaboration should be as simple as clicking on a coworkers face. Undoing changes and checking out different versions should just be a matter of moving around on the <a href="https://github.com/blog/39-say-hello-to-the-network-graph-visualizer">commit graph</a>. Dragging a piece of code out of the editor should produce a link to the VCS page for that code. If the editor understands the structure of the code we even can track semantic changes to individual units of code (eg rename function, reorder expressions) rather than diffing text in a file, making both automatic and manual merges easier since we have a better record of the intent of the change.</p>

<p>Similary, when Anon 2 the accountant wants to modify their client-side copy of the lunch form to remember their favourite lunches it should be a simple process. No hunting down and recompiling system binaries, no installing greasemonkey scripts from the filesystem. Just click to open the source, modify to your satisfaction, click to save. I&rsquo;ve never seen anything come close to this basic interaction. The <a href="http://blog.printf.net/articles/2006/10/29/the-view-source-key/">OLPC view source button</a> promised exactly this experience but as far as I know it never materialised (it certainly didn&rsquo;t work on mine).</p>

<h2>Learning</h2>

<p>Programming tools generally pay very little attention to producing helpful error messages (with <a href="http://cs.brown.edu/~sk/Publications/Papers/Published/mfk-measur-effect-error-msg-novice-sigcse/paper.pdf">one</a> or <a href="http://research.microsoft.com/pubs/64590/helium.pdf">two</a> exceptions). There is a modest amount of <a href="http://www.amazon.com/Man-Who-Lied-His-Laptop-ebook/dp/B003YUC7BI/ref=sr_1_1?ie=UTF8&amp;qid=1400099030&amp;sr=8-1&amp;keywords=man+who+lied+to+his+laptop">evidence</a> that people interact with computers as if they were people. Many of the results of this research are suprising and counter-intuitive eg <a href="http://faculty.washington.edu/ajko/papers/Lee2011Gidget.pdf">personifying the compiler</a> can improve learning rates in students. Given that, do you really want to spend lots of time with the kind of person who just repeatedly shouts &lsquo;cannot call method undefined of undefined!&rsquo; in your face without so much as hinting how you might fix the problem or where you might start looking?</p>

<p>Our programming environments are absurdly hostile. Interfaces either <a href="http://www.suggestsoft.com/images/quest-software/comparerocket-for-visual-studio.gif">overwhelm with detail</a> or <a href="http://i.stack.imgur.com/VqPMv.png">hide everything</a>. Most actions cannot be undone (eg changing a variable, defining a function, installing a library). Runtimes default to exiting on uncaught exceptions, throwing away all the context that would be useful for solving the problem and forcing the user to try to recreate the crashing state. When any action can lead to confusing breakage and ruined work, inexperienced users suffer from fear and paralysis and an unwillingness to experiment. This cripples their ability to learn.</p>

<p>Error messages should at the very least identify what might have caused the error and preferably offer options for fixing it. Intellij, for example, will highlight spelling mistakes and offer to correct them (&ldquo;did you mean&hellip;&rdquo;). Good end user applications will link common errors to FAQs. Suggestions don&rsquo;t need to be perfect, just accurate. Everyone hated Clippy because his advice was useless and repetitive and lacked context. The golden rule is if you don&rsquo;t have something useful to say, don&rsquo;t say nothing at all. One ambitious project (ref?) crowd-sourced examples of causes of and solutions to type-checking errors. Large-scale data collection and testing may end up being the best path to providing helpful feedback.</p>

<p>Environments also need to be more proactive. Uncaught errors should drop the user into the debugger where they can <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">edit and continue</a>. Editors can spot common mistakes and suggest corrections (Intellij is pretty good at this, as is <a href="https://github.com/jonase/kibit">kibit</a>, but many people are still working with editors that don&rsquo;t even warn them of typos or shadowed variables). Profilers can heuristically explore bottlenecks and suggest solutions (eg if foo was indexed this query would run 10x faster). Rather than rely on users to create their own tests we can prompt them for examples and invariant properties and <a href="www.scs.stanford.edu/11au-cs240h/notes/testing-slides.html">search for counter-examples</a>. <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0CD0QFjAC&amp;url=http%3A%2F%2Finfoscience.epfl.ch%2Frecord%2F136776&amp;ei=gNpzU7yeKMTesASLr4KoCA&amp;usg=AFQjCNGyqXOAavdVfGxGuBFZbTzobRmXtQ&amp;sig2=jvF_qeyNTyCOffdJkC-twA&amp;bvm=bv.66917471,d.cWc">Opis</a> comes equipped with a profiler that automatically estimates the asymptotic complexity of each function in the model and a finite-state model checker that can prove invariants always hold by efficiently and exhaustively checking every possible state. Bloom features a <a href="http://db.cs.berkeley.edu/papers/dbtest12-bloom.pdf">generative testing framework</a> that uses an SMT solver to efficiently explore the space of possible and a <a href="http://www.bloom-lang.net/calm/">static analysis pass</a> that warns of missed coordination points in distributed programs. Does your IDE even run your unit tests for you?</p>

<p>Finally, environments can&rsquo;t be black boxes. Beginners need a simple experience but if they are to become experts they need to be able to shed the training wheels and open the hood. Many attempts at end-user programming failed because they assumed the user was stupid and so wrapped everything in cotton wool. Whenever we provide a simplified experience, there should be an easy way to crack it open and see how it works. Nothing should be magic forever. Ensure that the users curiousity is never frustrated and they won&rsquo;t need teaching for long.</p>

<h2>Plans</h2>

<p>Some of the things I have described are just a matter of paying attention to the details. Others require doing things very differently. The key parts of our plan for Aurora are:</p>

<ul>
<li>storing code in a networked database with version control and realtime sync</li>
<li>a <a href="http://en.wikipedia.org/wiki/Structure_editor">structured editor</a> to enable rich ASTs with unique UUIDs</li>
<li>managing environments declaratively so that evaluating code is always safe</li>
<li>a uniform (logical) data model where every piece of state is globally addressable</li>
<li>a model for change that tracks history and causality</li>
<li>a powerful query language that can be used for querying code, runtime state, causal graphs, profiling data etc</li>
<li>composable gui tools with transparent guts</li>
<li>a smooth interface to the old world so we don&rsquo;t end up sharing a grave with smalltalk</li>
</ul>


<p>We will dive into these in more detail in the coming months.</p>

<p>None of this will be at all easy, but it&rsquo;s no harder than continuing what we are doing now and much of the groundwork has already been laid if you know where to look. If one thing is certain, it is that the future is not 80 characters wide.</p>
]]></content>
  </entry>
  
</feed>
