<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: strucjure | Scattered Thoughts]]></title>
  <link href="http://scattered-thoughts.net/blog/categories/strucjure/atom.xml" rel="self"/>
  <link href="http://scattered-thoughts.net/"/>
  <updated>2014-02-17T05:45:39+00:00</updated>
  <id>http://scattered-thoughts.net/</id>
  <author>
    <name><![CDATA[Jamie Brandon]]></name>
    <email><![CDATA[jamie@scattered-thoughts.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Strucjure: motivation]]></title>
    <link href="http://scattered-thoughts.net/blog/2012/12/04/strucjure-motivation/"/>
    <updated>2012-12-04T02:31:00+00:00</updated>
    <id>http://scattered-thoughts.net/blog/2012/12/04/strucjure-motivation</id>
    <content type="html"><![CDATA[<p>I feel that the readme for <a href="https://github.com/jamii/strucjure">strucjure</a> does a reasonable job of explaining how to use the library but not of explaining why you would want to. I want to do that here. I&rsquo;m going to focus on the motivation behind strucjure and the use cases for it rather than the internals, so try not to worry too much about how this all works and just focus on the ideas (the implementation itself is <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">very simple</a> but liable to keep changing).</p>

<!--more-->


<p>The core idea is that strucjure (and the <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;ved=0CFIQFjAD&amp;url=http%3A%2F%2Flambda-the-ultimate.org%2Fnode%2F2477&amp;ei=lQ69UJqrLK-WyAHC1IGIBg&amp;usg=AFQjCNEJAMQULpZ62ASYefNHadlUWTlgKA&amp;sig2=E1ePKzLJJNaFw5BfEG9rrA">OMeta</a> library on which it is based) is not just yet-another-parser, but is instead a concise language for describing, manipulating and transforming data structures. The <a href="http://www.vpri.org/">VPRI</a> folks have done some amazing things with OMeta. My goal with strucjure is to see how much further this idea can be taken.</p>

<p>(Note: For the purposes of this post I&rsquo;ll use the terms pattern and view interchangeably. There <em>is</em> a difference, but the line between the two is not yet clear to me and will probably change in future implementations)</p>

<h1>Pattern matching</h1>

<p>Pattern matching is a concept found in many functional languages. The basic idea is something like a switch statement, combined with a mini-language for describing patterns which the input should be tested against. The first pattern which matches has its corresponding branch executed.</p>

<p>As a very simple example, we can use strucjure to write fizzbuzz like this:</p>

<p>``` clojure
(doseq [i (range 100)]
  (prn
   (match [(mod i 3) (mod i 5)]</p>

<pre><code>      [0 0] "fizzbuzz"
      [0 _] "fizz"
      [_ 0] "buzz"
      _      i)))
</code></pre>

<p>```</p>

<p>This is a concise, readable description of the various cases and replaces a chain of if-statements.</p>

<p>If we stopped there, you could be forgiven for not caring. Simple examples don&rsquo;t really demonstrate the power of pattern matching. Let&rsquo;s instead look at a more complicated example &ndash; <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black trees</a>. An important operation on red-black trees is re-establishing the balance invariants after inserting a new node. Here is a java implementation of the balance operation (from <a href="http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">this implementation</a>):</p>

<p>``` java</p>

<pre><code>// make a left-leaning link lean to the right
private Node rotateRight(Node h) {
    assert (h != null) &amp;&amp; isRed(h.left);
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = x.right.color;
    x.right.color = RED;
    x.N = h.N;
    h.N = size(h.left) + size(h.right) + 1;
    return x;
}

// make a right-leaning link lean to the left
private Node rotateLeft(Node h) {
    assert (h != null) &amp;&amp; isRed(h.right);
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = x.left.color;
    x.left.color = RED;
    x.N = h.N;
    h.N = size(h.left) + size(h.right) + 1;
    return x;
}

// flip the colors of a node and its two children
private void flipColors(Node h) {
    // h must have opposite color of its two children
    assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);
    assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))
        || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));
    h.color = !h.color;
    h.left.color = !h.left.color;
    h.right.color = !h.right.color;
}

// restore red-black tree invariant
private Node balance(Node h) {
    assert (h != null);

    if (isRed(h.right))                      h = rotateLeft(h);
    if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left) &amp;&amp; isRed(h.right))     flipColors(h);

    h.N = size(h.left) + size(h.right) + 1;
    return h;
}
</code></pre>

<p>```</p>

<p>This pile of if-statements obscures the intent of the code, which is to re-arrange the tree so that no red node has a red child. What we really want to see is &lsquo;if the tree looks like foo, replace it with bar&rsquo;. Using pattern matching we can express this directly (code based on <a href="http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec11.html">this implementation</a>):</p>

<p>``` clojure
(defrecord Leaf [])
(defrecord Red [left value right])
(defrecord Black [left value right])</p>

<p>(defview balance
  ;; if it looks like one of these&hellip;
  (or
   (Black. (Red. (Red. ?a ?x ?b) ?y ?c) ?z ?d)
   (Black. (Red. ?a ?x (Red. ?b ?y ?c)) ?z ?d)
   (Black. ?a ?x (Red. (Red. ?b ?y ?c) ?z ?d))
   (Black. ?a ?x (Red. ?b ?y (Red. ?c ?z ?d))))
  ;; replace it with this&hellip;
  (Red. (Black. a x b) y (Black. c z d))</p>

<p>  ;; otherwise, leave it alone
  ?other
  other)
```</p>

<p>(Note that this isn&rsquo;t exactly the same operation as the code above, because the corresponding implementation has a slightly different insert algorithm too. Nevertheless, converting this operation to java would result in the same grotesque expansion of if-statements).</p>

<p>Strucjure is not very optimized yet, but if you use a more mature pattern-matching library then this code would be as fast as what you would write by hand. For complex patterns <a href="https://github.com/clojure/core.match">core.match</a> often does a better job of optimizing the decision tree than I can manage by hand, in much the same way that GCC does a better job of writing assembly code than I ever could.</p>

<p>Strucjure patterns are first-class values and can call other patterns or recursively call themselves, so they can express much more complex patterns than other pattern matchers. For example:</p>

<p>``` clojure
(defview balanced-height
  Leaf
  0</p>

<p>  (and (Black. _</p>

<pre><code>     (balanced-height ?l)
     (balanced-height ?r))
   #(= l r))
</code></pre>

<p>  (+ 1 l)</p>

<p>  (and (Red. _</p>

<pre><code>     (and (not Red) (balanced-height ?l))
     (and (not Red) (balanced-height ?r)))
   #(= l r))
</code></pre>

<p>  l)
```</p>

<p>This is a pattern which only matches balanced red-black trees, by recursively matching against each branch and returning the number of black nodes per path (see property 5 <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Properties">here</a>).</p>

<h1>Parsing</h1>

<p>Strucjure supports patterns which only consume part of the input and can chain these patterns together. Combine that with pattern matching and you can very easily write back-tracking recursive-descent parsers.</p>

<p>We can use this for traditional text parsing (you have to be feeling a little masochistic at the moment because strucjure can&rsquo;t directly handle strings yet, only sequences of \c \h \a \r \s). For example, strucjure <a href="http://scattered-thoughts.net/blog/2012/10/25/strucjure-reading-the-readme/">parses its own readme</a> to ensure all the examples are correct.</p>

<p>Parsing doesn&rsquo;t have to be limited to text. We can apply the same techniques to any sequential data structure.</p>

<p>``` clojure
user> (defnview zero-or-more-prefix [elem]</p>

<pre><code>    (prefix &amp; (elem ?x) &amp; ((zero-or-more-prefix elem) ?xs)) (cons x xs)
    (prefix ) nil)
</code></pre>

<h1>&lsquo;user/zero-or-more-prefix</h1>

<p>user> (defview self-counting</p>

<pre><code>    (prefix 1) 'one
    (prefix 2 2) 'two
    (prefix 3 3 3) 'three)
</code></pre>

<h1>&lsquo;user/self-counting</h1>

<p>user> (run (zero-or-more-prefix self-counting) [1 3 3 3 2 2 1 2 2])
(one three two one two)
```</p>

<p>Since we live in lisp land, code is data too. We can use strucjure to easily and <em>readably</em> (hopefully) operate over sexps.</p>

<p>``` clojure
;; generic parser for (right-binding) infix operators with precedence</p>

<p>(defn value? [all form]
  (not-any? #(contains? % form) all))</p>

<p>(defn bind* [all current]
  (if-let [[ops &amp; tighter] current]</p>

<pre><code>(view
 (prefix &amp; ((bind* all tighter) ?x) (and #(contains? ops %) ?op) &amp; ((bind* all current) ?y)) `(~op ~x ~y)
 (prefix &amp; ((bind* all tighter) ?x)) x)
(view
 (prefix [((bind* all all) ?x)]) x
 (prefix (and #(value? all %) ?x)) x)))
</code></pre>

<p>(defn bind [binding-levels]
  (bind* binding-levels binding-levels))</p>

<p>;; run &lsquo;bind with basic arithmetic precedences
(defmacro math [&amp; args]
  (run (bind [#{&rsquo;+ &lsquo;&ndash;} #{&rsquo;* &lsquo;/}]) args))</p>

<p>(macroexpand &lsquo;(math 1 &ndash; 2 + 3 &ndash; 4))
;; (&ndash; 1 (+ 2 (&ndash; 3 4)))
(macroexpand &rsquo;(math 1 + 2 * 7 + 1 / 2))
;; (+ 1 (+ (<em> 2 7) (/ 1 2)))
(macroexpand &lsquo;(math 1 + 2 * (7 + 1) / 2))
;; (+ 1 (</em> 2 (/ (7 + 1) 2)))
```</p>

<p>No more death-by-polish-notation!</p>

<p>(The operators above really ought to bind to the left but, unlike ometa, strucjure doesn&rsquo;t yet support <a href="http://en.wikipedia.org/wiki/Left_recursion">left-recursion</a> and I&rsquo;m too lazy to manually transform the grammar. It&rsquo;s a temporary limitation.)</p>

<p>Taking this to its logical conclusion, the syntax for patterns and views in strucjure is itself defined <a href="https://github.com/jamii/strucjure/blob/master/src/strucjure/parser.clj#L178">using views</a>. This is a fairly complex DSL but with strucjure it&rsquo;s was very easy to write, read and modify the parser.</p>

<h1>Generic programming</h1>

<p>Clojure has some great facilities for generic traversals in the form of clojure.walk:</p>

<p>``` clojure
(defn walk
  &ldquo;Traverses form, an arbitrary data structure.  inner and outer are
  functions.  Applies inner to each element of form, building up a
  data structure of the same type, then applies outer to the result.
  Recognizes all Clojure data structures. Consumes seqs as with doall.&rdquo;</p>

<p>  {:added &ldquo;1.1&rdquo;}
  [inner outer form]
  (cond
   (list? form) (outer (apply list (map inner form)))
   (instance? clojure.lang.IMapEntry form) (outer (vec (map inner form)))
   (seq? form) (outer (doall (map inner form)))
   (coll? form) (outer (into (empty form) (map inner form)))
   :else (outer form)))</p>

<p>(defn postwalk
  &ldquo;Performs a depth-first, post-order traversal of form. Calls f on
each sub-form, uses f&rsquo;s return value in place of the original.
Recognizes all Clojure data structures except sorted-map-by.
Consumes seqs as with doall.&rdquo;
  {:added &ldquo;1.1&rdquo;}
  [f form]
  (walk (partial postwalk f) f form))
```</p>

<p>Essentially, all this is doing is specifying how to take apart clojure data structures and how to put them back together again. Strucjure supports passing optional :pre-view and :post-view functions to modify the input to or output from any named view encountered during parsing, so we can do something very similar:</p>

<p>``` clojure
(defview clojure
  (and list? ((zero-or-more clojure) ?xs)) xs
  (and clojure.lang.IMapEntry [?x ?y]) [x y]
  (and seq? ((zero-or-more clojure) ?xs)) xs
  (and coll? ?coll ((zero-or-more clojure) ?xs)) (into (empty coll) xs)
  ?other other)</p>

<p>(defn postwalk [form f]
  (run clojure form {:post-view (fn [_ sub-form] (f sub-form)}))
```</p>

<p>The problem with using this (or clojure.walk) for generic traversals is that it loses context. When a given sub-form is encountered, the function f is given no indication of where in the data structure that sub-form is or how it is being used. If we apply the above idea to domain-specific views we can do generic traversals <em>with context</em>. The motivating example for this was a simple game I was porting called <a href="https://github.com/jamii/l-seed">l-seed</a> (I haven&rsquo;t yet updated l-seed to use strucjure, but you can see a precursor to it in <a href="https://github.com/jamii/l-seed/blob/master/src/l_seed/syntax.clj">l-seed.syntax</a>). In l-seed, players submit programs defining the growth of their plant species and compete with other player&rsquo;s plants for sunlight and nutrients. The plant language can be defined like this:</p>

<p>``` clojure
(defview +name+
  string? %)</p>

<p>(defview +tag+
  string? %)</p>

<p>(defview +length+
  (and number? #(&lt;= 0 %)) %)</p>

<p>(defview +direction+
  (and number? #(&lt;= -360 % 360)) %)</p>

<p>(defview +relation+
  (or &lsquo;= &rsquo;> &lsquo;>= &rsquo;&lt; &lsquo;&lt;=) %)</p>

<p>(defview +property+
  (or &lsquo;tag 'length 'direction) %)</p>

<p>(defview +condition+
  [&lsquo;and &amp; ((zero-or-more +condition+) ?conditions)] (cons 'and conditions)
  ['or &amp; ((zero-or-more +condition+) ?conditions)] (cons 'or conditions)
  ['not (+condition+ ?condition)] (list 'not condition)
  [(+relation+ ?relation) (+property+ ?property) ?value] (list relation property value))</p>

<p>(defview +condition-head+
  [&lsquo;when (+condition+ ?condition)] (list 'when condition)
  'whenever 'whenever)</p>

<p>(defview +action+
  [&lsquo;grow-by (+length+ ?length)] (list 'grow-by length)
  ['turn-by (+direction+ ?direction)] (list 'turn-by direction)
  ['turn-to (+direction+ ?direction)] (list 'turn-to direction)
  ['tag (+tag+ ?tag)] (list 'tag tag)
  ['blossom (+tag+ ?tag)] (list 'blossom tag)
  ['branch &amp; ((zero-or-more (zero-or-more +action+)) ?action-lists)] (cons 'branch action-lists))</p>

<p>(defview +rule+
  [&lsquo;rule (+name+ ?name) (+condition-head+ ?condition-head) &amp; ((zero-or-more +action+) ?actions)] (apply list 'rule name condition-head actions))</p>

<p>(defview +rules+
  [&amp; ((zero-or-more +rule+) ?rules)] rules)
```</p>

<p>(Note that we specify both how to take apart a data structure and how to put it together. Really, the latter should be derived from the former. I think strucjure will eventually feature reversible patterns for this purpose.)</p>

<p>We can then operate on these programs in a generic way. For example, deciding which rule to execute next:</p>

<p>``` clojure
(defn select* [properties]
  (defview</p>

<pre><code>[`+relation+ ?relation] (resolve relation)
[`+property+ ?property] (get properties property)
[`+condition+ ['and &amp; ?conds]] (every? true? conds)
[`+condition+ ['or &amp; ?conds]] (some true? conds)
[`+condition+ ['not ?cond]] (not cond)
[`+condition+ [?relation ?property ?value]] (relation property value)
[`+condition-head+ ['when ?condition]] condition
[`+condition-head+ ['whenever]] true
[`+rule+ ['rule _ ?condition &amp; ?actions]] (when condition actions)
[`+rules+ [&amp; ?rules]] (choose (filter seq rules))
[_ ?other] other))
</code></pre>

<p>(defn select [rules properties]
  &ldquo;Pick a valid rule and return its list of actions (or nil if no rules are valid)&rdquo;
  (utilpostwalk +rules+ rules (select* properties)))
```</p>

<p>Writing code like this allows us to separate the shape of the data from the computation we perform over it.</p>

<p>We&rsquo;re also not limited to just walking over data structures. We can perform more complex operations in the same generic fashion.</p>

<p>``` clojure
(defn map-reduce [strucjure form map-op reduce-op]
  &ldquo;Call map-op on every sub-form and reduce results with reduce-op&rdquo;
  (let [acc (atom (reduce-op))]</p>

<pre><code>(run strucjure form
       {:post-view (fn [name form]
                     (swap! acc reduce-op (map-op name form))
                     form)})
@acc))
</code></pre>

<p>(defn collect [strucjure form filter-op]
  &ldquo;Return all sub-forms satisfying filter-op&rdquo;
  (let [acc (atom nil)]</p>

<pre><code>(run strucjure form
       {:post-view (fn [name form]
                     (if (filter-op name form)
                       (swap! acc conj result)))})
@acc))
</code></pre>

<p>```</p>

<h1>Types</h1>

<p>I originally learned to code in haskell. One of the things I miss about strong static typing is it that it automatically provides documentation about the data structures used in your program. Strucjure patterns can fulfill the same role. In l-seed, if you are confused about what a rule should look like you can just go look at the +rule+ pattern.</p>

<p>We can&rsquo;t quite get static typing out of this, but we do get runtime checking for complex typedata-structures:</p>

<p><code>clojure
(defmacro defgenotype [name &amp; rules]
  ;; compile-time syntax check for the genotype language
  (run +rules+ rules)
  `(def ~name '~(vec rules)))
</code></p>

<p>In theory, it should also be possible to generate random data structures satisfying a given pattern. This would be useful for providing examples and for <a href="https://github.com/clojure/test.generative">generative testing</a>. In erlang, <a href="https://github.com/manopapad/proper">proper</a> allows using type-specs directly alongside hand-written generators. I haven&rsquo;t yet implemented this in strucjure but I think it should be reasonably easy once reversible patterns are implemented.</p>

<h1>State machines</h1>

<p>One can think of parsers in general as state machines with look-ahead and backtracking. OMeta takes this idea and runs with it:</p>

<blockquote><p>Most  interesting  ideas  have  more  than  one  fruitful  way  to  view  them,  and  it  occurred  to  us  that,
abstractly,  one  could  think  of  TCP/IP  as  a  kind  of  “non‐deterministic  parser  with  balancing
heuristics”,  in  that  it  takes  in  a  stream  of  things,  does  various  kinds  of  pattern‐matching  on  them,
deals with errors by backing up and taking other paths, and produces a transformation of the input in
a specified form as a result.</p>

<p>Since the language transformation techniques we use operate on arbitrary objects, not just strings (see
above), and include some abilities of both standard and logic programming, it seemed that this could
be used to make a very compact TCP/IP. Our first attempt was about 160 lines of code that was robust
enough to run a website. We think this can be done even more compactly and clearly, and we plan to
take another pass at this next year.</p></blockquote>

<p>I haven&rsquo;t yet tried doing anything like this in strucjure, but all the machinery is there. It would make an interesting complement to <a href="https://github.com/jamii/droplet">droplet</a>.</p>

<h1>Moving forward</h1>

<p>There are of lot of different directions for improvement and experimentation.</p>

<p>One of my top priorities is better error reporting. This sucks:</p>

<p><code>clojure
clojure.lang.ExceptionInfo: throw+: #strucjure.view.PartialMatch{:view #strucjure.view.Or{:views [#strucjure.view.Match{:pattern #strucjure.pattern.Seq{:pattern #strucjure.pattern.Chain{:patterns [#strucjure.view.Import{:view-fun #&lt;test$bind_STAR_$fn__2339 test$bind_STAR_$fn__2339@60a896b8&gt;, :pattern #strucjure.pattern.Bind{:symbol x}} #strucjure.pattern.Head{:pattern #strucjure.pattern.And{:patterns [#strucjure.pattern.Guard{:fun #&lt; clojure.lang.AFunction$1@5c3f3b9b&gt;} #strucjure.pattern.Bind{:symbol op}]}} #strucjure.view.Import{:view-fun #&lt;test$bind_STAR_$fn__2343 test$bind_STAR_$fn__2343@3b626c6d&gt;, :pattern #strucjure.pattern.Bind{:symbol y}}]}}, :result-fun #&lt; clojure.lang.AFunction$1@3abc8690&gt;} #strucjure.view.Match{:pattern #strucjure.pattern.Seq{:pattern #strucjure.pattern.Chain{:patterns [#strucjure.view.Import{:view-fun #&lt;test$bind_STAR_$fn__2347 test$bind_STAR_$fn__2347@2f267610&gt;, :pattern #strucjure.pattern.Bind{:symbol x}}]}}, :result-fun #&lt; clojure.lang.AFunction$1@6112c9f&gt;}]}, :input (1 - 2 + 3 - 4), :remaining (- 2 + 3 - 4), :output 1}
</code></p>

<p>I have some ideas about how to improve this but nothing totally concrete. I could, at the very least, return the bindings that existed at the point of failure along with some kind of failure stack. If I can figure out a reasonable way to implement <a href="http://en.wikipedia.org/wiki/Cut_%28logic_programming%29">cut</a> that will also help.</p>

<p>Another short-term priority is some form of <a href="http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons">tail call elemination</a>. Many patterns and views are naturally implemented in a recursive fashion:</p>

<p><code>clojure
(defnview zero-or-more [elem]
  (prefix (elem ?x) &amp; ((zero-or-more elem) ?xs)) (cons x xs)
  (prefix ) nil)
</code></p>

<p>But in the current implementation of strucjure this will quickly overflow the stack. The current workaround is to define such views by hand:</p>

<p>``` clojure
(defrecord ZeroOrMore [view]
  View
  (run* [this input opts]</p>

<pre><code>(when (or
       (nil? input)
       (instance? clojure.lang.Seqable input))
  (loop [elems (seq input)
         outputs nil]
    (if-let [[elem &amp; elems] elems]
      (if-let [[remaining output] (run view elem opts)]
        (if (nil? remaining)
          (recur elems (cons output outputs))
          [(cons elem elems) (reverse outputs)])
        [(cons elem elems) (reverse outputs)])
      [nil (reverse outputs)])))))
</code></pre>

<p>(def zero-or-more &ndash;>ZeroOrMore)
```</p>

<p>This is gross. I don&rsquo;t have any ideas on how to overcome this.</p>

<p>I&rsquo;ve already briefly mentioned reversible patterns. At the beginning of this post I warned that I would use the terms view and pattern interchangeably. The line between them in strucjure is currently blurry but I think that the distinction should be that patterns must be reversible while views are allowed to destroy information.</p>

<p>Lastly, there will eventually be a need for some level of optimization. Given the extra flexibility in strucjure I don&rsquo;t expect to ever be as fast as core.match but there is certainly lots of room for improvement on the current code. Originally, strucjure patterns were compiled into efficient clojure code but the implementation was complicated and it was difficult to rapidly iterate around it. I will probably return to compilation once the semantics and interface settle down.</p>

<p>For now, I&rsquo;m going to dogfood strucjure in various projects while ruminating on improvements. I&rsquo;m already very happy with how much leverage can be had from such a simple idea, especially if I can fix the problems above. Hopefully the examples here might get other people thinking along the same lines.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hacker School]]></title>
    <link href="http://scattered-thoughts.net/blog/2012/12/02/hacker-school/"/>
    <updated>2012-12-02T01:16:00+00:00</updated>
    <id>http://scattered-thoughts.net/blog/2012/12/02/hacker-school</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve spent the last ten weeks or so at <a href="https://www.hackerschool.com/">Hacker School</a>. It&rsquo;s something like a writer&rsquo;s retreat for programmers. Unlike a traditional school there is very little structure and the focus is on project-based learning. In order to make the most of this environment, it&rsquo;s important to be clear exactly what your goals are.</p>

<!--more-->


<p>So here is my goal &ndash; to create better tools for the problems I regularly encounter. My focus is on building distributed systems and p2p networks but I suspect that these tools will be generally useful. When working as a freelancer I am necessarily constrained to using proven ideas and techniques because the risk assumed is not mine. Hacker School is a chance for me to explore some more far-out ideas. These ideas are drawn primarily from two places: the <a href="http://vpri.org/">Viewpoint Research Institute</a> and the <a href="boom.cs.berkeley.edu/">Berkeley Order Of Magnitude</a> project.</p>

<h1>Viewpoint Research Institute</h1>

<p>Specifically, I&rsquo;m interested in the <a href="http://www.vpri.org/pdf/tr2011004_steps11.pdf">Steps Towards Expressive Programming</a> project. Their goal is no less than the reinvention of programming. By way of proof of concept they aim to develop an entire computing system, from OS to compilers to applications, in less than 20k LOC. Such a system would be compact enough to be understood in its entirety by a single person, something that is unthinkable in todays world of multi-million LOC systems. Amazingly, their initial prototypes of various subsystems actually approach this goal.</p>

<p>Their approach relies heavily on the use of <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSLs</a> to capture high-level, domain-specific expressions of intent which are then compiled into efficient code. By way of example, they describe their TCP-IP stack:</p>

<blockquote><p>Most  interesting  ideas  have  more  than  one  fruitful  way  to  view  them,  and  it  occurred  to  us  that,
abstractly,  one  could  think  of  TCP/IP  as  a  kind  of  “non‐deterministic  parser  with  balancing
heuristics”,  in  that  it  takes  in  a  stream  of  things,  does  various  kinds  of  pattern‐matching  on  them,
deals with errors by backing up and taking other paths, and produces a transformation of the input in
a specified form as a result.</p>

<p>Since the language transformation techniques we use operate on arbitrary objects, not just strings (see
above), and include some abilities of both standard and logic programming, it seemed that this could
be used to make a very compact TCP/IP. Our first attempt was about 160 lines of code that was robust
enough to run a website. We think this can be done even more compactly and clearly, and we plan to
take another pass at this next year.</p></blockquote>

<p>The &lsquo;language transformation techniques&rsquo; they refer to are embodied in <a href="http://lambda-the-ultimate.org/node/2477">OMeta</a>, a <a href="http://en.wikipedia.org/wiki/PEG">PEG</a>-based language for parsing and pattern-matching. OMeta provides an incredible amount of leverage for such a simple abstraction. For starters, it leads to very concise and readable descriptions of tokenisers, parsers and tree transformers which are all crucial for developing DSLs.</p>

<h1>Berkeley Order Of Magnitude</h1>

<p>The Berkeley Order Of Magnitude project has spent a number of years experimenting with using logic languages for distributed systems. Like the STEPS project, their goals are audaciously ambitious.</p>

<blockquote><p>Enter BOOM, an effort to explore implementing Cloud software using disorderly, data-centric languages. BOOM stands for the Berkeley Orders Of Magnitude project, because we seek to enable people to build systems that are OOM bigger than are building today, with OOM less effort than traditional programming methodologies.</p></blockquote>

<p>Among their <a href="boom.cs.berkeley.edu/papers.html">myriad publications</a> they describe an <a href="http://www.srcf.ucam.org/~ms705/temp/eurosys2010/boom.pdf">API-compliant reimplementation of Hadoop and HDFS</a> in ~1K lines of Overlog code, which they then extend with a variety of features (eg master-node failover via MultiPaxos) not yet found in Hadoop. Thanks to a number of high-level optimisations enabled by the simpler code-base their implementation is almost as fast as the original.</p>

<p>For me, the most interesting aspect is the amount of reflective power gained by treating everything as data:</p>

<blockquote><p>One key to our approach is that everything is data, i.e. rows in tables that can be queried and manipulated. This includes persistent data (e.g. filesystem metadata), runtime state (e.g. Hadoop scheduler bookkeeping), summary stats (e.g. for advanced straggler scheduling), in-flight msgs and system events, even parsed code. When everything in a system is data, it becomes easy to do things like parallelize computations on the state, make it fault tolerant, and express (and enforce) invariants on legal states of the system.</p></blockquote>

<p>The latest project from the BOOM group is the <a href="http://www.bloom-lang.net/">Bloom language</a>. Bloom has a more solid theoretical foundation than their previous languages and also enables an amazing level of static analysis, even being able to guarantee that certain Bloom programs are eventually consistent.</p>

<h1>Core Ideas</h1>

<p>What can I take away from these projects? Here are some vague ideas, which to my mind all seem related.</p>

<h2>Higher-level reasoning</h2>

<p>The STEPS notes talk about &lsquo;separating meaning from tactics&rsquo;. It&rsquo;s often easier to specify what a correct solution to a problem looks like than it is to actually find it. In many domains, finding a solution is then just a matter of applying a suitable search algorithm. For example, constraint solvers such as <a href="http://www.gecode.org/">gecode</a> or <a href="https://github.com/clojure/core.logic">core.logic</a> express a problem as a set of logical constraints on the possible solutions and then search through the space of variable assignments to find a solution. By automatically pruning parts of the search space which break one or more constraints and applying user-specified search heuristics, constraint solvers can often be faster than hand-coded solvers for complex problems whilst at the same time allowing a clear, concise, declarative specification of the problem.</p>

<h2>Everything is data</h2>

<p>Constraint solving is enabled by treating both the problem specification and the solution space as data, reducing the problem to search. In lisps, treating code as data enables macros and code rewriting. In Overlog, everything from persistent data to scheduler state to the language runtime is available as data and can be queried and manipulated using the same powerful abstractions. Tracing in Overlog is as simple as adding a rule that fires whenever a new fact is derived, because the derivation itself is stored alongside the fact.</p>

<p>Whatever you are working on, making it accessible as plain data enables turning the full power and expressivity of your language directly onto the problem. This is where OO falls down, in trying to hide data behind custom interfaces. Rob Pike recently put it: &ldquo;It has become clear that OO zealots are afraid of data&rdquo;.</p>

<h2>Reflection</h2>

<p>When you expose the internals of a system as data to that same system, amazing (and, yes, sometimes terrifying) things happen. The STEPS folks manage to stay withing their code budget by building highly dynamic, self-hosting, meta-circular, introspective languages. Many of the amazing results of the Overlog project, from the optimising compiler to declarative distributed tracing, resulted from exposing the language runtime and program source code to the same logic engine that it implements. Turning a system in on itself and allowing it to reason about its own behaviour is an incredibly powerful idea. Certainly it can be dangerous, and it&rsquo;s all too easy to tangle oneself in knots, but the results speak for themselves. This is an idea that has been <a href="http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html">expounded</a> <a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">many</a> <a href="http://www.paulgraham.com/diff.html">times</a> before but I think there is still so much more to explore here.</p>

<h1>Progress</h1>

<p>My attempts to keep up with this have been focused on three projects.</p>

<p><a href="https://github.com/jamii/shackles">Shackles</a> is a constraint solver supporting both finite-domain and logical constraints. It was originally an experiment to see what, if any, extra power could be gained from implementing a gecode-style solver using persistent data-structures (constraint solvers in traditional languages spend much of their time cloning program state to enable back-tracking). Fortunately, <a href="https://github.com/clojure/core.logic">core.logic</a> now supports finite domain variables with constraint propagation and there has been noise about implementing user-specified search heuristcs, so that&rsquo;s one less piece of code I need to write :D</p>

<p><a href="https://github.com/jamii/strucjure">Strucjure</a> is similar to OMeta but aims to be a good clojure citizen rather than a totally separate tool. As such, all of its core components are <a href="http://clojure.org/protocols">protocols</a>, semantic actions are plain clojure code and the resulting patterns and views are just nested <a href="http://clojure.org/datatypes">records</a> which can be manipulated by regular clojure code. Following the principles above, the syntax of strucjure patterns/views is <a href="https://github.com/jamii/strucjure/blob/master/src/strucjure/parser.clj#L94">self-defined using views</a> and the test suite <a href="https://github.com/jamii/strucjure/blob/master/src/strucjure/test.clj#L1">parses the documentation</a> to verify the correctness of the examples.</p>

<p><a href="https://github.com/jamii/droplet">Droplet</a> is based on the Bloom<sup>L</sup> language (an extension of the Bloom language that operates over arbitrary semi-lattices). Droplet is so far less developed than the other projects but the core interpreter is working as well as basic datalog-like rules. Again, droplet attempts to be a good clojure citizen. Rules are just clojure functions. The datalog syntax is implemented via a simple macro which produces a rule function. Individual droplets are held in <a href="http://clojure.org/agents">agents</a> and communicate either via agent sends or over <a href="https://github.com/ztellman/lamina">lamina</a> queues. I&rsquo;m currently working out a composable, extensible query language that is able to operate over arbitrary semi-lattices, rather than just sets. In its current (and largely imaginary) form, it looks something like <a href="https://gist.github.com/4171094">this</a>.</p>

<p>I&rsquo;ll go into more detail on the latter two projects soon but for now I&rsquo;m content to just throw these ideas out into the world, without justification, and see what bounces back.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strucjure: reading the readme]]></title>
    <link href="http://scattered-thoughts.net/blog/2012/10/25/strucjure-reading-the-readme/"/>
    <updated>2012-10-25T19:37:00+01:00</updated>
    <id>http://scattered-thoughts.net/blog/2012/10/25/strucjure-reading-the-readme</id>
    <content type="html"><![CDATA[<p>I just released <a href="https://github.com/jamii/strucjure">strucjure</a>, a clojure library and DSL for parsing and pattern matching based on <a href="http://lambda-the-ultimate.org/node/2477">Ometa</a>.</p>

<p>The readme on github has detailed descriptions of the syntax etc which I won&rsquo;t repeat here. What I do want to do is run through a realistic example.</p>

<!--more-->


<p>The readme has a large number of examples and I want to be sure that these are all correct and up to date. As part of the test-suite for strucjure I parse the <a href="https://raw.github.com/jamii/strucjure/master/README.md">readme source</a>, pull out all the examples and make sure that they all run correctly and return the expected output.</p>

<p>```bash
jamie@alien:~/strucjure$ lein test strucjure.test
WARNING: newline already refers to: #&lsquo;clojure.core/newline in namespace: strucjure.test, being replaced by: #'strucjure.test/newline</p>

<p>lein test strucjure.test</p>

<p>Ran 1 tests containing 166 assertions.
0 failures, 0 errors.
```</p>

<p>The readme parser is pretty simple. Since I control both the parser and the readme source so it doesn&rsquo;t need to be bullet-proof, just the simplest thing that will get the job done. Strucjure is very bare-bones at the moment though so we have to create a lot of simple views that really belong in a library somewhere.</p>

<p>```clojure
(defview space
  \space %)</p>

<p>(defview newline
  \newline %)</p>

<p>(defview not-newline
  (not \newline) %)</p>

<p>(defview line
  (and (not []) ; have to consume at least one char</p>

<pre><code>   (prefix &amp; ((zero-or-more not-newline) ?line)
           &amp; ((optional newline) ?end)))
</code></pre>

<p>  line)</p>

<p>(defview indented-line
  (prefix &amp; ((one-or-more space) _) &amp; (line ?line))
  line)
```</p>

<p>We want a tokeniser for various parts of the readme. We could write it like this:</p>

<p><code>clojure
(defnview tokenise [sep]
  ;; empty input
  [] '(())
  ;; throw away separator, start a new token
  [&amp; (sep _) &amp; ((tokenise sep) ?results)] (cons () results)
  ;; add the current char to the first token
  [?char &amp; ((tokenise sep) [?result &amp; ?results])] (cons (cons char result) results))
</code></p>

<p>Unfortunately in the current implementation of strucjure that recursive call goes on the stack, so this view will blow up on large inputs. For now we just have to implement this view by hand to get access to recur.</p>

<p>```clojure
(defn tokenise [sep]
  (view/&ndash;>Raw
   (fn [input opts]</p>

<pre><code> (when-let [elems (seq input)]
   (loop [elems elems
          token-acc nil
          tokens-acc nil]
     (if-let [[remaining _] (view/run sep elems opts)]
       (recur remaining nil (cons (reverse token-acc) tokens-acc))
       (if-let [[elem &amp; elems] elems]
         (recur elems (cons elem token-acc) tokens-acc)
         [nil (reverse (cons (reverse token-acc) tokens-acc))])))))))
</code></pre>

<p>```</p>

<p>The rest of the parser makes more sense reading in reverse order. We start by splitting up the readme by code delimiters (triple backticks). This gives us chunks of alternating text and code, so we parse every other chunk as a block of code.</p>

<p><code>``clojure
(defview code-delim
  (prefix \</code> ` `)
  :code-delim)</p>

<p>(defview readme
  ((tokenise code-delim) ?chunks)
  (apply concat (map (partial run code-block) (take-nth 2 (rest chunks)))))
```</p>

<p>We only want to look at code blocks that are marked as clojure code.</p>

<p><code>clojure
(defview code-block
  [\c \l \o \j \u \r \e \newline &amp; (code-block-inner ?result)]
  result)
</code></p>

<p>A few of the code blocks don&rsquo;t contain examples &ndash; we can detect these because they don&rsquo;t start with a &ldquo;user> &rdquo; prompt. All the other blocks contain a list of examples separated by prompts.</p>

<p>```clojure
(defview prompt
  (prefix \u \s \e \r > \space)
  :prompt)</p>

<p>(defview code-block-inner
  (and (prompt _)</p>

<pre><code>   ((tokenise prompt) ?chunks))
</code></pre>

<p>  (map (partial run example) (filter #(not (empty? %)) chunks))</p>

<p>  _ ;; not a block of examples
  nil)
```</p>

<p>An example consists of an input, which may be on multiple lines, zero or more lines of printed output and finally a result.</p>

<p><code>clojure
(defview example
  [&amp; (line ?input-first)
   &amp; ((zero-or-more-prefix indented-line) ?input-rest)
   &amp; ((one-or-more-prefix line) ?output-lines)]
  {:input (with-out-str (doseq [line (cons input-first input-rest)] (print (apply str line) \space)))
   :prints (with-out-str (doseq [line (butlast output-lines)] (println (apply str line))))
   :result (run result (last output-lines))})
</code></p>

<p>The result is either a return value or an exception.</p>

<p>```clojure
;; #&ldquo;[a-zA-Z.]&rdquo;
(defview exception-chars
  (or .</p>

<pre><code>  #(&lt;= (int \a) (int %) (int \z))
  #(&lt;= (int \A) (int %) (int \Z)))
</code></pre>

<p>  %)</p>

<p>(defview result
  [\E \x \c \e \p \t \i \o \n \I \n \f \o \space
   \t \h \r \o \w + \: \space
   # &amp; ((one-or-more exception-chars) ?exception)
   &amp; _]
  [:throws (apply str exception)]</p>

<p>  ?data
  [:returns (apply str data)])
```</p>

<p>That&rsquo;s it &ndash; parsing done.</p>

<p>Now we just have to turn the results into unit tests. We have to be careful about comparing the results of the examples because they might contain closures, which look different every time.</p>

<p>```clojure
(defn replace-fun [unread-form]
  (.replaceAll unread-form &ldquo;#&lt;[^>]*>&rdquo; &ldquo;#<fun>&rdquo;))</p>

<p>(defn prints-as [string form]
  (= (replace-fun string) (replace-fun (with-out-str (pr form)))))
```</p>

<p>Running the examples is a little tricky because some of them create bindings or classes that are used by later examples. We end up needing to eval the code at runtime.</p>

<p>```clojure
(defn example-test [input prints result]
  (match result</p>

<pre><code>     [:returns ?value]
     (do
       (is (prints-as value (input)))
       (is (= prints (with-out-str (input)))))

     [:throws ?exception]
     (do
       (is (try+ (input)
                 nil
                 (catch java.lang.Object thrown
                   (prints-as exception (class thrown)))))
       (is (= prints (with-out-str
                       (try+ (input)
                             (catch java.lang.Object _ nil))))))))
</code></pre>

<p>(defmacro insert-example-test [{:keys [input prints result]}]
  `(example-test (fn [] (eval &lsquo;(do (use &rsquo;~&lsquo;strucjure) ~(read-string input)))) ~prints &rsquo;~result))</p>

<p>(defmacro insert-readme-test [file]
  `(do</p>

<pre><code> ~@(for [example (run readme (seq (slurp (eval file))))]
     `(insert-example-test ~example))))
</code></pre>

<p>(deftest readme-test
  (insert-readme-test &ldquo;README.md&rdquo;))
```</p>

<p>This is fun. Not only does strucjure parse its own syntax, it reads its own documentation!</p>

<p>Parts of this were a little painful. The next version of strucjure will definitely have improved string matching. I&rsquo;m also looking at optimising/compiling views, as well as memoisation. Previous versions of strucjure supported both but were hard to maintain. For now I&rsquo;m going to be moving on to using strucjure to build other useful DSLs.</p>
]]></content>
  </entry>
  
</feed>
