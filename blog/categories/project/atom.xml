<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: project | Scattered Thoughts]]></title>
  <link href="http://scattered-thoughts.net/blog/categories/project/atom.xml" rel="self"/>
  <link href="http://scattered-thoughts.net/"/>
  <updated>2015-03-26T00:54:01-07:00</updated>
  <id>http://scattered-thoughts.net/</id>
  <author>
    <name><![CDATA[Jamie Brandon]]></name>
    <email><![CDATA[jamie@scattered-thoughts.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hugo-a-go-go: optimisation]]></title>
    <link href="http://scattered-thoughts.net/blog/2013/11/24/hugo-a-go-go-optimisation/"/>
    <updated>2013-11-24T04:43:00-08:00</updated>
    <id>http://scattered-thoughts.net/blog/2013/11/24/hugo-a-go-go-optimisation</id>
    <content type="html"><![CDATA[<p>After a little optimisation work <a href="https://github.com/jamii/hugo-a-go-go/">hugo</a> now manages to play out ~12k games per second on a 9x9 board. Besides fixing the two incorrect optimisations I made during the last minutes of the competition, the main wins were changing the board representation and carefully inspecting the compiler output to eliminate unneccesary work. A lot of the things I discovered are generally applicable to calculation-heavy, cpu-bound cljs code (with all the usual disclaimers about profiling and premature optimsation).</p>

<!--more-->


<h2>Layout</h2>

<p>The board is now packed into a Uint8Array. With borders included, the board is an 11x11 grid.</p>

<p>``` clj
(def size 9)
(def array-size (+ 2 size))
(def max-pos (* array-size array-size))</p>

<p>(defn &ndash;>pos [x y]
  (+ 1 x (* array-size (+ 1 y))))
```</p>

<p>The first 121 entries in the array represent the colour of each cell on the board.</p>

<p>``` clj
(def empty 0)
(def black 1)
(def white 2)
(def grey 3) ;; for the border</p>

<p>(defmacro get-colour [board pos]
  `(aget ~board ~pos))</p>

<p>(defmacro set-colour [board pos colour]
  `(aset ~board ~pos ~colour))
```</p>

<p>The next 121 entries track which string is present on a cell. Strings are just represented by an integer id. The last entry in the array tracks the next id to be assigned.</p>

<p>``` clj
(def empty-string 0)
(def grey-string 1)</p>

<p>(defmacro new-string [board]
  `(let [next-string# (aget ~board 1023)]</p>

<pre><code> (aset ~board 1023 (+ next-string# 1))
 next-string#))
</code></pre>

<p>(defmacro get-string [board pos]
  `(aget ~board (+ ~max-pos ~pos)))</p>

<p>(defmacro set-string [board pos string]
  `(aset ~board (+ ~max-pos ~pos) ~string))
```</p>

<p>The next 121 entries track the number of non-empty neighbouring cells, which is useful for short-circuiting <code>suicide?</code> and <code>eyelike?</code> tests.</p>

<p><code>`` clj
(defmacro get-neighbours [board pos]
 </code>(let [freedom-ix# (+ ~(* 2 max-pos) ~pos)]</p>

<pre><code> (aget ~board freedom-ix#)))
</code></pre>

<p>(defmacro add-neighbours [board pos amount]
  `(let [freedom-ix# (+ ~(* 2 max-pos) ~pos)]</p>

<pre><code> (aset ~board freedom-ix# (+ (aget ~board freedom-ix#) ~amount))))
</code></pre>

<p>```</p>

<p>Finally, the remaining cells map string ids to the number of pseudo-liberties belonging to that string.</p>

<p><code>`` clj
(defmacro get-liberties [board pos]
 </code>(let [string-ix# (+ ~(* 3 max-pos) (get-string ~board ~pos))]</p>

<pre><code> (aget ~board string-ix#)))
</code></pre>

<p>(defmacro add-liberties [board pos amount]
  `(let [string-ix# (+ ~(* 3 max-pos) (get-string ~board ~pos))]</p>

<pre><code> (aset ~board string-ix# (+ (aget ~board string-ix#) ~amount))))
</code></pre>

<p>```</p>

<p>Packing the board this way gives two benefits. First, every field access is reduced to a few instructions. This isn&rsquo;t as big a win as one might think, given that the structure of the old layout was predictable enough for the jit to replace hash lookups with struct access. More importantly, packing the board means that creating a copy is a single array copy. Cheap copying means we can cache boards all over the place and this leads to a lot of saved work in the UCT stage.</p>

<p>My implementation here is a little clumsy but in the future a cljs port of <a href="https://github.com/ztellman/vertigo">vertigo</a> would make this a lot cleaner. This is the kind of abstraction that would be difficult to implement in plain js.</p>

<h2>Truth</h2>

<p>In cljs, only <code>false</code> and <code>nil</code> are falsey. In generated code, if the cljs compiler cannot infer that the test in a branch is a boolean, it wraps it in <code>cljs.core.truth_</code> to test for cljs truthiness rather than js truthiness.</p>

<p>``` clj
(defn foo? [x]
  (= &ldquo;foo&rdquo; x))</p>

<p>(defn unfoo [x]
  (if (foo? x)</p>

<pre><code>nil
x))
</code></pre>

<p>```</p>

<p><code>js
hugo_a_go_go.board.foo_QMARK_ = function(a) {
  return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2("foo", a)
};
hugo_a_go_go.board.unfoo = function(a) {
  return cljs.core.truth_(hugo_a_go_go.board.foo_QMARK_(a)) ? null : a
};
</code></p>

<p>Normally this doesn&rsquo;t matter but hugo is optimised enough already that profiling showed it spending ~15% of it&rsquo;s time inside <code>cljs.core.truth_</code>. You can avoid it either by adding type hints&hellip;</p>

<p>``` clj
(defn ^boolean foo? [x]
  (= &ldquo;foo&rdquo; x))</p>

<p>(defn unfoo [x]
  (if (foo? x)</p>

<pre><code>nil
x))
</code></pre>

<p>```</p>

<p><code>js
hugo_a_go_go.board.foo_QMARK_ = function(a) {
  return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2("foo", a)
};
hugo_a_go_go.board.unfoo = function(a) {
  return hugo_a_go_go.board.foo_QMARK_(a) ? null : a
};
</code></p>

<p>&hellip; or by wrapping the test in a function that is already hinted.</p>

<p>``` clj
(defn foo? [x]
  (= &ldquo;foo&rdquo; x))</p>

<p>(defn unfoo [x]
  (if (true? (foo? x))</p>

<pre><code>nil
x))
</code></pre>

<p>```</p>

<p><code>js
hugo_a_go_go.board.foo_QMARK_ = function(a) {
  return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2("foo", a)
};
hugo_a_go_go.board.unfoo = function(a) {
  return!0 === hugo_a_go_go.board.foo_QMARK_(a) ? null : a
};
</code></p>

<h2>Equality</h2>

<p>Clojure defaults to structural equality where possible, rather than using javascript&rsquo;s insane notion of equality.</p>

<p><code>clj
(defn opposite-colour [colour]
  (if (= colour black) white black))
</code></p>

<p><code>js
hugo_a_go_go.board.opposite_colour = function(a) {
  return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(a, hugo_a_go_go.board.black) ? hugo_a_go_go.board.white : hugo_a_go_go.board.black
};
</code></p>

<p>Again, this is something that normally doesn&rsquo;t matter but hugo was spending ~20% of cpu time in <code>cljs.core.__EQ__</code>. Since we know we are comparing integers we can use <code>==</code> instead, which compiles down to <code>===</code> in js.</p>

<p><code>clj
(defn opposite-colour [colour]
  (if (== colour black) white black))
</code></p>

<p><code>js
hugo_a_go_go.board.opposite_colour = function(a) {
  return a === hugo_a_go_go.board.black ? hugo_a_go_go.board.white : hugo_a_go_go.board.black
};
</code></p>

<p>For other primitive types it seems that <code>identical?</code> will inline to <code>===</code>. For keywords you now have to use <code>keyword-identical?</code> which unfortunately does not inline.</p>

<h2>Polyadic calls</h2>

<p>Clojure functions can dispatch on the number of arguments. Usually the cljs compiler does a good job of compiling away the extra indirection, but it struggles with local functions.</p>

<p>``` clj
(defn foo []
  (letfn [(bar [x y] (= x y))]</p>

<pre><code>(bar :foo :bar)))
</code></pre>

<p>```</p>

<p>``` js
hugo_a_go_go.board.foo = function() {
  var a = function(a, c) {</p>

<pre><code>return cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(a, c)
</code></pre>

<p>  };
  return a.cljs$core$IFn$<em>invoke$arity$2 ? a.cljs$core$IFn$</em>invoke$arity$2(new cljs.core.Keyword(null, &ldquo;foo&rdquo;, &ldquo;foo&rdquo;, 1014005816), new cljs.core.Keyword(null, &ldquo;bar&rdquo;, &ldquo;bar&rdquo;, 1014001541)) : a.call(null, new cljs.core.Keyword(null, &ldquo;foo&rdquo;, &ldquo;foo&rdquo;, 1014005816), new cljs.core.Keyword(null, &ldquo;bar&rdquo;, &ldquo;bar&rdquo;, 1014001541))
};
```</p>

<p>The important part to notice here is that it tests if <code>a.cljs$core$IFn$_invoke$arity$2</code> exists before calling it, despite the fact that that is statically known. We had some small (~5%) performance improvements in a few places (notably board/flood-fill) by lifting all closures up to top-level functions so that the compiler can remove that check.</p>

<h2>Mutable variables</h2>

<p>Sometimes you need a mutable variable. Using atoms incurs overhead for eg checking watches. According to <a href="http://swannodette.github.io/2013/06/10/porting-notchs-minecraft-demo-to-clojurescript/">David Nolen</a>, the best option in cljs is creating a one-element array.</p>

<p>It would be nice to have safe access to mutable vars in the style of <a href="https://github.com/ztellman/proteus">proteus</a> instead.</p>

<h2>Next</h2>

<p>While it meet seem annoying to have to work around the compiler sometimes to get decent performance, I far prefer to have sane semantics by default and just remember a few simple tricks for speeding up inner loops. Having access to macros also opens the door to a world of performant abstractions that would be extremely painful in plain js (eg <a href="https://github.com/clojure/core.match">core.match</a>, <a href="https://github.com/ztellman/vertigo">vertigo</a>). Now that the core of hugo is just bashing on integers and byte arrays there is also the potential to compile sections of it to <a href="http://asmjs.org/">asm.js</a> for even more performance.</p>

<p>Hugo now plays fairly sensibly but is still easy to defeat even for a novice player like me. I suspect that the UCT stage is still not entirely correct so the next step is to build a visualiser for the game tree so I can see the reasoning behind it&rsquo;s moves.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hugo-a-go-go]]></title>
    <link href="http://scattered-thoughts.net/blog/2013/10/06/hugo-a-go-go/"/>
    <updated>2013-10-06T13:22:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2013/10/06/hugo-a-go-go</id>
    <content type="html"><![CDATA[<p>For the <a href="http://clojurecup.com/">2013 Clojure Cup</a> myself and <a href="http://www.thattommyhall.com/">Tom Hall</a> wrote a <a href="http://en.wikipedia.org/wiki/Go_%28game%29">go</a> AI in clojurescript, inspired by <a href="https://github.com/ztellman/pushkin">pushkin</a>. The source is <a href="https://github.com/jamii/hugo-a-go-go/">here</a> and it can currently be played on the <a href="http://hugoagogo.clojurecup.com/">clojure cup site</a> (only tested in chrome).</p>

<!--more-->


<p>Before reading this post it would help to understand the rules of go. Hugo-a-go-go follows (an approximation of) the <a href="http://en.wikipedia.org/wiki/Rules_of_Go#Chinese_rules">chinese rules</a>. Due to the limited time we don&rsquo;t yet check for <a href="http://en.wikipedia.org/wiki/Rules_of_Go#Ko">ko</a> and don&rsquo;t even attempt to detect the end of the game. The code at the moment is incredibly messy and probably very buggy (the version we submitted seems to actually <em>try</em> to lose) so treat it with suspicion.</p>

<h2>Board</h2>

<p>The best place to start is with the board representation. The most expensive operation for the AI is detecting suicide and death. To make this fast we track connected strings of pieces.</p>

<p><code>clojure
(defrecord String [colour liberties])
</code></p>

<p><code>colour</code> is one of <code>:black</code>, <code>:white</code>, <code>:grey</code> (for the border) or <code>:empty</code>. <code>liberties</code> tracks the number of <a href="https://groups.google.com/forum/#!msg/computer-go-archive/hs259RQQ5hI/TOLFX2d5Y6UJ">pseudo-liberties</a> the string has (for black or white strings; for empty or grey strings the <code>liberties</code> value is never read and exists just to avoid having to branch on the colour).</p>

<p>The board is represented by a 1d array of pointers to strings (this representation is inspired by <a href="http://www.gnu.org/software/gnugo/">gnugo</a> rather than pushkin) and a pointer to the empty string (which we use for fast <code>empty?</code> checks).</p>

<p>``` clojure
(defrecord Board [strings empty-string])</p>

<p>(def size 9)
(def array-size (+ 2 size))
(def max-pos (* array-size array-size))</p>

<p>(defn &ndash;>pos [x y]
  (+ 1 x (* array-size (+ 1 y))))
```</p>

<p>To create a board we just have to setup the empty-string and border-string.</p>

<p>``` clojure
(defn new []
  (let [empty-string (&ndash;>String :empty 0)</p>

<pre><code>    border-string (-&gt;String :grey 0)
    strings (object-array max-pos)]
(dotimes [i max-pos]
  (aset strings i empty-string))
(dotimes [i array-size]
  (aset strings (-&gt;pos (dec i) -1) border-string)
  (aset strings (-&gt;pos (dec i) size) border-string)
  (aset strings (-&gt;pos -1 (dec i)) border-string)
  (aset strings (-&gt;pos size (dec i)) border-string))
(-&gt;Board strings empty-string)))
</code></pre>

<p>```</p>

<p>A given move is <em>not</em> suicide if, after the move is made, there is at least one neighbour which is either:</p>

<ul>
<li><p>the same colour and has more than zero liberties</p></li>
<li><p>the opposite colour and has zero liberties (ie would die if the move was carried through)</p></li>
<li><p>empty</p></li>
</ul>


<p>``` clojure
(defn suicide? [^Board board colour pos]
  (let [suicide (atom true)</p>

<pre><code>    opposite-colour (condp keyword-identical? colour :black :white :white :black)]
;; decrement all the neighbours liberties
(foreach-neighbour neighbour-pos pos
  (let [string (aget (.-strings board) neighbour-pos)]
    (set! (.-liberties string) (dec (.-liberties string)))))
;; check for suicide
(foreach-neighbour neighbour-pos pos
  (let [string (aget (.-strings board) neighbour-pos)]
    (condp keyword-identical? (.-colour string)
      colour (when (&gt; (.-liberties string) 0)
               (reset! suicide false))
      opposite-colour (when (= (.-liberties string) 0)
                        (reset! suicide false))
      :empty (reset! suicide false)
      :grey nil)))
;; undo the decrement
(foreach-neighbour neighbour-pos pos
  (let [string (aget (.-strings board) neighbour-pos)]
    (set! (.-liberties string) (inc (.-liberties string)))))
@suicide))
</code></pre>

<p>```</p>

<p>Actually making a move is similar but we have to clear out dead strings and join adjacent strings together. Proving that it&rsquo;s safe to do all this in a single pass is straightforward, if tedious.</p>

<p>``` clojure
defn set-colour [^Board board pos colour]
  (let [string (&ndash;>String colour 0)]</p>

<pre><code>(aset (.-strings board) pos string)
(foreach-neighbour neighbour-pos pos
                   (let [neighbour-string (aget (.-strings board) neighbour-pos)
                         neighbour-colour (.-colour neighbour-string)]
                     (condp keyword-identical? neighbour-colour
                       :empty
                       (set! (.-liberties (aget (.-strings board) pos)) (inc (.-liberties (aget (.-strings board) pos))))

                       :grey
                       nil

                       colour
                       (do
                         (set! (.-liberties neighbour-string) (dec (.-liberties neighbour-string)))
                         (join-strings board (aget (.-strings board) pos) neighbour-string pos neighbour-pos))

                       ;; opposite colour
                       (do
                         (set! (.-liberties neighbour-string) (dec (.-liberties neighbour-string)))
                         (when (= 0 (.-liberties neighbour-string))
                           (clear-string board neighbour-string neighbour-pos))))))))
</code></pre>

<p>```</p>

<h2>Monte Carlo</h2>

<p>Go branches far too much to exhaustively check all possible futures. Instead we use a heuristic measure of the value of a move &ndash; the Monte Carlo estimate of the expected score when both players choose from the set of valid moves uniformly at random. To put it simply, we run large numbers of random games from this board position and take the mean score as our measure of how strong this board position is. Since we don&rsquo;t have a test for the end of the game we just run until either 100 moves have been made or until both sides have no valid moves remaining.</p>

<p>``` clojure
(defn flood-fill [board colour]
  (let [filled (object-array max-pos)]</p>

<pre><code>(letfn [(flood-fill-around [pos]
          (foreach-neighbour pos pos
              (when (and (not (aget filled pos))
                         (keyword-identical? :empty (get-colour board pos)))
                (aset filled pos true)
                (flood-fill-around pos))))]
  (dotimes [x size]
    (dotimes [y size]
      (let [pos (-&gt;pos x y)]
        (when (keyword-identical? colour (get-colour board pos))
          (aset filled pos true)
          (flood-fill-around pos))))))
(count (filter identity filled))))
</code></pre>

<p>(defn score [board]
  (let [white-flood (flood-fill board :white)</p>

<pre><code>    black-flood (flood-fill board :black)
    total (* size size)
    overlap (- (+ white-flood black-flood) total)
    white-score (- white-flood overlap)
    black-score (- black-flood overlap)]
{:white white-score :black black-score}))
</code></pre>

<p>(defn random-move [board colour]
  (let [starting-pos (random-int board/max-pos)]</p>

<pre><code>(loop [pos starting-pos]
  (if (and (board/valid? board colour pos)
           (not (board/eyelike? board colour pos)))
    pos
    (let [new-pos (mod (inc pos) board/max-pos)]
      (if (= starting-pos new-pos)
        nil
        (recur new-pos)))))))
</code></pre>

<p>(defn with-random-moves [board n starting-colour]
  (doseq [colour (take n (interleave (repeat starting-colour) (repeat (board/opposite-colour starting-colour))))]</p>

<pre><code>  (when-let [move (random-move board colour)]
    (board/set-colour board move colour)))
</code></pre>

<p>  board)
```</p>

<p>You may notice that the above code actually only runs until one side has no moves &ndash; this is the first of many bugs.</p>

<p>The scoring and random-move code was a huge bottleneck so at the last minute I &lsquo;optimised&rsquo; it by changing it to:</p>

<p>``` clojure
;; rough approximation of the final score if the board is tightly packed
(defn score [board colour]
  (let [score (atom 0)]</p>

<pre><code>(dotimes [pos board/max-pos]
  (when (keyword-identical? colour (board/get-colour board pos))
    (swap! score inc)))
@score))
</code></pre>

<p>;; massive speedup at the expense of never playing in killed spaces
(defn with-random-moves-from [board n starting-colour moves]
  (js/goog.array.shuffle moves)
  (loop [colour starting-colour]</p>

<pre><code>(if-let [move (.pop moves)]
  (board/set-colour board move colour)
  (recur (board/opposite-colour colour))))
</code></pre>

<p>  board)
```</p>

<p>I think it is these two changes that are largely responsible for the submitted version playing so poorly &ndash; it doesn&rsquo;t check for eyes in the random playouts, doesn&rsquo;t allow the other player to keep killing strings when the ai player has no moves and doesn&rsquo;t count eyes in the final score. This explains why it likes to tightly pack pieces against the edge of the board.</p>

<h2>UCT</h2>

<p>While the monte-carlo estimate gives us a reasonable heuristic for move strength it doesn&rsquo;t re-use any information between passes. With such a large move space we need to explore more intelligently. The <a href="http://teytaud.over-blog.com/article-35709049.html">UCT</a> algorithm treats move-selection like a <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit problem</a>.</p>

<iframe width="640" height="360" src="http://scattered-thoughts.net//www.youtube.com/embed/dbvoPg51CqQ?feature=player_embedded" frameborder="0" allowfullscreen="allowfullscreen">video</iframe>


<p>We build a tree of moves where each node in the tree tracks not just the estimated score for all its child nodes but also the upper bound of a confidence interval on that estimate.</p>

<p><code>clojure
(defrecord Node [parent colour pos count sum nodes valids])
</code></p>

<p><code>colour</code> is the colour making the move at this node. <code>pos</code> is the position at which it is moving. <code>nodes</code> is a list of child nodes for which we have estimates. <code>valids</code> is a list of valid moves which have not yet been converted into nodes. <code>count</code> and <code>sum</code> track the mean score for all the children in <code>nodes</code>.</p>

<p>On each iteration we pick a path through the tree, choosing some explore/exploit tradeoff using the upper confidence bounds. Given the limited time we had, I decided to just copy a scoring function from a paper without stopping to understand it, so I don&rsquo;t actually know what explore/exploit tradeoff we are making :S</p>

<p>``` clojure
(defn best-child [node]
  (let [best-score (atom (&ndash; (/ 1 0)))</p>

<pre><code>    best-child (atom nil)]
(doseq [child (.-nodes node)]
  (let [score (+ (/ (.-sum child) (.-count child))
                 (js/Math.sqrt
                  (/ (* 2 (js/Math.log (.-count node)))
                     (* 5 (.-count child)))))]
    (when (&gt; score @best-score)
      (reset! best-score score)
      (reset! best-child child))))
@best-child))
</code></pre>

<p>(defn expand [board node ai-colour]
  (let [pos (.-pos node)]</p>

<pre><code>(if (not= 0 pos) ;; top node has pos 0 - probably a smell
  (board/set-colour board pos (.-colour node))))
</code></pre>

<p>  (if-let [valid-pos (.pop (.-valids node))]</p>

<pre><code>(.push (.-nodes node) (expand-leaf board ai-colour node (board/opposite-colour (.-colour node)) valid-pos))
(if-let [child (if (= (.-colour node) ai-colour)
                 (worst-child node)
                 (best-child node))]
  (expand board child ai-colour)
  nil ;; no possible moves - pass
  )))
</code></pre>

<p>```</p>

<p>On reaching a leaf we extend it by one more move, estimate the value of that move using monte-carlo simulations and then propagate the value back up the path to the top of tree.</p>

<p>``` clojure
(defn expand-leaf [board ai-colour parent colour pos]
  (board/set-colour board pos colour)
  (let [valids (valids board (board/opposite-colour colour))]</p>

<pre><code>(random/with-random-moves-from board 100 (board/opposite-colour colour) (aclone valids))
(let [value (value board ai-colour)]
  (add-value parent value)
  (-&gt;Node parent colour pos 1 value (object-array 0) valids))))
</code></pre>

<p>(defn add-value [node value]
  (set! (.-count node) (+ (.-count node) 1))
  (set! (.-sum node) (+ (.-sum node) value))
  (if-let [parent (.-parent node)]</p>

<pre><code>(recur parent value)))
</code></pre>

<p>```</p>

<p>Finally, the ai chooses its move by running a number of iterations of this algorithm and returning the value of <code>best-child</code> at the root (this is probably wrong &ndash; at this point we should just exploit, not explore).</p>

<p>``` clojure
(defn move-for [board colour n]
  (let [node (hugo-a-go-go.tree/new (board/copy board) colour)]</p>

<pre><code>(dotimes [_ n]
  (expand (board/copy board) node colour))
(when-let [child (best-child node)]
  (.-pos child))))
</code></pre>

<p>```</p>

<h2>Postmortem</h2>

<p>Together we spent around 20 man-hours on the competition. I spent the first two thirds of the competition just getting the board representation to work correctly. Part of the delay was that after moving to a cljs-only implementation the feedback loop was much slower. I wasted an hour or two tring to get brepl working without any success and after that had to rely on print statements and pre-compiled test cases. Finding errors in cljs also leaves a lot to be desired (eg a typo in a field name resulted in an <code>undefined</code> value which, several functions later, became a <code>NaN</code> which then behaves interestingly inside max/min). I only started on the UCT code an hour or two before the deadline. Tom started on the user input around the same time. We played our first game against the ai about five minutes before the deadline and frantically submitted whatever code we had running.</p>

<p>If we were taking it more seriously we certainly could have done a lot more to prepare &ndash; being familiar with the cljs dev tools, actually learning the rules of go, sketching out the board representation and the UCT implementation before the weekend started, not walking a marathon on the same weekend. But winning was not the goal and instead we had a lot of fun and excitement seeing just how much we can hack together in such a short space of time.</p>

<p>Our AI is definitely not correct so it&rsquo;s difficult to evaluate the project yet. The code is relatively short and simple (especially compared to eg <a href="http://git.savannah.gnu.org/cgit/gnugo.git/tree/engine">gnugo</a>) but that doesn&rsquo;t mean much until it actually works. The performance is promising &ndash; the current version can simulate around 5k games per second in chrome. Fixing the monte-carlo step and the scoring will eat into that performance but I&rsquo;ve already spotted plenty of inefficiencies in other places. We haven&rsquo;t even started experimenting with <a href="https://github.com/ztellman/vertigo">vertigo</a> or <a href="http://asmjs.org/">asm.js</a> yet so there is certainly lots of headroom.</p>

<p>I am definitely hoping to come back to this project. To echo <a href="http://www.youtube.com/watch?v=v5dYE0CMmHQ">Zach Tellman&rsquo;s motivation</a>, it will be really interesting to see if it is possible to write a competitive go AI in a high-level language. We&rsquo;ve also thought about distributing the UCT step and have team games pitching the aggregated wisdom of a group of human players voting on their next move against the assembled computing power of their browsing machines.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[External memory]]></title>
    <link href="http://scattered-thoughts.net/blog/2013/05/21/flowing-faster-external-memory/"/>
    <updated>2013-05-21T20:43:00-07:00</updated>
    <id>http://scattered-thoughts.net/blog/2013/05/21/flowing-faster-external-memory</id>
    <content type="html"><![CDATA[<p> What work I do that is worthwhile happens in the few hours of flow I manage to achieve every week. A million different things break that flow every day. I suspect that a large part of achieving flow is keeping the current problem in working memory. To improve my chances I can improve my working memory, offload parts of the problem to the computer or prevent context switches. I&rsquo;m on my own with the first option, but a better development environment can help with the latter two.</p>

<!--more-->


<p>The first thing that I want to fix in this series is offloading memory. There are basically two kinds of questions I regularly deal with:</p>

<ul>
<li><p>How did I solve this problem / build this software / configure this program X months ago?</p></li>
<li><p>What was I trying to remember to change X seconds ago?</p></li>
</ul>


<p>I&rsquo;ve started using <a href="http://jblevins.org/projects/deft/">deft</a> to answer both of these. Deft stores notes in a folder full of flat files and adds an incremental search buffer to emacs (searching > organising). This means that my notes are simple plain text which I can easily edit, backup, grep or serve on the web.</p>

<p>For long-term memory I create a new note every time I solve a problem or learn something useful. Within emacs M-&lsquo; brings up the deft window, typing triggers the incremental search and hiting Enter opens the first matching note.</p>

<p>For short-term memory I have a single note called stack. Hitting C-&lsquo; opens the stack note with the cursor on a new blank line for adding items to the stack. Hitting C-DEL deletes the previous line and C-q closes the stack. Hopefully this is sufficiently low-friction that the extra memory makes up for the context switch.</p>

<p>My config is <a href="https://github.com/jamii/emacs-live-packs/blob/master/deft-pack/init.el">here</a>. I&rsquo;m considering writing a gnome-shell extension which displays the last line of the stack in the status bar to remind me what I&rsquo;m supposed to be doing when my mental stack gets rudely dumped. I also want to add the global key bindings to gnome-shell so I don&rsquo;t have to navigate to emacs first.</p>

<p>This is a very simple tool, which is kind of the point. The more stucture and options added to a note-taking tool the more effort it takes to actually use it and the more likely it is that I lose my entire mental stack whilst doing so.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search trees and core.logic]]></title>
    <link href="http://scattered-thoughts.net/blog/2012/12/19/search-trees-and-core-dot-logic/"/>
    <updated>2012-12-19T20:32:00-08:00</updated>
    <id>http://scattered-thoughts.net/blog/2012/12/19/search-trees-and-core-dot-logic</id>
    <content type="html"><![CDATA[<p>I mentioned in an <a href="http://scattered-thoughts.net/blog/2012/12/02/hacker-school/">earlier post</a> that I had spent some time working on <a href="https://github.com/jamii/shackles">shackles</a>, an extensible <a href="http://en.wikipedia.org/wiki/Constraint_programming">constraint solver</a> based on <a href="http://www.gecode.org/">gecode</a> with extensions for <a href="http://en.wikipedia.org/wiki/Logic_programming">logic programming</a>. I eventually gave up working on shackles in favor of using <a href="https://github.com/clojure/core.logic">core.logic</a> which is much more mature and has actual maintainers. Last week David Nolen (the author of core.logic) was visiting Hacker School so I decided to poke around inside core.logic and see what could be brought over from shackles. The <a href="https://github.com/clojure/core.logic/pull/13">first chunk of work</a> adds fair conjunction, user-configurable search and a parallel solver.</p>

<!--more-->


<p>First, a little background. From a high-level point of view, a constraint solver does three things:</p>

<ul>
<li><p>specifies a search space in the form of a set of constraints</p></li>
<li><p>turns that search space into a search tree</p></li>
<li><p>searches the resulting tree for non-failed leaves</p></li>
</ul>


<p>Currently core.logic (and cKanren before it) complects all three of these. My patch partly decomplects the latter from the first two, allowing different search algorithms to be specified independently of the problem specification.</p>

<p>Let&rsquo;s look at how core.logic works. I&rsquo;m going to gloss over a lot of implementation details in order to make the core ideas clearer.</p>

<p>The search tree in core.logic is representated as a lazy stream of the non-failed leaves of the tree. This stream can be:</p>

<ul>
<li><p><code>nil</code> &ndash; the empty stream</p></li>
<li><p><code>(Choice. head tail)</code> &ndash; a cons cell</p></li>
</ul>


<p>Disjunction of two goals produces a new goal which contains the search trees of the two goals as adjacent branches. In core.logic, this is implemented by combining their streams with <code>mplus</code>. A naive implementation might look like this:</p>

<p>``` clojure
(defn mplus [stream1 stream2]
  (cond</p>

<pre><code>(nil? stream1) stream2
(choice? stream1) (Choice. (.head stream1) (mplus (.tail stream1) stream2))))
</code></pre>

<p>```</p>

<p>This amounts to a depth-first search of the leaves of the tree. Unfortunately, search trees in core.logic can be infinitely deep so a depth-first search can get stuck. If the first branch has an infinite subtree we will never see results from the second branch.</p>

<p>``` clojure
;; simple non-terminating goal
(def forevero
  (fresh []</p>

<pre><code>forevero))
</code></pre>

<p>(run* [q]
  (conde</p>

<pre><code>[forvero]
[(== q 1)]))
</code></pre>

<p>;; with depth-first search blocks immediately, returning (&hellip;)
;; with breadth-first search blocks after the first result, returning (1 &hellip;)
```</p>

<p>We can perform breadth-first search by adding a new stream type:</p>

<ul>
<li><code>(fn [] stream)</code> &ndash; a thunk representing a branch in the search tree</li>
</ul>


<p>And then interleaving results from each branch:</p>

<p>``` clojure
(defn mplus [stream1 stream2]
  (cond</p>

<pre><code>...
(fn? stream1) (fn [] (mplus stream2 (stream1)))))
</code></pre>

<p>```</p>

<p>This is how core.logic implements fair disjunction (fair in the sense that all branches of <code>conde</code> will be explored equally). However, we still have a problem with fair conjunction. Conjunction is performed in core.logic by running the second goal starting at each of the leaves of the tree of the first goal. In terms of the stream representation, this looks like:</p>

<p>``` clojure
(defn bind [stream goal]
  (cond</p>

<pre><code>(nil? stream) nil ;; failure
(choice? stream) (Choice. (bind (.head stream) goal) (bind (.tail stream) goal))
(fn? stream) (fn [] (bind (stream) goal))))
</code></pre>

<p>```</p>

<p>This gives rise to similar behaviour as the naive version of <code>mplus</code>:</p>

<p>``` clojure
(run* [q]
  (all</p>

<pre><code>forevero
(!= q q)))
</code></pre>

<p>;; with unfair conjunction blocks immediately, returning (&hellip;)
;; with fair conjunction the second branch causes failure, returning ()
```</p>

<p>I suspect the reason that core.logic didn&rsquo;t yet have fair conjunction is entirely due to this stream representation, which complects all three stages of constraint solving and hides the underlying search tree. Since shackles is based on gecode it has the advantage of a much clearer theoretical framework (I strongly recommend <a href="http://www.gecode.org/paper.html?id=Tack:PhD:2009">this paper</a>, not just for the insight into gecode but as a shining example of how mathematical intuition can be used to guide software design).</p>

<p>The first step in introducing fair conjunction to core.logic is to explicitly represent the search tree. The types are similar:</p>

<ul>
<li><code>nil</code> &ndash; the empty tree</li>
<li><code>(Result. state)</code> &ndash; a leaf</li>
<li><code>(Choice. left right)</code> &ndash; a branch</li>
<li><code>(Thunk. state goal)</code> &ndash; a thunk containing the current state and a sub-goal</li>
</ul>


<p>Defining <code>mplus</code> is now trivial since it is no longer responsible for interleaving results:</p>

<p><code>clojure
(defn mplus [tree1 tree2]
  (Choice. tree1 tree2))
</code></p>

<p>And we now have two variants of bind:</p>

<p>``` clojure
(defn bind-unfair [tree goal]
  (cond</p>

<pre><code>(nil? goal) nil ;; failure
(result? tree) (goal (.state tree)) ;; success, start the second tree here
(choice? tree) (Choice. (bind-unfair (.left tree) goal) (bind-unfair (.right tree) goal))
(thunk? tree) (Thunk. (.state tree) (bind-unfair ((.goal tree) state) goal))))
</code></pre>

<p>(defn bind-fair [tree goal]
  (cond</p>

<pre><code>(nil? goal) nil ;; failure
(result? tree) (goal (.state tree)) ;; success, start the second tree here
(choice? tree) (Choice. (bind-fair (.left tree) goal) (bind-fair (.right tree) goal))
(thunk? tree) (Thunk. (.state tree) (bind-fair (goal state) (.goal tree))))) ;; interleave!
</code></pre>

<p>```</p>

<p>The crucial difference here is that bind-fair takes advantage of the continuation-like thunk to interleave both goals, allowing each to do one thunk&rsquo;s worth of work before switching to the next.</p>

<p>(We keep bind-unfair around because it tends to be faster in practice &ndash; when you know what order your goals will be run in you can use domain knowledge to specify the most optimal order. However, making program evaluation dependent on goal ordering is less declarative and there are also some problems that cannot be specified without fair conjunction. It&rsquo;s nice to have both.)</p>

<p>Now that we explicity represent the tree we can use different search algorithms. My patch defaults to lazy, breadth-first search (to maintain the previous semantics) but it also supplies a variety of others including a <a href="https://github.com/jamii/core.logic/blob/flexible-search/src/main/clojure/clojure/core/logic/par.clj#L49">parallel depth-first search</a> using <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">fork-join</a>.</p>

<p>I still need to write a few more tests and sign the clojure contributor agreement before this can be considered for merging. I also have a pesky performance regression in lazy searches &ndash; this branch sometimes does more work than the original when only finding the first solution. I&rsquo;m not sure yet whether this is down to a lack of laziness somewhere or maybe just a result of a slightly different search order. Either way, it needs to be fixed.</p>

<p>After this change, core.logic still complects the specification of the search space and the generation of the search tree (eg we have to choose between bind-unfair and bind-fair in the problem specification). At some point I would like to either fix that in core.logic or finish work on shackles. For now though, I&rsquo;m going back to working on <a href="https://github.com/jamii/droplet">droplet</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strucjure: motivation]]></title>
    <link href="http://scattered-thoughts.net/blog/2012/12/04/strucjure-motivation/"/>
    <updated>2012-12-04T02:31:00-08:00</updated>
    <id>http://scattered-thoughts.net/blog/2012/12/04/strucjure-motivation</id>
    <content type="html"><![CDATA[<p>I feel that the readme for <a href="https://github.com/jamii/strucjure">strucjure</a> does a reasonable job of explaining how to use the library but not of explaining why you would want to. I want to do that here. I&rsquo;m going to focus on the motivation behind strucjure and the use cases for it rather than the internals, so try not to worry too much about how this all works and just focus on the ideas (the implementation itself is <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">very simple</a> but liable to keep changing).</p>

<!--more-->


<p>The core idea is that strucjure (and the <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;ved=0CFIQFjAD&amp;url=http%3A%2F%2Flambda-the-ultimate.org%2Fnode%2F2477&amp;ei=lQ69UJqrLK-WyAHC1IGIBg&amp;usg=AFQjCNEJAMQULpZ62ASYefNHadlUWTlgKA&amp;sig2=E1ePKzLJJNaFw5BfEG9rrA">OMeta</a> library on which it is based) is not just yet-another-parser, but is instead a concise language for describing, manipulating and transforming data structures. The <a href="http://www.vpri.org/">VPRI</a> folks have done some amazing things with OMeta. My goal with strucjure is to see how much further this idea can be taken.</p>

<p>(Note: For the purposes of this post I&rsquo;ll use the terms pattern and view interchangeably. There <em>is</em> a difference, but the line between the two is not yet clear to me and will probably change in future implementations)</p>

<h2>Pattern matching</h2>

<p>Pattern matching is a concept found in many functional languages. The basic idea is something like a switch statement, combined with a mini-language for describing patterns which the input should be tested against. The first pattern which matches has its corresponding branch executed.</p>

<p>As a very simple example, we can use strucjure to write fizzbuzz like this:</p>

<p>``` clojure
(doseq [i (range 100)]
  (prn
   (match [(mod i 3) (mod i 5)]</p>

<pre><code>      [0 0] "fizzbuzz"
      [0 _] "fizz"
      [_ 0] "buzz"
      _      i)))
</code></pre>

<p>```</p>

<p>This is a concise, readable description of the various cases and replaces a chain of if-statements.</p>

<p>If we stopped there, you could be forgiven for not caring. Simple examples don&rsquo;t really demonstrate the power of pattern matching. Let&rsquo;s instead look at a more complicated example &ndash; <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black trees</a>. An important operation on red-black trees is re-establishing the balance invariants after inserting a new node. Here is a java implementation of the balance operation (from <a href="http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">this implementation</a>):</p>

<p>``` java</p>

<pre><code>// make a left-leaning link lean to the right
private Node rotateRight(Node h) {
    assert (h != null) &amp;&amp; isRed(h.left);
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = x.right.color;
    x.right.color = RED;
    x.N = h.N;
    h.N = size(h.left) + size(h.right) + 1;
    return x;
}

// make a right-leaning link lean to the left
private Node rotateLeft(Node h) {
    assert (h != null) &amp;&amp; isRed(h.right);
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = x.left.color;
    x.left.color = RED;
    x.N = h.N;
    h.N = size(h.left) + size(h.right) + 1;
    return x;
}

// flip the colors of a node and its two children
private void flipColors(Node h) {
    // h must have opposite color of its two children
    assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);
    assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))
        || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));
    h.color = !h.color;
    h.left.color = !h.left.color;
    h.right.color = !h.right.color;
}

// restore red-black tree invariant
private Node balance(Node h) {
    assert (h != null);

    if (isRed(h.right))                      h = rotateLeft(h);
    if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);
    if (isRed(h.left) &amp;&amp; isRed(h.right))     flipColors(h);

    h.N = size(h.left) + size(h.right) + 1;
    return h;
}
</code></pre>

<p>```</p>

<p>This pile of if-statements obscures the intent of the code, which is to re-arrange the tree so that no red node has a red child. What we really want to see is &lsquo;if the tree looks like foo, replace it with bar&rsquo;. Using pattern matching we can express this directly (code based on <a href="http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec11.html">this implementation</a>):</p>

<p>``` clojure
(defrecord Leaf [])
(defrecord Red [left value right])
(defrecord Black [left value right])</p>

<p>(defview balance
  ;; if it looks like one of these&hellip;
  (or
   (Black. (Red. (Red. ?a ?x ?b) ?y ?c) ?z ?d)
   (Black. (Red. ?a ?x (Red. ?b ?y ?c)) ?z ?d)
   (Black. ?a ?x (Red. (Red. ?b ?y ?c) ?z ?d))
   (Black. ?a ?x (Red. ?b ?y (Red. ?c ?z ?d))))
  ;; replace it with this&hellip;
  (Red. (Black. a x b) y (Black. c z d))</p>

<p>  ;; otherwise, leave it alone
  ?other
  other)
```</p>

<p>(Note that this isn&rsquo;t exactly the same operation as the code above, because the corresponding implementation has a slightly different insert algorithm too. Nevertheless, converting this operation to java would result in the same grotesque expansion of if-statements).</p>

<p>Strucjure is not very optimized yet, but if you use a more mature pattern-matching library then this code would be as fast as what you would write by hand. For complex patterns <a href="https://github.com/clojure/core.match">core.match</a> often does a better job of optimizing the decision tree than I can manage by hand, in much the same way that GCC does a better job of writing assembly code than I ever could.</p>

<p>Strucjure patterns are first-class values and can call other patterns or recursively call themselves, so they can express much more complex patterns than other pattern matchers. For example:</p>

<p>``` clojure
(defview balanced-height
  Leaf
  0</p>

<p>  (and (Black. _</p>

<pre><code>     (balanced-height ?l)
     (balanced-height ?r))
   #(= l r))
</code></pre>

<p>  (+ 1 l)</p>

<p>  (and (Red. _</p>

<pre><code>     (and (not Red) (balanced-height ?l))
     (and (not Red) (balanced-height ?r)))
   #(= l r))
</code></pre>

<p>  l)
```</p>

<p>This is a pattern which only matches balanced red-black trees, by recursively matching against each branch and returning the number of black nodes per path (see property 5 <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Properties">here</a>).</p>

<h2>Parsing</h2>

<p>Strucjure supports patterns which only consume part of the input and can chain these patterns together. Combine that with pattern matching and you can very easily write back-tracking recursive-descent parsers.</p>

<p>We can use this for traditional text parsing (you have to be feeling a little masochistic at the moment because strucjure can&rsquo;t directly handle strings yet, only sequences of \c \h \a \r \s). For example, strucjure <a href="http://scattered-thoughts.net/blog/2012/10/25/strucjure-reading-the-readme/">parses its own readme</a> to ensure all the examples are correct.</p>

<p>Parsing doesn&rsquo;t have to be limited to text. We can apply the same techniques to any sequential data structure.</p>

<p>``` clojure
user> (defnview zero-or-more-prefix [elem]</p>

<pre><code>    (prefix &amp; (elem ?x) &amp; ((zero-or-more-prefix elem) ?xs)) (cons x xs)
    (prefix ) nil)
</code></pre>

<h1>&lsquo;user/zero-or-more-prefix</h1>

<p>user> (defview self-counting</p>

<pre><code>    (prefix 1) 'one
    (prefix 2 2) 'two
    (prefix 3 3 3) 'three)
</code></pre>

<h1>&lsquo;user/self-counting</h1>

<p>user> (run (zero-or-more-prefix self-counting) [1 3 3 3 2 2 1 2 2])
(one three two one two)
```</p>

<p>Since we live in lisp land, code is data too. We can use strucjure to easily and <em>readably</em> (hopefully) operate over sexps.</p>

<p>``` clojure
;; generic parser for (right-binding) infix operators with precedence</p>

<p>(defn value? [all form]
  (not-any? #(contains? % form) all))</p>

<p>(defn bind* [all current]
  (if-let [[ops &amp; tighter] current]</p>

<pre><code>(view
 (prefix &amp; ((bind* all tighter) ?x) (and #(contains? ops %) ?op) &amp; ((bind* all current) ?y)) `(~op ~x ~y)
 (prefix &amp; ((bind* all tighter) ?x)) x)
(view
 (prefix [((bind* all all) ?x)]) x
 (prefix (and #(value? all %) ?x)) x)))
</code></pre>

<p>(defn bind [binding-levels]
  (bind* binding-levels binding-levels))</p>

<p>;; run &lsquo;bind with basic arithmetic precedences
(defmacro math [&amp; args]
  (run (bind [#{&rsquo;+ &lsquo;&ndash;} #{&rsquo;* &lsquo;/}]) args))</p>

<p>(macroexpand &lsquo;(math 1 &ndash; 2 + 3 &ndash; 4))
;; (&ndash; 1 (+ 2 (&ndash; 3 4)))
(macroexpand &rsquo;(math 1 + 2 * 7 + 1 / 2))
;; (+ 1 (+ (<em> 2 7) (/ 1 2)))
(macroexpand &lsquo;(math 1 + 2 * (7 + 1) / 2))
;; (+ 1 (</em> 2 (/ (7 + 1) 2)))
```</p>

<p>No more death-by-polish-notation!</p>

<p>(The operators above really ought to bind to the left but, unlike ometa, strucjure doesn&rsquo;t yet support <a href="http://en.wikipedia.org/wiki/Left_recursion">left-recursion</a> and I&rsquo;m too lazy to manually transform the grammar. It&rsquo;s a temporary limitation.)</p>

<p>Taking this to its logical conclusion, the syntax for patterns and views in strucjure is itself defined <a href="https://github.com/jamii/strucjure/blob/master/src/strucjure/parser.clj#L178">using views</a>. This is a fairly complex DSL but with strucjure it&rsquo;s was very easy to write, read and modify the parser.</p>

<h2>Generic programming</h2>

<p>Clojure has some great facilities for generic traversals in the form of clojure.walk:</p>

<p>``` clojure
(defn walk
  &ldquo;Traverses form, an arbitrary data structure.  inner and outer are
  functions.  Applies inner to each element of form, building up a
  data structure of the same type, then applies outer to the result.
  Recognizes all Clojure data structures. Consumes seqs as with doall.&rdquo;</p>

<p>  {:added &ldquo;1.1&rdquo;}
  [inner outer form]
  (cond
   (list? form) (outer (apply list (map inner form)))
   (instance? clojure.lang.IMapEntry form) (outer (vec (map inner form)))
   (seq? form) (outer (doall (map inner form)))
   (coll? form) (outer (into (empty form) (map inner form)))
   :else (outer form)))</p>

<p>(defn postwalk
  &ldquo;Performs a depth-first, post-order traversal of form. Calls f on
each sub-form, uses f&rsquo;s return value in place of the original.
Recognizes all Clojure data structures except sorted-map-by.
Consumes seqs as with doall.&rdquo;
  {:added &ldquo;1.1&rdquo;}
  [f form]
  (walk (partial postwalk f) f form))
```</p>

<p>Essentially, all this is doing is specifying how to take apart clojure data structures and how to put them back together again. Strucjure supports passing optional :pre-view and :post-view functions to modify the input to or output from any named view encountered during parsing, so we can do something very similar:</p>

<p>``` clojure
(defview clojure
  (and list? ((zero-or-more clojure) ?xs)) xs
  (and clojure.lang.IMapEntry [?x ?y]) [x y]
  (and seq? ((zero-or-more clojure) ?xs)) xs
  (and coll? ?coll ((zero-or-more clojure) ?xs)) (into (empty coll) xs)
  ?other other)</p>

<p>(defn postwalk [form f]
  (run clojure form {:post-view (fn [_ sub-form] (f sub-form)}))
```</p>

<p>The problem with using this (or clojure.walk) for generic traversals is that it loses context. When a given sub-form is encountered, the function f is given no indication of where in the data structure that sub-form is or how it is being used. If we apply the above idea to domain-specific views we can do generic traversals <em>with context</em>. The motivating example for this was a simple game I was porting called <a href="https://github.com/jamii/l-seed">l-seed</a> (I haven&rsquo;t yet updated l-seed to use strucjure, but you can see a precursor to it in <a href="https://github.com/jamii/l-seed/blob/master/src/l_seed/syntax.clj">l-seed.syntax</a>). In l-seed, players submit programs defining the growth of their plant species and compete with other player&rsquo;s plants for sunlight and nutrients. The plant language can be defined like this:</p>

<p>``` clojure
(defview +name+
  string? %)</p>

<p>(defview +tag+
  string? %)</p>

<p>(defview +length+
  (and number? #(&lt;= 0 %)) %)</p>

<p>(defview +direction+
  (and number? #(&lt;= -360 % 360)) %)</p>

<p>(defview +relation+
  (or &lsquo;= &rsquo;> &lsquo;>= &rsquo;&lt; &lsquo;&lt;=) %)</p>

<p>(defview +property+
  (or &lsquo;tag 'length 'direction) %)</p>

<p>(defview +condition+
  [&lsquo;and &amp; ((zero-or-more +condition+) ?conditions)] (cons 'and conditions)
  ['or &amp; ((zero-or-more +condition+) ?conditions)] (cons 'or conditions)
  ['not (+condition+ ?condition)] (list 'not condition)
  [(+relation+ ?relation) (+property+ ?property) ?value] (list relation property value))</p>

<p>(defview +condition-head+
  [&lsquo;when (+condition+ ?condition)] (list 'when condition)
  'whenever 'whenever)</p>

<p>(defview +action+
  [&lsquo;grow-by (+length+ ?length)] (list 'grow-by length)
  ['turn-by (+direction+ ?direction)] (list 'turn-by direction)
  ['turn-to (+direction+ ?direction)] (list 'turn-to direction)
  ['tag (+tag+ ?tag)] (list 'tag tag)
  ['blossom (+tag+ ?tag)] (list 'blossom tag)
  ['branch &amp; ((zero-or-more (zero-or-more +action+)) ?action-lists)] (cons 'branch action-lists))</p>

<p>(defview +rule+
  [&lsquo;rule (+name+ ?name) (+condition-head+ ?condition-head) &amp; ((zero-or-more +action+) ?actions)] (apply list 'rule name condition-head actions))</p>

<p>(defview +rules+
  [&amp; ((zero-or-more +rule+) ?rules)] rules)
```</p>

<p>(Note that we specify both how to take apart a data structure and how to put it together. Really, the latter should be derived from the former. I think strucjure will eventually feature reversible patterns for this purpose.)</p>

<p>We can then operate on these programs in a generic way. For example, deciding which rule to execute next:</p>

<p>``` clojure
(defn select* [properties]
  (defview</p>

<pre><code>[`+relation+ ?relation] (resolve relation)
[`+property+ ?property] (get properties property)
[`+condition+ ['and &amp; ?conds]] (every? true? conds)
[`+condition+ ['or &amp; ?conds]] (some true? conds)
[`+condition+ ['not ?cond]] (not cond)
[`+condition+ [?relation ?property ?value]] (relation property value)
[`+condition-head+ ['when ?condition]] condition
[`+condition-head+ ['whenever]] true
[`+rule+ ['rule _ ?condition &amp; ?actions]] (when condition actions)
[`+rules+ [&amp; ?rules]] (choose (filter seq rules))
[_ ?other] other))
</code></pre>

<p>(defn select [rules properties]
  &ldquo;Pick a valid rule and return its list of actions (or nil if no rules are valid)&rdquo;
  (utilpostwalk +rules+ rules (select* properties)))
```</p>

<p>Writing code like this allows us to separate the shape of the data from the computation we perform over it.</p>

<p>We&rsquo;re also not limited to just walking over data structures. We can perform more complex operations in the same generic fashion.</p>

<p>``` clojure
(defn map-reduce [strucjure form map-op reduce-op]
  &ldquo;Call map-op on every sub-form and reduce results with reduce-op&rdquo;
  (let [acc (atom (reduce-op))]</p>

<pre><code>(run strucjure form
       {:post-view (fn [name form]
                     (swap! acc reduce-op (map-op name form))
                     form)})
@acc))
</code></pre>

<p>(defn collect [strucjure form filter-op]
  &ldquo;Return all sub-forms satisfying filter-op&rdquo;
  (let [acc (atom nil)]</p>

<pre><code>(run strucjure form
       {:post-view (fn [name form]
                     (if (filter-op name form)
                       (swap! acc conj result)))})
@acc))
</code></pre>

<p>```</p>

<h2>Types</h2>

<p>I originally learned to code in haskell. One of the things I miss about strong static typing is it that it automatically provides documentation about the data structures used in your program. Strucjure patterns can fulfill the same role. In l-seed, if you are confused about what a rule should look like you can just go look at the +rule+ pattern.</p>

<p>We can&rsquo;t quite get static typing out of this, but we do get runtime checking for complex typedata-structures:</p>

<p><code>clojure
(defmacro defgenotype [name &amp; rules]
  ;; compile-time syntax check for the genotype language
  (run +rules+ rules)
  `(def ~name '~(vec rules)))
</code></p>

<p>In theory, it should also be possible to generate random data structures satisfying a given pattern. This would be useful for providing examples and for <a href="https://github.com/clojure/test.generative">generative testing</a>. In erlang, <a href="https://github.com/manopapad/proper">proper</a> allows using type-specs directly alongside hand-written generators. I haven&rsquo;t yet implemented this in strucjure but I think it should be reasonably easy once reversible patterns are implemented.</p>

<h2>State machines</h2>

<p>One can think of parsers in general as state machines with look-ahead and backtracking. OMeta takes this idea and runs with it:</p>

<blockquote><p>Most  interesting  ideas  have  more  than  one  fruitful  way  to  view  them,  and  it  occurred  to  us  that,
abstractly,  one  could  think  of  TCP/IP  as  a  kind  of  “non‐deterministic  parser  with  balancing
heuristics”,  in  that  it  takes  in  a  stream  of  things,  does  various  kinds  of  pattern‐matching  on  them,
deals with errors by backing up and taking other paths, and produces a transformation of the input in
a specified form as a result.</p>

<p>Since the language transformation techniques we use operate on arbitrary objects, not just strings (see
above), and include some abilities of both standard and logic programming, it seemed that this could
be used to make a very compact TCP/IP. Our first attempt was about 160 lines of code that was robust
enough to run a website. We think this can be done even more compactly and clearly, and we plan to
take another pass at this next year.</p></blockquote>

<p>I haven&rsquo;t yet tried doing anything like this in strucjure, but all the machinery is there. It would make an interesting complement to <a href="https://github.com/jamii/droplet">droplet</a>.</p>

<h2>Moving forward</h2>

<p>There are of lot of different directions for improvement and experimentation.</p>

<p>One of my top priorities is better error reporting. This sucks:</p>

<p><code>clojure
clojure.lang.ExceptionInfo: throw+: #strucjure.view.PartialMatch{:view #strucjure.view.Or{:views [#strucjure.view.Match{:pattern #strucjure.pattern.Seq{:pattern #strucjure.pattern.Chain{:patterns [#strucjure.view.Import{:view-fun #&lt;test$bind_STAR_$fn__2339 test$bind_STAR_$fn__2339@60a896b8&gt;, :pattern #strucjure.pattern.Bind{:symbol x}} #strucjure.pattern.Head{:pattern #strucjure.pattern.And{:patterns [#strucjure.pattern.Guard{:fun #&lt; clojure.lang.AFunction$1@5c3f3b9b&gt;} #strucjure.pattern.Bind{:symbol op}]}} #strucjure.view.Import{:view-fun #&lt;test$bind_STAR_$fn__2343 test$bind_STAR_$fn__2343@3b626c6d&gt;, :pattern #strucjure.pattern.Bind{:symbol y}}]}}, :result-fun #&lt; clojure.lang.AFunction$1@3abc8690&gt;} #strucjure.view.Match{:pattern #strucjure.pattern.Seq{:pattern #strucjure.pattern.Chain{:patterns [#strucjure.view.Import{:view-fun #&lt;test$bind_STAR_$fn__2347 test$bind_STAR_$fn__2347@2f267610&gt;, :pattern #strucjure.pattern.Bind{:symbol x}}]}}, :result-fun #&lt; clojure.lang.AFunction$1@6112c9f&gt;}]}, :input (1 - 2 + 3 - 4), :remaining (- 2 + 3 - 4), :output 1}
</code></p>

<p>I have some ideas about how to improve this but nothing totally concrete. I could, at the very least, return the bindings that existed at the point of failure along with some kind of failure stack. If I can figure out a reasonable way to implement <a href="http://en.wikipedia.org/wiki/Cut_%28logic_programming%29">cut</a> that will also help.</p>

<p>Another short-term priority is some form of <a href="http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons">tail call elemination</a>. Many patterns and views are naturally implemented in a recursive fashion:</p>

<p><code>clojure
(defnview zero-or-more [elem]
  (prefix (elem ?x) &amp; ((zero-or-more elem) ?xs)) (cons x xs)
  (prefix ) nil)
</code></p>

<p>But in the current implementation of strucjure this will quickly overflow the stack. The current workaround is to define such views by hand:</p>

<p>``` clojure
(defrecord ZeroOrMore [view]
  View
  (run* [this input opts]</p>

<pre><code>(when (or
       (nil? input)
       (instance? clojure.lang.Seqable input))
  (loop [elems (seq input)
         outputs nil]
    (if-let [[elem &amp; elems] elems]
      (if-let [[remaining output] (run view elem opts)]
        (if (nil? remaining)
          (recur elems (cons output outputs))
          [(cons elem elems) (reverse outputs)])
        [(cons elem elems) (reverse outputs)])
      [nil (reverse outputs)])))))
</code></pre>

<p>(def zero-or-more &ndash;>ZeroOrMore)
```</p>

<p>This is gross. I don&rsquo;t have any ideas on how to overcome this.</p>

<p>I&rsquo;ve already briefly mentioned reversible patterns. At the beginning of this post I warned that I would use the terms view and pattern interchangeably. The line between them in strucjure is currently blurry but I think that the distinction should be that patterns must be reversible while views are allowed to destroy information.</p>

<p>Lastly, there will eventually be a need for some level of optimization. Given the extra flexibility in strucjure I don&rsquo;t expect to ever be as fast as core.match but there is certainly lots of room for improvement on the current code. Originally, strucjure patterns were compiled into efficient clojure code but the implementation was complicated and it was difficult to rapidly iterate around it. I will probably return to compilation once the semantics and interface settle down.</p>

<p>For now, I&rsquo;m going to dogfood strucjure in various projects while ruminating on improvements. I&rsquo;m already very happy with how much leverage can be had from such a simple idea, especially if I can fix the problems above. Hopefully the examples here might get other people thinking along the same lines.</p>
]]></content>
  </entry>
  
</feed>
